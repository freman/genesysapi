// Code generated by go-swagger; DO NOT EDIT.

package textbots

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery -name API -inpkg

// API is the interface of the textbots client
type API interface {
	/*
	   GetTextbotsBotsSearch finds bots using the currently configured friendly name or ID
	   The name does allow case-insensitive partial string matches or by IDs (up to 50), but not both at the same time. Optionally you can limit the scope of the search by providing one or more bot types.  You can specify the maximum results to return, up to a limit of 100
	*/
	GetTextbotsBotsSearch(ctx context.Context, params *GetTextbotsBotsSearchParams) (*GetTextbotsBotsSearchOK, error)
	/*
	   PostTextbotsBotflowsSessionTurns issues a bot flow turn event
	   Send a turn event to an executing bot flow and produce the next action to take.
	*/
	PostTextbotsBotflowsSessionTurns(ctx context.Context, params *PostTextbotsBotflowsSessionTurnsParams) (*PostTextbotsBotflowsSessionTurnsOK, error)
	/*
	   PostTextbotsBotflowsSessions creates an execution instance of a bot flow definition
	   The launch is asynchronous; use the returned instance ID to post turns to it using 'POST /api/v2/textbots/botflows/sessions/{sessionId}/turns'.
	*/
	PostTextbotsBotflowsSessions(ctx context.Context, params *PostTextbotsBotflowsSessionsParams) (*PostTextbotsBotflowsSessionsOK, error)
	/*
	   PostTextbotsBotsExecute sends an intent to a bot to start a dialog interact with it via text
	   This will either start a bot with the given id or relay a communication to an existing bot session.
	*/
	PostTextbotsBotsExecute(ctx context.Context, params *PostTextbotsBotsExecuteParams) (*PostTextbotsBotsExecuteOK, error)
}

// New creates a new textbots API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for textbots API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
GetTextbotsBotsSearch finds bots using the currently configured friendly name or ID

The name does allow case-insensitive partial string matches or by IDs (up to 50), but not both at the same time. Optionally you can limit the scope of the search by providing one or more bot types.  You can specify the maximum results to return, up to a limit of 100
*/
func (a *Client) GetTextbotsBotsSearch(ctx context.Context, params *GetTextbotsBotsSearchParams) (*GetTextbotsBotsSearchOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTextbotsBotsSearch",
		Method:             "GET",
		PathPattern:        "/api/v2/textbots/bots/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetTextbotsBotsSearchReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTextbotsBotsSearchOK), nil

}

/*
PostTextbotsBotflowsSessionTurns issues a bot flow turn event

Send a turn event to an executing bot flow and produce the next action to take.
*/
func (a *Client) PostTextbotsBotflowsSessionTurns(ctx context.Context, params *PostTextbotsBotflowsSessionTurnsParams) (*PostTextbotsBotflowsSessionTurnsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postTextbotsBotflowsSessionTurns",
		Method:             "POST",
		PathPattern:        "/api/v2/textbots/botflows/sessions/{sessionId}/turns",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostTextbotsBotflowsSessionTurnsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostTextbotsBotflowsSessionTurnsOK), nil

}

/*
PostTextbotsBotflowsSessions creates an execution instance of a bot flow definition

The launch is asynchronous; use the returned instance ID to post turns to it using 'POST /api/v2/textbots/botflows/sessions/{sessionId}/turns'.
*/
func (a *Client) PostTextbotsBotflowsSessions(ctx context.Context, params *PostTextbotsBotflowsSessionsParams) (*PostTextbotsBotflowsSessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postTextbotsBotflowsSessions",
		Method:             "POST",
		PathPattern:        "/api/v2/textbots/botflows/sessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostTextbotsBotflowsSessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostTextbotsBotflowsSessionsOK), nil

}

/*
PostTextbotsBotsExecute sends an intent to a bot to start a dialog interact with it via text

This will either start a bot with the given id or relay a communication to an existing bot session.
*/
func (a *Client) PostTextbotsBotsExecute(ctx context.Context, params *PostTextbotsBotsExecuteParams) (*PostTextbotsBotsExecuteOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postTextbotsBotsExecute",
		Method:             "POST",
		PathPattern:        "/api/v2/textbots/bots/execute",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostTextbotsBotsExecuteReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostTextbotsBotsExecuteOK), nil

}
