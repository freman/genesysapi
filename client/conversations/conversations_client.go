// Code generated by go-swagger; DO NOT EDIT.

package conversations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery -name API -inpkg

// API is the interface of the conversations client
type API interface {
	/*
	   DeleteAnalyticsConversationsDetailsJob deletes cancel an async request
	*/
	DeleteAnalyticsConversationsDetailsJob(ctx context.Context, params *DeleteAnalyticsConversationsDetailsJobParams) (*DeleteAnalyticsConversationsDetailsJobNoContent, error)
	/*
	   DeleteConversationParticipantCode deletes a code used to add a communication to this participant
	*/
	DeleteConversationParticipantCode(ctx context.Context, params *DeleteConversationParticipantCodeParams) error
	/*
	   DeleteConversationParticipantFlaggedreason removes flagged reason from conversation participant
	*/
	DeleteConversationParticipantFlaggedreason(ctx context.Context, params *DeleteConversationParticipantFlaggedreasonParams) (*DeleteConversationParticipantFlaggedreasonNoContent, error)
	/*
	   DeleteConversationsCallParticipantConsult cancels the transfer
	*/
	DeleteConversationsCallParticipantConsult(ctx context.Context, params *DeleteConversationsCallParticipantConsultParams) (*DeleteConversationsCallParticipantConsultOK, error)
	/*
	   DeleteConversationsEmailMessagesDraftAttachment deletes attachment from draft
	*/
	DeleteConversationsEmailMessagesDraftAttachment(ctx context.Context, params *DeleteConversationsEmailMessagesDraftAttachmentParams) (*DeleteConversationsEmailMessagesDraftAttachmentOK, error)
	/*
	   DeleteConversationsMessagingIntegrationsFacebookIntegrationID deletes a facebook messaging integration
	*/
	DeleteConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsFacebookIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsLineIntegrationID deletes a l i n e messenger integration
	*/
	DeleteConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsLineIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsLineIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsTwitterIntegrationID deletes a twitter messaging integration
	*/
	DeleteConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsTwitterIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsWhatsappIntegrationID deletes a whats app messaging integration
	*/
	DeleteConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error)
	/*
	   GetAnalyticsConversationDetails gets a conversation by id
	*/
	GetAnalyticsConversationDetails(ctx context.Context, params *GetAnalyticsConversationDetailsParams) (*GetAnalyticsConversationDetailsOK, error)
	/*
	   GetAnalyticsConversationsDetails gets multiple conversations by id
	*/
	GetAnalyticsConversationsDetails(ctx context.Context, params *GetAnalyticsConversationsDetailsParams) (*GetAnalyticsConversationsDetailsOK, error)
	/*
	   GetAnalyticsConversationsDetailsJob gets status for async query for conversation details
	*/
	GetAnalyticsConversationsDetailsJob(ctx context.Context, params *GetAnalyticsConversationsDetailsJobParams) (*GetAnalyticsConversationsDetailsJobOK, *GetAnalyticsConversationsDetailsJobAccepted, error)
	/*
	   GetAnalyticsConversationsDetailsJobResults fetches a page of results for an async query
	*/
	GetAnalyticsConversationsDetailsJobResults(ctx context.Context, params *GetAnalyticsConversationsDetailsJobResultsParams) (*GetAnalyticsConversationsDetailsJobResultsOK, error)
	/*
	   GetAnalyticsConversationsDetailsJobsAvailability lookups the datalake availability date and time
	*/
	GetAnalyticsConversationsDetailsJobsAvailability(ctx context.Context, params *GetAnalyticsConversationsDetailsJobsAvailabilityParams) (*GetAnalyticsConversationsDetailsJobsAvailabilityOK, error)
	/*
	   GetConversation gets conversation
	*/
	GetConversation(ctx context.Context, params *GetConversationParams) (*GetConversationOK, error)
	/*
	   GetConversationParticipantSecureivrsession fetches info on a secure session
	*/
	GetConversationParticipantSecureivrsession(ctx context.Context, params *GetConversationParticipantSecureivrsessionParams) (*GetConversationParticipantSecureivrsessionOK, error)
	/*
	   GetConversationParticipantSecureivrsessions gets a list of secure sessions for this participant
	*/
	GetConversationParticipantSecureivrsessions(ctx context.Context, params *GetConversationParticipantSecureivrsessionsParams) (*GetConversationParticipantSecureivrsessionsOK, error)
	/*
	   GetConversationParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationParticipantWrapup(ctx context.Context, params *GetConversationParticipantWrapupParams) (*GetConversationParticipantWrapupOK, error)
	/*
	   GetConversationParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationParticipantWrapupcodes(ctx context.Context, params *GetConversationParticipantWrapupcodesParams) (*GetConversationParticipantWrapupcodesOK, error)
	/*
	   GetConversations gets active conversations for the logged in user
	*/
	GetConversations(ctx context.Context, params *GetConversationsParams) (*GetConversationsOK, error)
	/*
	   GetConversationsCall gets call conversation
	*/
	GetConversationsCall(ctx context.Context, params *GetConversationsCallParams) (*GetConversationsCallOK, error)
	/*
	   GetConversationsCallParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsCallParticipantWrapup(ctx context.Context, params *GetConversationsCallParticipantWrapupParams) (*GetConversationsCallParticipantWrapupOK, error)
	/*
	   GetConversationsCallParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsCallParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallParticipantWrapupcodesParams) (*GetConversationsCallParticipantWrapupcodesOK, error)
	/*
	   GetConversationsCallback gets callback conversation
	*/
	GetConversationsCallback(ctx context.Context, params *GetConversationsCallbackParams) (*GetConversationsCallbackOK, error)
	/*
	   GetConversationsCallbackParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsCallbackParticipantWrapup(ctx context.Context, params *GetConversationsCallbackParticipantWrapupParams) (*GetConversationsCallbackParticipantWrapupOK, error)
	/*
	   GetConversationsCallbackParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsCallbackParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallbackParticipantWrapupcodesParams) (*GetConversationsCallbackParticipantWrapupcodesOK, error)
	/*
	   GetConversationsCallbacks gets active callback conversations for the logged in user
	*/
	GetConversationsCallbacks(ctx context.Context, params *GetConversationsCallbacksParams) (*GetConversationsCallbacksOK, error)
	/*
	   GetConversationsCalls gets active call conversations for the logged in user
	*/
	GetConversationsCalls(ctx context.Context, params *GetConversationsCallsParams) (*GetConversationsCallsOK, error)
	/*
	   GetConversationsCallsHistory gets call history
	*/
	GetConversationsCallsHistory(ctx context.Context, params *GetConversationsCallsHistoryParams) (*GetConversationsCallsHistoryOK, error)
	/*
	   GetConversationsCallsMaximumconferenceparties gets the maximum number of participants that this user can have on a conference
	*/
	GetConversationsCallsMaximumconferenceparties(ctx context.Context, params *GetConversationsCallsMaximumconferencepartiesParams) (*GetConversationsCallsMaximumconferencepartiesOK, error)
	/*
	   GetConversationsChat gets chat conversation
	*/
	GetConversationsChat(ctx context.Context, params *GetConversationsChatParams) (*GetConversationsChatOK, error)
	/*
	   GetConversationsChatMessage gets a web chat conversation message
	   The current user must be involved with the conversation to get its messages.
	*/
	GetConversationsChatMessage(ctx context.Context, params *GetConversationsChatMessageParams) (*GetConversationsChatMessageOK, error)
	/*
	   GetConversationsChatMessages gets the messages of a chat conversation
	   The current user must be involved with the conversation to get its messages.
	*/
	GetConversationsChatMessages(ctx context.Context, params *GetConversationsChatMessagesParams) (*GetConversationsChatMessagesOK, error)
	/*
	   GetConversationsChatParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsChatParticipantWrapup(ctx context.Context, params *GetConversationsChatParticipantWrapupParams) (*GetConversationsChatParticipantWrapupOK, error)
	/*
	   GetConversationsChatParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsChatParticipantWrapupcodes(ctx context.Context, params *GetConversationsChatParticipantWrapupcodesParams) (*GetConversationsChatParticipantWrapupcodesOK, error)
	/*
	   GetConversationsChats gets active chat conversations for the logged in user
	*/
	GetConversationsChats(ctx context.Context, params *GetConversationsChatsParams) (*GetConversationsChatsOK, error)
	/*
	   GetConversationsCobrowsesession gets cobrowse conversation
	*/
	GetConversationsCobrowsesession(ctx context.Context, params *GetConversationsCobrowsesessionParams) (*GetConversationsCobrowsesessionOK, error)
	/*
	   GetConversationsCobrowsesessionParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsCobrowsesessionParticipantWrapup(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupParams) (*GetConversationsCobrowsesessionParticipantWrapupOK, error)
	/*
	   GetConversationsCobrowsesessionParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsCobrowsesessionParticipantWrapupcodes(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupcodesParams) (*GetConversationsCobrowsesessionParticipantWrapupcodesOK, error)
	/*
	   GetConversationsCobrowsesessions gets active cobrowse conversations for the logged in user
	*/
	GetConversationsCobrowsesessions(ctx context.Context, params *GetConversationsCobrowsesessionsParams) (*GetConversationsCobrowsesessionsOK, error)
	/*
	   GetConversationsEmail gets email conversation
	*/
	GetConversationsEmail(ctx context.Context, params *GetConversationsEmailParams) (*GetConversationsEmailOK, error)
	/*
	   GetConversationsEmailMessage gets conversation message
	*/
	GetConversationsEmailMessage(ctx context.Context, params *GetConversationsEmailMessageParams) (*GetConversationsEmailMessageOK, error)
	/*
	   GetConversationsEmailMessages gets conversation messages
	*/
	GetConversationsEmailMessages(ctx context.Context, params *GetConversationsEmailMessagesParams) (*GetConversationsEmailMessagesOK, error)
	/*
	   GetConversationsEmailMessagesDraft gets conversation draft reply
	*/
	GetConversationsEmailMessagesDraft(ctx context.Context, params *GetConversationsEmailMessagesDraftParams) (*GetConversationsEmailMessagesDraftOK, error)
	/*
	   GetConversationsEmailParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsEmailParticipantWrapup(ctx context.Context, params *GetConversationsEmailParticipantWrapupParams) (*GetConversationsEmailParticipantWrapupOK, error)
	/*
	   GetConversationsEmailParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsEmailParticipantWrapupcodes(ctx context.Context, params *GetConversationsEmailParticipantWrapupcodesParams) (*GetConversationsEmailParticipantWrapupcodesOK, error)
	/*
	   GetConversationsEmails gets active email conversations for the logged in user
	*/
	GetConversationsEmails(ctx context.Context, params *GetConversationsEmailsParams) (*GetConversationsEmailsOK, error)
	/*
	   GetConversationsMessage gets message conversation
	*/
	GetConversationsMessage(ctx context.Context, params *GetConversationsMessageParams) (*GetConversationsMessageOK, error)
	/*
	   GetConversationsMessageCommunicationMessagesMediaMediaID gets media
	*/
	GetConversationsMessageCommunicationMessagesMediaMediaID(ctx context.Context, params *GetConversationsMessageCommunicationMessagesMediaMediaIDParams) (*GetConversationsMessageCommunicationMessagesMediaMediaIDOK, error)
	/*
	   GetConversationsMessageMessage gets message
	*/
	GetConversationsMessageMessage(ctx context.Context, params *GetConversationsMessageMessageParams) (*GetConversationsMessageMessageOK, error)
	/*
	   GetConversationsMessageParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsMessageParticipantWrapup(ctx context.Context, params *GetConversationsMessageParticipantWrapupParams) (*GetConversationsMessageParticipantWrapupOK, error)
	/*
	   GetConversationsMessageParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsMessageParticipantWrapupcodes(ctx context.Context, params *GetConversationsMessageParticipantWrapupcodesParams) (*GetConversationsMessageParticipantWrapupcodesOK, error)
	/*
	   GetConversationsMessages gets active message conversations for the logged in user
	*/
	GetConversationsMessages(ctx context.Context, params *GetConversationsMessagesParams) (*GetConversationsMessagesOK, error)
	/*
	   GetConversationsMessagingFacebookApp gets genesys facebook app Id
	*/
	GetConversationsMessagingFacebookApp(ctx context.Context, params *GetConversationsMessagingFacebookAppParams) (*GetConversationsMessagingFacebookAppOK, error)
	/*
	   GetConversationsMessagingIntegrations gets a list of integrations
	*/
	GetConversationsMessagingIntegrations(ctx context.Context, params *GetConversationsMessagingIntegrationsParams) (*GetConversationsMessagingIntegrationsOK, error)
	/*
	   GetConversationsMessagingIntegrationsFacebook gets a list of facebook integrations
	*/
	GetConversationsMessagingIntegrationsFacebook(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookParams) (*GetConversationsMessagingIntegrationsFacebookOK, error)
	/*
	   GetConversationsMessagingIntegrationsFacebookIntegrationID gets a facebook messaging integration
	*/
	GetConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*GetConversationsMessagingIntegrationsFacebookIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsLine gets a list of l i n e messenger integrations
	*/
	GetConversationsMessagingIntegrationsLine(ctx context.Context, params *GetConversationsMessagingIntegrationsLineParams) (*GetConversationsMessagingIntegrationsLineOK, error)
	/*
	   GetConversationsMessagingIntegrationsLineIntegrationID gets a l i n e messenger integration
	*/
	GetConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsLineIntegrationIDParams) (*GetConversationsMessagingIntegrationsLineIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsTwitter gets a list of twitter integrations
	*/
	GetConversationsMessagingIntegrationsTwitter(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterParams) (*GetConversationsMessagingIntegrationsTwitterOK, error)
	/*
	   GetConversationsMessagingIntegrationsTwitterIntegrationID gets a twitter messaging integration
	*/
	GetConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*GetConversationsMessagingIntegrationsTwitterIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsWhatsapp gets a list of whats app integrations
	*/
	GetConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappParams) (*GetConversationsMessagingIntegrationsWhatsappOK, error)
	/*
	   GetConversationsMessagingIntegrationsWhatsappIntegrationID gets a whats app messaging integration
	*/
	GetConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*GetConversationsMessagingIntegrationsWhatsappIntegrationIDOK, error)
	/*
	   GetConversationsMessagingSticker gets a list of messaging stickers
	*/
	GetConversationsMessagingSticker(ctx context.Context, params *GetConversationsMessagingStickerParams) (*GetConversationsMessagingStickerOK, error)
	/*
	   PatchConversationParticipant updates a participant
	   Update conversation participant.
	*/
	PatchConversationParticipant(ctx context.Context, params *PatchConversationParticipantParams) (*PatchConversationParticipantAccepted, error)
	/*
	   PatchConversationParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationParticipantAttributes(ctx context.Context, params *PatchConversationParticipantAttributesParams) (*PatchConversationParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCall updates a conversation by setting it s recording state merging in other conversations to create a conference or disconnecting all of the participants
	*/
	PatchConversationsCall(ctx context.Context, params *PatchConversationsCallParams) (*PatchConversationsCallOK, *PatchConversationsCallAccepted, error)
	/*
	   PatchConversationsCallParticipant updates conversation participant
	*/
	PatchConversationsCallParticipant(ctx context.Context, params *PatchConversationsCallParticipantParams) (*PatchConversationsCallParticipantAccepted, error)
	/*
	   PatchConversationsCallParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsCallParticipantAttributes(ctx context.Context, params *PatchConversationsCallParticipantAttributesParams) (*PatchConversationsCallParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCallParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsCallParticipantCommunication(ctx context.Context, params *PatchConversationsCallParticipantCommunicationParams) (*PatchConversationsCallParticipantCommunicationOK, error)
	/*
	   PatchConversationsCallParticipantConsult changes who can speak
	*/
	PatchConversationsCallParticipantConsult(ctx context.Context, params *PatchConversationsCallParticipantConsultParams) (*PatchConversationsCallParticipantConsultOK, error)
	/*
	   PatchConversationsCallback updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsCallback(ctx context.Context, params *PatchConversationsCallbackParams) (*PatchConversationsCallbackOK, error)
	/*
	   PatchConversationsCallbackParticipant updates conversation participant
	*/
	PatchConversationsCallbackParticipant(ctx context.Context, params *PatchConversationsCallbackParticipantParams) (*PatchConversationsCallbackParticipantAccepted, error)
	/*
	   PatchConversationsCallbackParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsCallbackParticipantAttributes(ctx context.Context, params *PatchConversationsCallbackParticipantAttributesParams) (*PatchConversationsCallbackParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCallbackParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsCallbackParticipantCommunication(ctx context.Context, params *PatchConversationsCallbackParticipantCommunicationParams) (*PatchConversationsCallbackParticipantCommunicationOK, error)
	/*
	   PatchConversationsChat updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsChat(ctx context.Context, params *PatchConversationsChatParams) (*PatchConversationsChatOK, error)
	/*
	   PatchConversationsChatParticipant updates conversation participant
	*/
	PatchConversationsChatParticipant(ctx context.Context, params *PatchConversationsChatParticipantParams) (*PatchConversationsChatParticipantAccepted, error)
	/*
	   PatchConversationsChatParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsChatParticipantAttributes(ctx context.Context, params *PatchConversationsChatParticipantAttributesParams) (*PatchConversationsChatParticipantAttributesAccepted, error)
	/*
	   PatchConversationsChatParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsChatParticipantCommunication(ctx context.Context, params *PatchConversationsChatParticipantCommunicationParams) (*PatchConversationsChatParticipantCommunicationOK, error)
	/*
	   PatchConversationsCobrowsesession updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsCobrowsesession(ctx context.Context, params *PatchConversationsCobrowsesessionParams) (*PatchConversationsCobrowsesessionOK, error)
	/*
	   PatchConversationsCobrowsesessionParticipant updates conversation participant
	*/
	PatchConversationsCobrowsesessionParticipant(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantParams) (*PatchConversationsCobrowsesessionParticipantAccepted, error)
	/*
	   PatchConversationsCobrowsesessionParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsCobrowsesessionParticipantAttributes(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantAttributesParams) (*PatchConversationsCobrowsesessionParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCobrowsesessionParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsCobrowsesessionParticipantCommunication(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantCommunicationParams) (*PatchConversationsCobrowsesessionParticipantCommunicationOK, error)
	/*
	   PatchConversationsEmail updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsEmail(ctx context.Context, params *PatchConversationsEmailParams) (*PatchConversationsEmailOK, error)
	/*
	   PatchConversationsEmailParticipant updates conversation participant
	*/
	PatchConversationsEmailParticipant(ctx context.Context, params *PatchConversationsEmailParticipantParams) (*PatchConversationsEmailParticipantAccepted, error)
	/*
	   PatchConversationsEmailParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsEmailParticipantAttributes(ctx context.Context, params *PatchConversationsEmailParticipantAttributesParams) (*PatchConversationsEmailParticipantAttributesAccepted, error)
	/*
	   PatchConversationsEmailParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsEmailParticipantCommunication(ctx context.Context, params *PatchConversationsEmailParticipantCommunicationParams) (*PatchConversationsEmailParticipantCommunicationOK, error)
	/*
	   PatchConversationsMessage updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsMessage(ctx context.Context, params *PatchConversationsMessageParams) (*PatchConversationsMessageOK, error)
	/*
	   PatchConversationsMessageParticipant updates conversation participant
	*/
	PatchConversationsMessageParticipant(ctx context.Context, params *PatchConversationsMessageParticipantParams) (*PatchConversationsMessageParticipantAccepted, error)
	/*
	   PatchConversationsMessageParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsMessageParticipantAttributes(ctx context.Context, params *PatchConversationsMessageParticipantAttributesParams) (*PatchConversationsMessageParticipantAttributesAccepted, error)
	/*
	   PatchConversationsMessageParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsMessageParticipantCommunication(ctx context.Context, params *PatchConversationsMessageParticipantCommunicationParams) (*PatchConversationsMessageParticipantCommunicationOK, error)
	/*
	   PatchConversationsMessagingIntegrationsFacebookIntegrationID updates facebook messaging integration
	*/
	PatchConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*PatchConversationsMessagingIntegrationsFacebookIntegrationIDOK, error)
	/*
	   PatchConversationsMessagingIntegrationsTwitterIntegrationID updates twitter messaging integration
	*/
	PatchConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*PatchConversationsMessagingIntegrationsTwitterIntegrationIDOK, error)
	/*
	   PatchConversationsMessagingIntegrationsWhatsappIntegrationID updates or activate a whats app messaging integration
	   The following steps are required in order to fully activate a Whatsapp Integration: Initially, you will need to get an activation code by sending: an action set to Activate, and an authenticationMethod choosing from Sms or Voice. Finally, once you have been informed of an activation code on selected authenticationMethod, you will need to confirm the code by sending: an action set to Confirm, and the confirmationCode you have received from Whatsapp.
	*/
	PatchConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*PatchConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error)
	/*
	   PostAnalyticsConversationDetailsProperties indices conversation properties
	*/
	PostAnalyticsConversationDetailsProperties(ctx context.Context, params *PostAnalyticsConversationDetailsPropertiesParams) (*PostAnalyticsConversationDetailsPropertiesAccepted, error)
	/*
	   PostAnalyticsConversationsAggregatesQuery queries for conversation aggregates
	*/
	PostAnalyticsConversationsAggregatesQuery(ctx context.Context, params *PostAnalyticsConversationsAggregatesQueryParams) (*PostAnalyticsConversationsAggregatesQueryOK, error)
	/*
	   PostAnalyticsConversationsDetailsJobs queries for conversation details asynchronously
	*/
	PostAnalyticsConversationsDetailsJobs(ctx context.Context, params *PostAnalyticsConversationsDetailsJobsParams) (*PostAnalyticsConversationsDetailsJobsAccepted, error)
	/*
	   PostAnalyticsConversationsDetailsQuery queries for conversation details
	*/
	PostAnalyticsConversationsDetailsQuery(ctx context.Context, params *PostAnalyticsConversationsDetailsQueryParams) (*PostAnalyticsConversationsDetailsQueryOK, error)
	/*
	   PostConversationAssign attempts to manually assign a specified conversation to a specified agent ignores bullseye ring p a r score skills and languages
	*/
	PostConversationAssign(ctx context.Context, params *PostConversationAssignParams) (*PostConversationAssignAccepted, error)
	/*
	   PostConversationDisconnect performs a full conversation teardown issues disconnect requests for any connected media applies a system wrap up code to any participants that are pending wrap up this is not intended to be the normal way of ending interactions but is available in the event of problems with the application to allow a resynchronization of state across all components it is recommended that users submit a support case if they are relying on this endpoint systematically as there is likely something that needs investigation
	*/
	PostConversationDisconnect(ctx context.Context, params *PostConversationDisconnectParams) (*PostConversationDisconnectAccepted, error)
	/*
	   PostConversationParticipantCallbacks creates a new callback for the specified participant on the conversation
	*/
	PostConversationParticipantCallbacks(ctx context.Context, params *PostConversationParticipantCallbacksParams) (*PostConversationParticipantCallbacksCreated, error)
	/*
	   PostConversationParticipantDigits sends d t m f to the participant
	*/
	PostConversationParticipantDigits(ctx context.Context, params *PostConversationParticipantDigitsParams) (*PostConversationParticipantDigitsAccepted, error)
	/*
	   PostConversationParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationParticipantReplace(ctx context.Context, params *PostConversationParticipantReplaceParams) (*PostConversationParticipantReplaceAccepted, error)
	/*
	   PostConversationParticipantSecureivrsessions creates secure i v r session only a participant in the conversation can invoke a secure i v r
	*/
	PostConversationParticipantSecureivrsessions(ctx context.Context, params *PostConversationParticipantSecureivrsessionsParams) (*PostConversationParticipantSecureivrsessionsOK, error)
	/*
	   PostConversationsCall places a new call as part of a callback conversation
	*/
	PostConversationsCall(ctx context.Context, params *PostConversationsCallParams) (*PostConversationsCallOK, error)
	/*
	   PostConversationsCallParticipantCoach listens in on the conversation from the point of view of a given participant while speaking to just the given participant
	*/
	PostConversationsCallParticipantCoach(ctx context.Context, params *PostConversationsCallParticipantCoachParams) (*PostConversationsCallParticipantCoachCreated, error)
	/*
	   PostConversationsCallParticipantConsult initiates and update consult transfer
	*/
	PostConversationsCallParticipantConsult(ctx context.Context, params *PostConversationsCallParticipantConsultParams) (*PostConversationsCallParticipantConsultOK, error)
	/*
	   PostConversationsCallParticipantMonitor listens in on the conversation from the point of view of a given participant
	*/
	PostConversationsCallParticipantMonitor(ctx context.Context, params *PostConversationsCallParticipantMonitorParams) (*PostConversationsCallParticipantMonitorCreated, error)
	/*
	   PostConversationsCallParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsCallParticipantReplace(ctx context.Context, params *PostConversationsCallParticipantReplaceParams) (*PostConversationsCallParticipantReplaceAccepted, error)
	/*
	   PostConversationsCallParticipants adds participants to a conversation
	*/
	PostConversationsCallParticipants(ctx context.Context, params *PostConversationsCallParticipantsParams) (*PostConversationsCallParticipantsOK, error)
	/*
	   PostConversationsCallbackParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsCallbackParticipantReplace(ctx context.Context, params *PostConversationsCallbackParticipantReplaceParams) (*PostConversationsCallbackParticipantReplaceAccepted, error)
	/*
	   PostConversationsCallbacks creates a callback
	*/
	PostConversationsCallbacks(ctx context.Context, params *PostConversationsCallbacksParams) (*PostConversationsCallbacksOK, *PostConversationsCallbacksAccepted, error)
	/*
	   PostConversationsCalls creates a call conversation
	*/
	PostConversationsCalls(ctx context.Context, params *PostConversationsCallsParams) (*PostConversationsCallsOK, error)
	/*
	   PostConversationsChatCommunicationMessages sends a message on behalf of a communication in a chat conversation
	*/
	PostConversationsChatCommunicationMessages(ctx context.Context, params *PostConversationsChatCommunicationMessagesParams) (*PostConversationsChatCommunicationMessagesOK, error)
	/*
	   PostConversationsChatCommunicationTyping sends a typing indicator on behalf of a communication in a chat conversation
	*/
	PostConversationsChatCommunicationTyping(ctx context.Context, params *PostConversationsChatCommunicationTypingParams) (*PostConversationsChatCommunicationTypingOK, error)
	/*
	   PostConversationsChatParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsChatParticipantReplace(ctx context.Context, params *PostConversationsChatParticipantReplaceParams) (*PostConversationsChatParticipantReplaceAccepted, error)
	/*
	   PostConversationsChats creates a web chat conversation
	*/
	PostConversationsChats(ctx context.Context, params *PostConversationsChatsParams) (*PostConversationsChatsOK, error)
	/*
	   PostConversationsCobrowsesessionParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsCobrowsesessionParticipantReplace(ctx context.Context, params *PostConversationsCobrowsesessionParticipantReplaceParams) (*PostConversationsCobrowsesessionParticipantReplaceAccepted, error)
	/*
	   PostConversationsEmailInboundmessages sends an email to an external conversation an external conversation is one where the provider is not pure cloud based this endpoint allows the sender of the external email to reply or send a new message to the existing conversation the new message will be treated as part of the existing conversation and chained to it
	*/
	PostConversationsEmailInboundmessages(ctx context.Context, params *PostConversationsEmailInboundmessagesParams) (*PostConversationsEmailInboundmessagesOK, error)
	/*
	   PostConversationsEmailMessages sends an email reply
	*/
	PostConversationsEmailMessages(ctx context.Context, params *PostConversationsEmailMessagesParams) (*PostConversationsEmailMessagesOK, error)
	/*
	   PostConversationsEmailMessagesDraftAttachmentsCopy copies attachments from an email message to the current draft
	*/
	PostConversationsEmailMessagesDraftAttachmentsCopy(ctx context.Context, params *PostConversationsEmailMessagesDraftAttachmentsCopyParams) (*PostConversationsEmailMessagesDraftAttachmentsCopyOK, error)
	/*
	   PostConversationsEmailParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsEmailParticipantReplace(ctx context.Context, params *PostConversationsEmailParticipantReplaceParams) (*PostConversationsEmailParticipantReplaceAccepted, error)
	/*
	   PostConversationsEmails creates an email conversation
	   If the direction of the request is INBOUND, this will create an external conversation with a third party provider. If the direction of the the request is OUTBOUND, this will create a conversation to send outbound emails on behalf of a queue.
	*/
	PostConversationsEmails(ctx context.Context, params *PostConversationsEmailsParams) (*PostConversationsEmailsOK, error)
	/*
	   PostConversationsFaxes creates fax conversation
	*/
	PostConversationsFaxes(ctx context.Context, params *PostConversationsFaxesParams) (*PostConversationsFaxesOK, error)
	/*
	   PostConversationsMessageCommunicationMessages sends message
	   Send message on existing conversation/communication. Only one message body field can be accepted, per request. Example: 1 textBody, 1 mediaId, 1 stickerId, or 1 messageTemplate.
	*/
	PostConversationsMessageCommunicationMessages(ctx context.Context, params *PostConversationsMessageCommunicationMessagesParams) (*PostConversationsMessageCommunicationMessagesOK, *PostConversationsMessageCommunicationMessagesAccepted, error)
	/*
	   PostConversationsMessageCommunicationMessagesMedia creates media
	*/
	PostConversationsMessageCommunicationMessagesMedia(ctx context.Context, params *PostConversationsMessageCommunicationMessagesMediaParams) (*PostConversationsMessageCommunicationMessagesMediaOK, *PostConversationsMessageCommunicationMessagesMediaAccepted, error)
	/*
	   PostConversationsMessageMessagesBulk gets messages in batch
	   The path parameter [conversationId] should contain the conversationId of the conversation being filtered. The body should contain the messageId(s) of messages being requested. For example: ["a3069a33b-bbb1-4703-9d68-061d9e9db96e", "55bc6be3-078c-4a49-a4e6-1e05776ed7e8"]
	*/
	PostConversationsMessageMessagesBulk(ctx context.Context, params *PostConversationsMessageMessagesBulkParams) (*PostConversationsMessageMessagesBulkOK, error)
	/*
	   PostConversationsMessageParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsMessageParticipantReplace(ctx context.Context, params *PostConversationsMessageParticipantReplaceParams) (*PostConversationsMessageParticipantReplaceAccepted, error)
	/*
	   PostConversationsMessages creates an outbound messaging conversation
	   If there is an existing conversation between the remote address and the address associated with the queue specified in createOutboundRequest then the result of this request depends on the state of that conversation and the useExistingConversation field of createOutboundRequest. If the existing conversation is in alerting or connected state, then the request will fail. If the existing conversation is disconnected but still within the conversation window then the request will fail unless useExistingConversation is set to true.
	*/
	PostConversationsMessages(ctx context.Context, params *PostConversationsMessagesParams) (*PostConversationsMessagesOK, error)
	/*
	   PostConversationsMessagesAgentless sends an agentless outbound message
	   Send an agentlesss (api participant) outbound message using a client credential grant. In order to call this endpoint you will need OAuth token generated using OAuth client credentials authorized with at least messaging scope. This will generate a new Conversation, if there is an existing active Conversation between the fromAddress and toAddress already, then this POST will fail.
	*/
	PostConversationsMessagesAgentless(ctx context.Context, params *PostConversationsMessagesAgentlessParams) (*PostConversationsMessagesAgentlessOK, *PostConversationsMessagesAgentlessAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsFacebook creates a facebook integration
	*/
	PostConversationsMessagingIntegrationsFacebook(ctx context.Context, params *PostConversationsMessagingIntegrationsFacebookParams) (*PostConversationsMessagingIntegrationsFacebookOK, *PostConversationsMessagingIntegrationsFacebookAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsLine creates a l i n e messenger integration
	*/
	PostConversationsMessagingIntegrationsLine(ctx context.Context, params *PostConversationsMessagingIntegrationsLineParams) (*PostConversationsMessagingIntegrationsLineOK, *PostConversationsMessagingIntegrationsLineAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsTwitter creates a twitter integration
	*/
	PostConversationsMessagingIntegrationsTwitter(ctx context.Context, params *PostConversationsMessagingIntegrationsTwitterParams) (*PostConversationsMessagingIntegrationsTwitterOK, *PostConversationsMessagingIntegrationsTwitterAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsWhatsapp creates a whats app integration
	   You must be approved by WhatsApp to use this feature. Your approved e164-formatted phone number and valid WhatsApp certificate for your number are required. Your WhatsApp certificate must have valid base64 encoding. Please paste carefully and do not add any leading or trailing spaces. Do not alter any characters. An integration must be activated within 7 days of certificate generation. If you cannot complete the addition and activation of the number within 7 days, please obtain a new certificate before creating the integration. Integrations created with an invalid number or certificate may immediately incur additional integration fees. Please carefully enter your number and certificate as described.
	*/
	PostConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *PostConversationsMessagingIntegrationsWhatsappParams) (*PostConversationsMessagingIntegrationsWhatsappOK, error)
	/*
	   PutConversationParticipantFlaggedreason sets flagged reason on conversation participant to indicate bad conversation quality
	*/
	PutConversationParticipantFlaggedreason(ctx context.Context, params *PutConversationParticipantFlaggedreasonParams) (*PutConversationParticipantFlaggedreasonNoContent, error)
	/*
	   PutConversationsCallParticipantCommunicationUuidata sets uui data to be sent on future commands
	*/
	PutConversationsCallParticipantCommunicationUuidata(ctx context.Context, params *PutConversationsCallParticipantCommunicationUuidataParams) (*PutConversationsCallParticipantCommunicationUuidataOK, *PutConversationsCallParticipantCommunicationUuidataNoContent, error)
	/*
	   PutConversationsEmailMessagesDraft updates conversation draft reply
	*/
	PutConversationsEmailMessagesDraft(ctx context.Context, params *PutConversationsEmailMessagesDraftParams) (*PutConversationsEmailMessagesDraftOK, error)
	/*
	   PutConversationsMessagingIntegrationsLineIntegrationID updates a l i n e messenger integration
	*/
	PutConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *PutConversationsMessagingIntegrationsLineIntegrationIDParams) (*PutConversationsMessagingIntegrationsLineIntegrationIDOK, error)
}

// New creates a new conversations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for conversations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
DeleteAnalyticsConversationsDetailsJob deletes cancel an async request
*/
func (a *Client) DeleteAnalyticsConversationsDetailsJob(ctx context.Context, params *DeleteAnalyticsConversationsDetailsJobParams) (*DeleteAnalyticsConversationsDetailsJobNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteAnalyticsConversationsDetailsJob",
		Method:             "DELETE",
		PathPattern:        "/api/v2/analytics/conversations/details/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteAnalyticsConversationsDetailsJobReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteAnalyticsConversationsDetailsJobNoContent), nil

}

/*
DeleteConversationParticipantCode deletes a code used to add a communication to this participant
*/
func (a *Client) DeleteConversationParticipantCode(ctx context.Context, params *DeleteConversationParticipantCodeParams) error {

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationParticipantCode",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/codes/{addCommunicationCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationParticipantCodeReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
DeleteConversationParticipantFlaggedreason removes flagged reason from conversation participant
*/
func (a *Client) DeleteConversationParticipantFlaggedreason(ctx context.Context, params *DeleteConversationParticipantFlaggedreasonParams) (*DeleteConversationParticipantFlaggedreasonNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationParticipantFlaggedreason",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationParticipantFlaggedreasonReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationParticipantFlaggedreasonNoContent), nil

}

/*
DeleteConversationsCallParticipantConsult cancels the transfer
*/
func (a *Client) DeleteConversationsCallParticipantConsult(ctx context.Context, params *DeleteConversationsCallParticipantConsultParams) (*DeleteConversationsCallParticipantConsultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsCallParticipantConsult",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsCallParticipantConsultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsCallParticipantConsultOK), nil

}

/*
DeleteConversationsEmailMessagesDraftAttachment deletes attachment from draft
*/
func (a *Client) DeleteConversationsEmailMessagesDraftAttachment(ctx context.Context, params *DeleteConversationsEmailMessagesDraftAttachmentParams) (*DeleteConversationsEmailMessagesDraftAttachmentOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsEmailMessagesDraftAttachment",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/{attachmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsEmailMessagesDraftAttachmentReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsEmailMessagesDraftAttachmentOK), nil

}

/*
DeleteConversationsMessagingIntegrationsFacebookIntegrationID deletes a facebook messaging integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsFacebookIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsFacebookIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsFacebookIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsFacebookIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsLineIntegrationID deletes a l i n e messenger integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsLineIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsLineIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsLineIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsLineIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsLineIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsTwitterIntegrationID deletes a twitter messaging integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsTwitterIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsTwitterIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsTwitterIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsTwitterIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsWhatsappIntegrationID deletes a whats app messaging integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsWhatsappIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDOK:
		return value, nil, nil
	case *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetAnalyticsConversationDetails gets a conversation by id
*/
func (a *Client) GetAnalyticsConversationDetails(ctx context.Context, params *GetAnalyticsConversationDetailsParams) (*GetAnalyticsConversationDetailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAnalyticsConversationDetails",
		Method:             "GET",
		PathPattern:        "/api/v2/analytics/conversations/{conversationId}/details",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAnalyticsConversationDetailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAnalyticsConversationDetailsOK), nil

}

/*
GetAnalyticsConversationsDetails gets multiple conversations by id
*/
func (a *Client) GetAnalyticsConversationsDetails(ctx context.Context, params *GetAnalyticsConversationsDetailsParams) (*GetAnalyticsConversationsDetailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAnalyticsConversationsDetails",
		Method:             "GET",
		PathPattern:        "/api/v2/analytics/conversations/details",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAnalyticsConversationsDetailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAnalyticsConversationsDetailsOK), nil

}

/*
GetAnalyticsConversationsDetailsJob gets status for async query for conversation details
*/
func (a *Client) GetAnalyticsConversationsDetailsJob(ctx context.Context, params *GetAnalyticsConversationsDetailsJobParams) (*GetAnalyticsConversationsDetailsJobOK, *GetAnalyticsConversationsDetailsJobAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAnalyticsConversationsDetailsJob",
		Method:             "GET",
		PathPattern:        "/api/v2/analytics/conversations/details/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAnalyticsConversationsDetailsJobReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetAnalyticsConversationsDetailsJobOK:
		return value, nil, nil
	case *GetAnalyticsConversationsDetailsJobAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetAnalyticsConversationsDetailsJobResults fetches a page of results for an async query
*/
func (a *Client) GetAnalyticsConversationsDetailsJobResults(ctx context.Context, params *GetAnalyticsConversationsDetailsJobResultsParams) (*GetAnalyticsConversationsDetailsJobResultsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAnalyticsConversationsDetailsJobResults",
		Method:             "GET",
		PathPattern:        "/api/v2/analytics/conversations/details/jobs/{jobId}/results",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAnalyticsConversationsDetailsJobResultsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAnalyticsConversationsDetailsJobResultsOK), nil

}

/*
GetAnalyticsConversationsDetailsJobsAvailability lookups the datalake availability date and time
*/
func (a *Client) GetAnalyticsConversationsDetailsJobsAvailability(ctx context.Context, params *GetAnalyticsConversationsDetailsJobsAvailabilityParams) (*GetAnalyticsConversationsDetailsJobsAvailabilityOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAnalyticsConversationsDetailsJobsAvailability",
		Method:             "GET",
		PathPattern:        "/api/v2/analytics/conversations/details/jobs/availability",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAnalyticsConversationsDetailsJobsAvailabilityReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAnalyticsConversationsDetailsJobsAvailabilityOK), nil

}

/*
GetConversation gets conversation
*/
func (a *Client) GetConversation(ctx context.Context, params *GetConversationParams) (*GetConversationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversation",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationOK), nil

}

/*
GetConversationParticipantSecureivrsession fetches info on a secure session
*/
func (a *Client) GetConversationParticipantSecureivrsession(ctx context.Context, params *GetConversationParticipantSecureivrsessionParams) (*GetConversationParticipantSecureivrsessionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantSecureivrsession",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions/{secureSessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantSecureivrsessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantSecureivrsessionOK), nil

}

/*
GetConversationParticipantSecureivrsessions gets a list of secure sessions for this participant
*/
func (a *Client) GetConversationParticipantSecureivrsessions(ctx context.Context, params *GetConversationParticipantSecureivrsessionsParams) (*GetConversationParticipantSecureivrsessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantSecureivrsessions",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantSecureivrsessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantSecureivrsessionsOK), nil

}

/*
GetConversationParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationParticipantWrapup(ctx context.Context, params *GetConversationParticipantWrapupParams) (*GetConversationParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantWrapupOK), nil

}

/*
GetConversationParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationParticipantWrapupcodes(ctx context.Context, params *GetConversationParticipantWrapupcodesParams) (*GetConversationParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantWrapupcodesOK), nil

}

/*
GetConversations gets active conversations for the logged in user
*/
func (a *Client) GetConversations(ctx context.Context, params *GetConversationsParams) (*GetConversationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversations",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsOK), nil

}

/*
GetConversationsCall gets call conversation
*/
func (a *Client) GetConversationsCall(ctx context.Context, params *GetConversationsCallParams) (*GetConversationsCallOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCall",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallOK), nil

}

/*
GetConversationsCallParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsCallParticipantWrapup(ctx context.Context, params *GetConversationsCallParticipantWrapupParams) (*GetConversationsCallParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallParticipantWrapupOK), nil

}

/*
GetConversationsCallParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsCallParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallParticipantWrapupcodesParams) (*GetConversationsCallParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallParticipantWrapupcodesOK), nil

}

/*
GetConversationsCallback gets callback conversation
*/
func (a *Client) GetConversationsCallback(ctx context.Context, params *GetConversationsCallbackParams) (*GetConversationsCallbackOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallback",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbackReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbackOK), nil

}

/*
GetConversationsCallbackParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsCallbackParticipantWrapup(ctx context.Context, params *GetConversationsCallbackParticipantWrapupParams) (*GetConversationsCallbackParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallbackParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbackParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbackParticipantWrapupOK), nil

}

/*
GetConversationsCallbackParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsCallbackParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallbackParticipantWrapupcodesParams) (*GetConversationsCallbackParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallbackParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbackParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbackParticipantWrapupcodesOK), nil

}

/*
GetConversationsCallbacks gets active callback conversations for the logged in user
*/
func (a *Client) GetConversationsCallbacks(ctx context.Context, params *GetConversationsCallbacksParams) (*GetConversationsCallbacksOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallbacks",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbacksOK), nil

}

/*
GetConversationsCalls gets active call conversations for the logged in user
*/
func (a *Client) GetConversationsCalls(ctx context.Context, params *GetConversationsCallsParams) (*GetConversationsCallsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCalls",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallsOK), nil

}

/*
GetConversationsCallsHistory gets call history
*/
func (a *Client) GetConversationsCallsHistory(ctx context.Context, params *GetConversationsCallsHistoryParams) (*GetConversationsCallsHistoryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallsHistory",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallsHistoryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallsHistoryOK), nil

}

/*
GetConversationsCallsMaximumconferenceparties gets the maximum number of participants that this user can have on a conference
*/
func (a *Client) GetConversationsCallsMaximumconferenceparties(ctx context.Context, params *GetConversationsCallsMaximumconferencepartiesParams) (*GetConversationsCallsMaximumconferencepartiesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallsMaximumconferenceparties",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/maximumconferenceparties",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallsMaximumconferencepartiesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallsMaximumconferencepartiesOK), nil

}

/*
GetConversationsChat gets chat conversation
*/
func (a *Client) GetConversationsChat(ctx context.Context, params *GetConversationsChatParams) (*GetConversationsChatOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChat",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatOK), nil

}

/*
GetConversationsChatMessage gets a web chat conversation message

The current user must be involved with the conversation to get its messages.
*/
func (a *Client) GetConversationsChatMessage(ctx context.Context, params *GetConversationsChatMessageParams) (*GetConversationsChatMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/messages/{messageId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatMessageOK), nil

}

/*
GetConversationsChatMessages gets the messages of a chat conversation

The current user must be involved with the conversation to get its messages.
*/
func (a *Client) GetConversationsChatMessages(ctx context.Context, params *GetConversationsChatMessagesParams) (*GetConversationsChatMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatMessages",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatMessagesOK), nil

}

/*
GetConversationsChatParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsChatParticipantWrapup(ctx context.Context, params *GetConversationsChatParticipantWrapupParams) (*GetConversationsChatParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatParticipantWrapupOK), nil

}

/*
GetConversationsChatParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsChatParticipantWrapupcodes(ctx context.Context, params *GetConversationsChatParticipantWrapupcodesParams) (*GetConversationsChatParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatParticipantWrapupcodesOK), nil

}

/*
GetConversationsChats gets active chat conversations for the logged in user
*/
func (a *Client) GetConversationsChats(ctx context.Context, params *GetConversationsChatsParams) (*GetConversationsChatsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChats",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatsOK), nil

}

/*
GetConversationsCobrowsesession gets cobrowse conversation
*/
func (a *Client) GetConversationsCobrowsesession(ctx context.Context, params *GetConversationsCobrowsesessionParams) (*GetConversationsCobrowsesessionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesession",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionOK), nil

}

/*
GetConversationsCobrowsesessionParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsCobrowsesessionParticipantWrapup(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupParams) (*GetConversationsCobrowsesessionParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesessionParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionParticipantWrapupOK), nil

}

/*
GetConversationsCobrowsesessionParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsCobrowsesessionParticipantWrapupcodes(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupcodesParams) (*GetConversationsCobrowsesessionParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesessionParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionParticipantWrapupcodesOK), nil

}

/*
GetConversationsCobrowsesessions gets active cobrowse conversations for the logged in user
*/
func (a *Client) GetConversationsCobrowsesessions(ctx context.Context, params *GetConversationsCobrowsesessionsParams) (*GetConversationsCobrowsesessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesessions",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionsOK), nil

}

/*
GetConversationsEmail gets email conversation
*/
func (a *Client) GetConversationsEmail(ctx context.Context, params *GetConversationsEmailParams) (*GetConversationsEmailOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmail",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailOK), nil

}

/*
GetConversationsEmailMessage gets conversation message
*/
func (a *Client) GetConversationsEmailMessage(ctx context.Context, params *GetConversationsEmailMessageParams) (*GetConversationsEmailMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/{messageId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailMessageOK), nil

}

/*
GetConversationsEmailMessages gets conversation messages
*/
func (a *Client) GetConversationsEmailMessages(ctx context.Context, params *GetConversationsEmailMessagesParams) (*GetConversationsEmailMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailMessages",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailMessagesOK), nil

}

/*
GetConversationsEmailMessagesDraft gets conversation draft reply
*/
func (a *Client) GetConversationsEmailMessagesDraft(ctx context.Context, params *GetConversationsEmailMessagesDraftParams) (*GetConversationsEmailMessagesDraftOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailMessagesDraft",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailMessagesDraftReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailMessagesDraftOK), nil

}

/*
GetConversationsEmailParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsEmailParticipantWrapup(ctx context.Context, params *GetConversationsEmailParticipantWrapupParams) (*GetConversationsEmailParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailParticipantWrapupOK), nil

}

/*
GetConversationsEmailParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsEmailParticipantWrapupcodes(ctx context.Context, params *GetConversationsEmailParticipantWrapupcodesParams) (*GetConversationsEmailParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailParticipantWrapupcodesOK), nil

}

/*
GetConversationsEmails gets active email conversations for the logged in user
*/
func (a *Client) GetConversationsEmails(ctx context.Context, params *GetConversationsEmailsParams) (*GetConversationsEmailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmails",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailsOK), nil

}

/*
GetConversationsMessage gets message conversation
*/
func (a *Client) GetConversationsMessage(ctx context.Context, params *GetConversationsMessageParams) (*GetConversationsMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageOK), nil

}

/*
GetConversationsMessageCommunicationMessagesMediaMediaID gets media
*/
func (a *Client) GetConversationsMessageCommunicationMessagesMediaMediaID(ctx context.Context, params *GetConversationsMessageCommunicationMessagesMediaMediaIDParams) (*GetConversationsMessageCommunicationMessagesMediaMediaIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageCommunicationMessagesMediaMediaId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media/{mediaId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageCommunicationMessagesMediaMediaIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageCommunicationMessagesMediaMediaIDOK), nil

}

/*
GetConversationsMessageMessage gets message
*/
func (a *Client) GetConversationsMessageMessage(ctx context.Context, params *GetConversationsMessageMessageParams) (*GetConversationsMessageMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/messages/{messageId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageMessageOK), nil

}

/*
GetConversationsMessageParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsMessageParticipantWrapup(ctx context.Context, params *GetConversationsMessageParticipantWrapupParams) (*GetConversationsMessageParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageParticipantWrapupOK), nil

}

/*
GetConversationsMessageParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsMessageParticipantWrapupcodes(ctx context.Context, params *GetConversationsMessageParticipantWrapupcodesParams) (*GetConversationsMessageParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageParticipantWrapupcodesOK), nil

}

/*
GetConversationsMessages gets active message conversations for the logged in user
*/
func (a *Client) GetConversationsMessages(ctx context.Context, params *GetConversationsMessagesParams) (*GetConversationsMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessages",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagesOK), nil

}

/*
GetConversationsMessagingFacebookApp gets genesys facebook app Id
*/
func (a *Client) GetConversationsMessagingFacebookApp(ctx context.Context, params *GetConversationsMessagingFacebookAppParams) (*GetConversationsMessagingFacebookAppOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingFacebookApp",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/facebook/app",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingFacebookAppReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingFacebookAppOK), nil

}

/*
GetConversationsMessagingIntegrations gets a list of integrations
*/
func (a *Client) GetConversationsMessagingIntegrations(ctx context.Context, params *GetConversationsMessagingIntegrationsParams) (*GetConversationsMessagingIntegrationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrations",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsOK), nil

}

/*
GetConversationsMessagingIntegrationsFacebook gets a list of facebook integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsFacebook(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookParams) (*GetConversationsMessagingIntegrationsFacebookOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsFacebook",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsFacebookReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsFacebookOK), nil

}

/*
GetConversationsMessagingIntegrationsFacebookIntegrationID gets a facebook messaging integration
*/
func (a *Client) GetConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*GetConversationsMessagingIntegrationsFacebookIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsFacebookIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsFacebookIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsFacebookIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsLine gets a list of l i n e messenger integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsLine(ctx context.Context, params *GetConversationsMessagingIntegrationsLineParams) (*GetConversationsMessagingIntegrationsLineOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsLine",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsLineReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsLineOK), nil

}

/*
GetConversationsMessagingIntegrationsLineIntegrationID gets a l i n e messenger integration
*/
func (a *Client) GetConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsLineIntegrationIDParams) (*GetConversationsMessagingIntegrationsLineIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsLineIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsLineIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsLineIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsTwitter gets a list of twitter integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsTwitter(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterParams) (*GetConversationsMessagingIntegrationsTwitterOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsTwitter",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsTwitterReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsTwitterOK), nil

}

/*
GetConversationsMessagingIntegrationsTwitterIntegrationID gets a twitter messaging integration
*/
func (a *Client) GetConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*GetConversationsMessagingIntegrationsTwitterIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsTwitterIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsTwitterIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsTwitterIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsWhatsapp gets a list of whats app integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappParams) (*GetConversationsMessagingIntegrationsWhatsappOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsWhatsapp",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsWhatsappReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsWhatsappOK), nil

}

/*
GetConversationsMessagingIntegrationsWhatsappIntegrationID gets a whats app messaging integration
*/
func (a *Client) GetConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*GetConversationsMessagingIntegrationsWhatsappIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsWhatsappIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsWhatsappIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsWhatsappIntegrationIDOK), nil

}

/*
GetConversationsMessagingSticker gets a list of messaging stickers
*/
func (a *Client) GetConversationsMessagingSticker(ctx context.Context, params *GetConversationsMessagingStickerParams) (*GetConversationsMessagingStickerOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingSticker",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/stickers/{messengerType}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingStickerReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingStickerOK), nil

}

/*
PatchConversationParticipant updates a participant

Update conversation participant.
*/
func (a *Client) PatchConversationParticipant(ctx context.Context, params *PatchConversationParticipantParams) (*PatchConversationParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationParticipantAccepted), nil

}

/*
PatchConversationParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationParticipantAttributes(ctx context.Context, params *PatchConversationParticipantAttributesParams) (*PatchConversationParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationParticipantAttributesAccepted), nil

}

/*
PatchConversationsCall updates a conversation by setting it s recording state merging in other conversations to create a conference or disconnecting all of the participants
*/
func (a *Client) PatchConversationsCall(ctx context.Context, params *PatchConversationsCallParams) (*PatchConversationsCallOK, *PatchConversationsCallAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCall",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchConversationsCallOK:
		return value, nil, nil
	case *PatchConversationsCallAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PatchConversationsCallParticipant updates conversation participant
*/
func (a *Client) PatchConversationsCallParticipant(ctx context.Context, params *PatchConversationsCallParticipantParams) (*PatchConversationsCallParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantAccepted), nil

}

/*
PatchConversationsCallParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsCallParticipantAttributes(ctx context.Context, params *PatchConversationsCallParticipantAttributesParams) (*PatchConversationsCallParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantAttributesAccepted), nil

}

/*
PatchConversationsCallParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsCallParticipantCommunication(ctx context.Context, params *PatchConversationsCallParticipantCommunicationParams) (*PatchConversationsCallParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantCommunicationOK), nil

}

/*
PatchConversationsCallParticipantConsult changes who can speak
*/
func (a *Client) PatchConversationsCallParticipantConsult(ctx context.Context, params *PatchConversationsCallParticipantConsultParams) (*PatchConversationsCallParticipantConsultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipantConsult",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantConsultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantConsultOK), nil

}

/*
PatchConversationsCallback updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsCallback(ctx context.Context, params *PatchConversationsCallbackParams) (*PatchConversationsCallbackOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallback",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackOK), nil

}

/*
PatchConversationsCallbackParticipant updates conversation participant
*/
func (a *Client) PatchConversationsCallbackParticipant(ctx context.Context, params *PatchConversationsCallbackParticipantParams) (*PatchConversationsCallbackParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbackParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackParticipantAccepted), nil

}

/*
PatchConversationsCallbackParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsCallbackParticipantAttributes(ctx context.Context, params *PatchConversationsCallbackParticipantAttributesParams) (*PatchConversationsCallbackParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbackParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackParticipantAttributesAccepted), nil

}

/*
PatchConversationsCallbackParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsCallbackParticipantCommunication(ctx context.Context, params *PatchConversationsCallbackParticipantCommunicationParams) (*PatchConversationsCallbackParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbackParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackParticipantCommunicationOK), nil

}

/*
PatchConversationsChat updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsChat(ctx context.Context, params *PatchConversationsChatParams) (*PatchConversationsChatOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChat",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatOK), nil

}

/*
PatchConversationsChatParticipant updates conversation participant
*/
func (a *Client) PatchConversationsChatParticipant(ctx context.Context, params *PatchConversationsChatParticipantParams) (*PatchConversationsChatParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChatParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatParticipantAccepted), nil

}

/*
PatchConversationsChatParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsChatParticipantAttributes(ctx context.Context, params *PatchConversationsChatParticipantAttributesParams) (*PatchConversationsChatParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChatParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatParticipantAttributesAccepted), nil

}

/*
PatchConversationsChatParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsChatParticipantCommunication(ctx context.Context, params *PatchConversationsChatParticipantCommunicationParams) (*PatchConversationsChatParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChatParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatParticipantCommunicationOK), nil

}

/*
PatchConversationsCobrowsesession updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsCobrowsesession(ctx context.Context, params *PatchConversationsCobrowsesessionParams) (*PatchConversationsCobrowsesessionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesession",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionOK), nil

}

/*
PatchConversationsCobrowsesessionParticipant updates conversation participant
*/
func (a *Client) PatchConversationsCobrowsesessionParticipant(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantParams) (*PatchConversationsCobrowsesessionParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesessionParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionParticipantAccepted), nil

}

/*
PatchConversationsCobrowsesessionParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsCobrowsesessionParticipantAttributes(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantAttributesParams) (*PatchConversationsCobrowsesessionParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesessionParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionParticipantAttributesAccepted), nil

}

/*
PatchConversationsCobrowsesessionParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsCobrowsesessionParticipantCommunication(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantCommunicationParams) (*PatchConversationsCobrowsesessionParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesessionParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionParticipantCommunicationOK), nil

}

/*
PatchConversationsEmail updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsEmail(ctx context.Context, params *PatchConversationsEmailParams) (*PatchConversationsEmailOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmail",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailOK), nil

}

/*
PatchConversationsEmailParticipant updates conversation participant
*/
func (a *Client) PatchConversationsEmailParticipant(ctx context.Context, params *PatchConversationsEmailParticipantParams) (*PatchConversationsEmailParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmailParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailParticipantAccepted), nil

}

/*
PatchConversationsEmailParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsEmailParticipantAttributes(ctx context.Context, params *PatchConversationsEmailParticipantAttributesParams) (*PatchConversationsEmailParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmailParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailParticipantAttributesAccepted), nil

}

/*
PatchConversationsEmailParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsEmailParticipantCommunication(ctx context.Context, params *PatchConversationsEmailParticipantCommunicationParams) (*PatchConversationsEmailParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmailParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailParticipantCommunicationOK), nil

}

/*
PatchConversationsMessage updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsMessage(ctx context.Context, params *PatchConversationsMessageParams) (*PatchConversationsMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessage",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageOK), nil

}

/*
PatchConversationsMessageParticipant updates conversation participant
*/
func (a *Client) PatchConversationsMessageParticipant(ctx context.Context, params *PatchConversationsMessageParticipantParams) (*PatchConversationsMessageParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessageParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageParticipantAccepted), nil

}

/*
PatchConversationsMessageParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsMessageParticipantAttributes(ctx context.Context, params *PatchConversationsMessageParticipantAttributesParams) (*PatchConversationsMessageParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessageParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageParticipantAttributesAccepted), nil

}

/*
PatchConversationsMessageParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsMessageParticipantCommunication(ctx context.Context, params *PatchConversationsMessageParticipantCommunicationParams) (*PatchConversationsMessageParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessageParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageParticipantCommunicationOK), nil

}

/*
PatchConversationsMessagingIntegrationsFacebookIntegrationID updates facebook messaging integration
*/
func (a *Client) PatchConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*PatchConversationsMessagingIntegrationsFacebookIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsFacebookIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsFacebookIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessagingIntegrationsFacebookIntegrationIDOK), nil

}

/*
PatchConversationsMessagingIntegrationsTwitterIntegrationID updates twitter messaging integration
*/
func (a *Client) PatchConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*PatchConversationsMessagingIntegrationsTwitterIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsTwitterIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsTwitterIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessagingIntegrationsTwitterIntegrationIDOK), nil

}

/*
PatchConversationsMessagingIntegrationsWhatsappIntegrationID updates or activate a whats app messaging integration

The following steps are required in order to fully activate a Whatsapp Integration: Initially, you will need to get an activation code by sending: an action set to Activate, and an authenticationMethod choosing from Sms or Voice. Finally, once you have been informed of an activation code on selected authenticationMethod, you will need to confirm the code by sending: an action set to Confirm, and the confirmationCode you have received from Whatsapp.
*/
func (a *Client) PatchConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*PatchConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsWhatsappIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsWhatsappIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDOK:
		return value, nil, nil
	case *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostAnalyticsConversationDetailsProperties indices conversation properties
*/
func (a *Client) PostAnalyticsConversationDetailsProperties(ctx context.Context, params *PostAnalyticsConversationDetailsPropertiesParams) (*PostAnalyticsConversationDetailsPropertiesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postAnalyticsConversationDetailsProperties",
		Method:             "POST",
		PathPattern:        "/api/v2/analytics/conversations/{conversationId}/details/properties",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostAnalyticsConversationDetailsPropertiesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostAnalyticsConversationDetailsPropertiesAccepted), nil

}

/*
PostAnalyticsConversationsAggregatesQuery queries for conversation aggregates
*/
func (a *Client) PostAnalyticsConversationsAggregatesQuery(ctx context.Context, params *PostAnalyticsConversationsAggregatesQueryParams) (*PostAnalyticsConversationsAggregatesQueryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postAnalyticsConversationsAggregatesQuery",
		Method:             "POST",
		PathPattern:        "/api/v2/analytics/conversations/aggregates/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostAnalyticsConversationsAggregatesQueryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostAnalyticsConversationsAggregatesQueryOK), nil

}

/*
PostAnalyticsConversationsDetailsJobs queries for conversation details asynchronously
*/
func (a *Client) PostAnalyticsConversationsDetailsJobs(ctx context.Context, params *PostAnalyticsConversationsDetailsJobsParams) (*PostAnalyticsConversationsDetailsJobsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postAnalyticsConversationsDetailsJobs",
		Method:             "POST",
		PathPattern:        "/api/v2/analytics/conversations/details/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostAnalyticsConversationsDetailsJobsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostAnalyticsConversationsDetailsJobsAccepted), nil

}

/*
PostAnalyticsConversationsDetailsQuery queries for conversation details
*/
func (a *Client) PostAnalyticsConversationsDetailsQuery(ctx context.Context, params *PostAnalyticsConversationsDetailsQueryParams) (*PostAnalyticsConversationsDetailsQueryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postAnalyticsConversationsDetailsQuery",
		Method:             "POST",
		PathPattern:        "/api/v2/analytics/conversations/details/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostAnalyticsConversationsDetailsQueryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostAnalyticsConversationsDetailsQueryOK), nil

}

/*
PostConversationAssign attempts to manually assign a specified conversation to a specified agent ignores bullseye ring p a r score skills and languages
*/
func (a *Client) PostConversationAssign(ctx context.Context, params *PostConversationAssignParams) (*PostConversationAssignAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationAssign",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/assign",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationAssignReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationAssignAccepted), nil

}

/*
PostConversationDisconnect performs a full conversation teardown issues disconnect requests for any connected media applies a system wrap up code to any participants that are pending wrap up this is not intended to be the normal way of ending interactions but is available in the event of problems with the application to allow a resynchronization of state across all components it is recommended that users submit a support case if they are relying on this endpoint systematically as there is likely something that needs investigation
*/
func (a *Client) PostConversationDisconnect(ctx context.Context, params *PostConversationDisconnectParams) (*PostConversationDisconnectAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationDisconnect",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/disconnect",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationDisconnectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationDisconnectAccepted), nil

}

/*
PostConversationParticipantCallbacks creates a new callback for the specified participant on the conversation
*/
func (a *Client) PostConversationParticipantCallbacks(ctx context.Context, params *PostConversationParticipantCallbacksParams) (*PostConversationParticipantCallbacksCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantCallbacks",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantCallbacksCreated), nil

}

/*
PostConversationParticipantDigits sends d t m f to the participant
*/
func (a *Client) PostConversationParticipantDigits(ctx context.Context, params *PostConversationParticipantDigitsParams) (*PostConversationParticipantDigitsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantDigits",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/digits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantDigitsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantDigitsAccepted), nil

}

/*
PostConversationParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationParticipantReplace(ctx context.Context, params *PostConversationParticipantReplaceParams) (*PostConversationParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantReplaceAccepted), nil

}

/*
PostConversationParticipantSecureivrsessions creates secure i v r session only a participant in the conversation can invoke a secure i v r
*/
func (a *Client) PostConversationParticipantSecureivrsessions(ctx context.Context, params *PostConversationParticipantSecureivrsessionsParams) (*PostConversationParticipantSecureivrsessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantSecureivrsessions",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantSecureivrsessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantSecureivrsessionsOK), nil

}

/*
PostConversationsCall places a new call as part of a callback conversation
*/
func (a *Client) PostConversationsCall(ctx context.Context, params *PostConversationsCallParams) (*PostConversationsCallOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCall",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallOK), nil

}

/*
PostConversationsCallParticipantCoach listens in on the conversation from the point of view of a given participant while speaking to just the given participant
*/
func (a *Client) PostConversationsCallParticipantCoach(ctx context.Context, params *PostConversationsCallParticipantCoachParams) (*PostConversationsCallParticipantCoachCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantCoach",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/coach",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantCoachReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantCoachCreated), nil

}

/*
PostConversationsCallParticipantConsult initiates and update consult transfer
*/
func (a *Client) PostConversationsCallParticipantConsult(ctx context.Context, params *PostConversationsCallParticipantConsultParams) (*PostConversationsCallParticipantConsultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantConsult",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantConsultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantConsultOK), nil

}

/*
PostConversationsCallParticipantMonitor listens in on the conversation from the point of view of a given participant
*/
func (a *Client) PostConversationsCallParticipantMonitor(ctx context.Context, params *PostConversationsCallParticipantMonitorParams) (*PostConversationsCallParticipantMonitorCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantMonitor",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/monitor",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantMonitorReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantMonitorCreated), nil

}

/*
PostConversationsCallParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsCallParticipantReplace(ctx context.Context, params *PostConversationsCallParticipantReplaceParams) (*PostConversationsCallParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantReplaceAccepted), nil

}

/*
PostConversationsCallParticipants adds participants to a conversation
*/
func (a *Client) PostConversationsCallParticipants(ctx context.Context, params *PostConversationsCallParticipantsParams) (*PostConversationsCallParticipantsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipants",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantsOK), nil

}

/*
PostConversationsCallbackParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsCallbackParticipantReplace(ctx context.Context, params *PostConversationsCallbackParticipantReplaceParams) (*PostConversationsCallbackParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallbackParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallbackParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallbackParticipantReplaceAccepted), nil

}

/*
PostConversationsCallbacks creates a callback
*/
func (a *Client) PostConversationsCallbacks(ctx context.Context, params *PostConversationsCallbacksParams) (*PostConversationsCallbacksOK, *PostConversationsCallbacksAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallbacks",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsCallbacksOK:
		return value, nil, nil
	case *PostConversationsCallbacksAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsCalls creates a call conversation
*/
func (a *Client) PostConversationsCalls(ctx context.Context, params *PostConversationsCallsParams) (*PostConversationsCallsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCalls",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallsOK), nil

}

/*
PostConversationsChatCommunicationMessages sends a message on behalf of a communication in a chat conversation
*/
func (a *Client) PostConversationsChatCommunicationMessages(ctx context.Context, params *PostConversationsChatCommunicationMessagesParams) (*PostConversationsChatCommunicationMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChatCommunicationMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatCommunicationMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatCommunicationMessagesOK), nil

}

/*
PostConversationsChatCommunicationTyping sends a typing indicator on behalf of a communication in a chat conversation
*/
func (a *Client) PostConversationsChatCommunicationTyping(ctx context.Context, params *PostConversationsChatCommunicationTypingParams) (*PostConversationsChatCommunicationTypingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChatCommunicationTyping",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/typing",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatCommunicationTypingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatCommunicationTypingOK), nil

}

/*
PostConversationsChatParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsChatParticipantReplace(ctx context.Context, params *PostConversationsChatParticipantReplaceParams) (*PostConversationsChatParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChatParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatParticipantReplaceAccepted), nil

}

/*
PostConversationsChats creates a web chat conversation
*/
func (a *Client) PostConversationsChats(ctx context.Context, params *PostConversationsChatsParams) (*PostConversationsChatsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChats",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatsOK), nil

}

/*
PostConversationsCobrowsesessionParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsCobrowsesessionParticipantReplace(ctx context.Context, params *PostConversationsCobrowsesessionParticipantReplaceParams) (*PostConversationsCobrowsesessionParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCobrowsesessionParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCobrowsesessionParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCobrowsesessionParticipantReplaceAccepted), nil

}

/*
PostConversationsEmailInboundmessages sends an email to an external conversation an external conversation is one where the provider is not pure cloud based this endpoint allows the sender of the external email to reply or send a new message to the existing conversation the new message will be treated as part of the existing conversation and chained to it
*/
func (a *Client) PostConversationsEmailInboundmessages(ctx context.Context, params *PostConversationsEmailInboundmessagesParams) (*PostConversationsEmailInboundmessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailInboundmessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/inboundmessages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailInboundmessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailInboundmessagesOK), nil

}

/*
PostConversationsEmailMessages sends an email reply
*/
func (a *Client) PostConversationsEmailMessages(ctx context.Context, params *PostConversationsEmailMessagesParams) (*PostConversationsEmailMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailMessagesOK), nil

}

/*
PostConversationsEmailMessagesDraftAttachmentsCopy copies attachments from an email message to the current draft
*/
func (a *Client) PostConversationsEmailMessagesDraftAttachmentsCopy(ctx context.Context, params *PostConversationsEmailMessagesDraftAttachmentsCopyParams) (*PostConversationsEmailMessagesDraftAttachmentsCopyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailMessagesDraftAttachmentsCopy",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/copy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailMessagesDraftAttachmentsCopyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailMessagesDraftAttachmentsCopyOK), nil

}

/*
PostConversationsEmailParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsEmailParticipantReplace(ctx context.Context, params *PostConversationsEmailParticipantReplaceParams) (*PostConversationsEmailParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailParticipantReplaceAccepted), nil

}

/*
PostConversationsEmails creates an email conversation

If the direction of the request is INBOUND, this will create an external conversation with a third party provider. If the direction of the the request is OUTBOUND, this will create a conversation to send outbound emails on behalf of a queue.
*/
func (a *Client) PostConversationsEmails(ctx context.Context, params *PostConversationsEmailsParams) (*PostConversationsEmailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmails",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailsOK), nil

}

/*
PostConversationsFaxes creates fax conversation
*/
func (a *Client) PostConversationsFaxes(ctx context.Context, params *PostConversationsFaxesParams) (*PostConversationsFaxesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsFaxes",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/faxes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsFaxesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsFaxesOK), nil

}

/*
PostConversationsMessageCommunicationMessages sends message

Send message on existing conversation/communication. Only one message body field can be accepted, per request. Example: 1 textBody, 1 mediaId, 1 stickerId, or 1 messageTemplate.
*/
func (a *Client) PostConversationsMessageCommunicationMessages(ctx context.Context, params *PostConversationsMessageCommunicationMessagesParams) (*PostConversationsMessageCommunicationMessagesOK, *PostConversationsMessageCommunicationMessagesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageCommunicationMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageCommunicationMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessageCommunicationMessagesOK:
		return value, nil, nil
	case *PostConversationsMessageCommunicationMessagesAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessageCommunicationMessagesMedia creates media
*/
func (a *Client) PostConversationsMessageCommunicationMessagesMedia(ctx context.Context, params *PostConversationsMessageCommunicationMessagesMediaParams) (*PostConversationsMessageCommunicationMessagesMediaOK, *PostConversationsMessageCommunicationMessagesMediaAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageCommunicationMessagesMedia",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageCommunicationMessagesMediaReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessageCommunicationMessagesMediaOK:
		return value, nil, nil
	case *PostConversationsMessageCommunicationMessagesMediaAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessageMessagesBulk gets messages in batch

The path parameter [conversationId] should contain the conversationId of the conversation being filtered. The body should contain the messageId(s) of messages being requested. For example: ["a3069a33b-bbb1-4703-9d68-061d9e9db96e", "55bc6be3-078c-4a49-a4e6-1e05776ed7e8"]
*/
func (a *Client) PostConversationsMessageMessagesBulk(ctx context.Context, params *PostConversationsMessageMessagesBulkParams) (*PostConversationsMessageMessagesBulkOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageMessagesBulk",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/messages/bulk",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageMessagesBulkReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessageMessagesBulkOK), nil

}

/*
PostConversationsMessageParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsMessageParticipantReplace(ctx context.Context, params *PostConversationsMessageParticipantReplaceParams) (*PostConversationsMessageParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessageParticipantReplaceAccepted), nil

}

/*
PostConversationsMessages creates an outbound messaging conversation

If there is an existing conversation between the remote address and the address associated with the queue specified in createOutboundRequest then the result of this request depends on the state of that conversation and the useExistingConversation field of createOutboundRequest. If the existing conversation is in alerting or connected state, then the request will fail. If the existing conversation is disconnected but still within the conversation window then the request will fail unless useExistingConversation is set to true.
*/
func (a *Client) PostConversationsMessages(ctx context.Context, params *PostConversationsMessagesParams) (*PostConversationsMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessagesOK), nil

}

/*
PostConversationsMessagesAgentless sends an agentless outbound message

Send an agentlesss (api participant) outbound message using a client credential grant. In order to call this endpoint you will need OAuth token generated using OAuth client credentials authorized with at least messaging scope. This will generate a new Conversation, if there is an existing active Conversation between the fromAddress and toAddress already, then this POST will fail.
*/
func (a *Client) PostConversationsMessagesAgentless(ctx context.Context, params *PostConversationsMessagesAgentlessParams) (*PostConversationsMessagesAgentlessOK, *PostConversationsMessagesAgentlessAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagesAgentless",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/agentless",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagesAgentlessReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagesAgentlessOK:
		return value, nil, nil
	case *PostConversationsMessagesAgentlessAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsFacebook creates a facebook integration
*/
func (a *Client) PostConversationsMessagingIntegrationsFacebook(ctx context.Context, params *PostConversationsMessagingIntegrationsFacebookParams) (*PostConversationsMessagingIntegrationsFacebookOK, *PostConversationsMessagingIntegrationsFacebookAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsFacebook",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsFacebookReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsFacebookOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsFacebookAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsLine creates a l i n e messenger integration
*/
func (a *Client) PostConversationsMessagingIntegrationsLine(ctx context.Context, params *PostConversationsMessagingIntegrationsLineParams) (*PostConversationsMessagingIntegrationsLineOK, *PostConversationsMessagingIntegrationsLineAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsLine",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsLineReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsLineOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsLineAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsTwitter creates a twitter integration
*/
func (a *Client) PostConversationsMessagingIntegrationsTwitter(ctx context.Context, params *PostConversationsMessagingIntegrationsTwitterParams) (*PostConversationsMessagingIntegrationsTwitterOK, *PostConversationsMessagingIntegrationsTwitterAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsTwitter",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsTwitterReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsTwitterOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsTwitterAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsWhatsapp creates a whats app integration

You must be approved by WhatsApp to use this feature. Your approved e164-formatted phone number and valid WhatsApp certificate for your number are required. Your WhatsApp certificate must have valid base64 encoding. Please paste carefully and do not add any leading or trailing spaces. Do not alter any characters. An integration must be activated within 7 days of certificate generation. If you cannot complete the addition and activation of the number within 7 days, please obtain a new certificate before creating the integration. Integrations created with an invalid number or certificate may immediately incur additional integration fees. Please carefully enter your number and certificate as described.
*/
func (a *Client) PostConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *PostConversationsMessagingIntegrationsWhatsappParams) (*PostConversationsMessagingIntegrationsWhatsappOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsWhatsapp",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsWhatsappReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessagingIntegrationsWhatsappOK), nil

}

/*
PutConversationParticipantFlaggedreason sets flagged reason on conversation participant to indicate bad conversation quality
*/
func (a *Client) PutConversationParticipantFlaggedreason(ctx context.Context, params *PutConversationParticipantFlaggedreasonParams) (*PutConversationParticipantFlaggedreasonNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationParticipantFlaggedreason",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationParticipantFlaggedreasonReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationParticipantFlaggedreasonNoContent), nil

}

/*
PutConversationsCallParticipantCommunicationUuidata sets uui data to be sent on future commands
*/
func (a *Client) PutConversationsCallParticipantCommunicationUuidata(ctx context.Context, params *PutConversationsCallParticipantCommunicationUuidataParams) (*PutConversationsCallParticipantCommunicationUuidataOK, *PutConversationsCallParticipantCommunicationUuidataNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsCallParticipantCommunicationUuidata",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/uuidata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsCallParticipantCommunicationUuidataReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsCallParticipantCommunicationUuidataOK:
		return value, nil, nil
	case *PutConversationsCallParticipantCommunicationUuidataNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsEmailMessagesDraft updates conversation draft reply
*/
func (a *Client) PutConversationsEmailMessagesDraft(ctx context.Context, params *PutConversationsEmailMessagesDraftParams) (*PutConversationsEmailMessagesDraftOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsEmailMessagesDraft",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsEmailMessagesDraftReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsEmailMessagesDraftOK), nil

}

/*
PutConversationsMessagingIntegrationsLineIntegrationID updates a l i n e messenger integration
*/
func (a *Client) PutConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *PutConversationsMessagingIntegrationsLineIntegrationIDParams) (*PutConversationsMessagingIntegrationsLineIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsMessagingIntegrationsLineIntegrationId",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsMessagingIntegrationsLineIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsMessagingIntegrationsLineIntegrationIDOK), nil

}
