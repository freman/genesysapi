// Code generated by go-swagger; DO NOT EDIT.

package conversations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery -name API -inpkg

// API is the interface of the conversations client
type API interface {
	/*
	   DeleteConversationParticipantCode deletes a code used to add a communication to this participant
	*/
	DeleteConversationParticipantCode(ctx context.Context, params *DeleteConversationParticipantCodeParams) error
	/*
	   DeleteConversationParticipantFlaggedreason removes flagged reason from conversation participant
	*/
	DeleteConversationParticipantFlaggedreason(ctx context.Context, params *DeleteConversationParticipantFlaggedreasonParams) (*DeleteConversationParticipantFlaggedreasonNoContent, error)
	/*
	   DeleteConversationsCallParticipantConsult cancels the transfer
	*/
	DeleteConversationsCallParticipantConsult(ctx context.Context, params *DeleteConversationsCallParticipantConsultParams) (*DeleteConversationsCallParticipantConsultOK, error)
	/*
	   DeleteConversationsEmailMessagesDraftAttachment deletes attachment from draft
	*/
	DeleteConversationsEmailMessagesDraftAttachment(ctx context.Context, params *DeleteConversationsEmailMessagesDraftAttachmentParams) (*DeleteConversationsEmailMessagesDraftAttachmentOK, error)
	/*
	   DeleteConversationsMessagingIntegrationsFacebookIntegrationID deletes a facebook messaging integration
	*/
	DeleteConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsFacebookIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsLineIntegrationID deletes a l i n e messenger integration
	*/
	DeleteConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsLineIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsLineIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsOpenIntegrationID deletes an open messaging integration
	   See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
	*/
	DeleteConversationsMessagingIntegrationsOpenIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsOpenIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsOpenIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsTwitterIntegrationID deletes a twitter messaging integration
	*/
	DeleteConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsTwitterIntegrationIDNoContent, error)
	/*
	   DeleteConversationsMessagingIntegrationsWhatsappIntegrationID deletes a whats app messaging integration
	*/
	DeleteConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error)
	/*
	   DeleteConversationsMessagingSupportedcontentSupportedContentID deletes a supported content profile
	*/
	DeleteConversationsMessagingSupportedcontentSupportedContentID(ctx context.Context, params *DeleteConversationsMessagingSupportedcontentSupportedContentIDParams) (*DeleteConversationsMessagingSupportedcontentSupportedContentIDNoContent, error)
	/*
	   GetConversation gets conversation
	*/
	GetConversation(ctx context.Context, params *GetConversationParams) (*GetConversationOK, error)
	/*
	   GetConversationParticipantSecureivrsession fetches info on a secure session
	*/
	GetConversationParticipantSecureivrsession(ctx context.Context, params *GetConversationParticipantSecureivrsessionParams) (*GetConversationParticipantSecureivrsessionOK, error)
	/*
	   GetConversationParticipantSecureivrsessions gets a list of secure sessions for this participant
	*/
	GetConversationParticipantSecureivrsessions(ctx context.Context, params *GetConversationParticipantSecureivrsessionsParams) (*GetConversationParticipantSecureivrsessionsOK, error)
	/*
	   GetConversationParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationParticipantWrapup(ctx context.Context, params *GetConversationParticipantWrapupParams) (*GetConversationParticipantWrapupOK, error)
	/*
	   GetConversationParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationParticipantWrapupcodes(ctx context.Context, params *GetConversationParticipantWrapupcodesParams) (*GetConversationParticipantWrapupcodesOK, error)
	/*
	   GetConversationSecureattributes gets the secure attributes on a conversation
	*/
	GetConversationSecureattributes(ctx context.Context, params *GetConversationSecureattributesParams) (*GetConversationSecureattributesOK, error)
	/*
	   GetConversations gets active conversations for the logged in user
	*/
	GetConversations(ctx context.Context, params *GetConversationsParams) (*GetConversationsOK, error)
	/*
	   GetConversationsCall gets call conversation
	*/
	GetConversationsCall(ctx context.Context, params *GetConversationsCallParams) (*GetConversationsCallOK, error)
	/*
	   GetConversationsCallParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsCallParticipantWrapup(ctx context.Context, params *GetConversationsCallParticipantWrapupParams) (*GetConversationsCallParticipantWrapupOK, error)
	/*
	   GetConversationsCallParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsCallParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallParticipantWrapupcodesParams) (*GetConversationsCallParticipantWrapupcodesOK, error)
	/*
	   GetConversationsCallback gets callback conversation
	*/
	GetConversationsCallback(ctx context.Context, params *GetConversationsCallbackParams) (*GetConversationsCallbackOK, error)
	/*
	   GetConversationsCallbackParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsCallbackParticipantWrapup(ctx context.Context, params *GetConversationsCallbackParticipantWrapupParams) (*GetConversationsCallbackParticipantWrapupOK, error)
	/*
	   GetConversationsCallbackParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsCallbackParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallbackParticipantWrapupcodesParams) (*GetConversationsCallbackParticipantWrapupcodesOK, error)
	/*
	   GetConversationsCallbacks gets active callback conversations for the logged in user
	*/
	GetConversationsCallbacks(ctx context.Context, params *GetConversationsCallbacksParams) (*GetConversationsCallbacksOK, error)
	/*
	   GetConversationsCalls gets active call conversations for the logged in user
	*/
	GetConversationsCalls(ctx context.Context, params *GetConversationsCallsParams) (*GetConversationsCallsOK, error)
	/*
	   GetConversationsCallsHistory gets call history
	*/
	GetConversationsCallsHistory(ctx context.Context, params *GetConversationsCallsHistoryParams) (*GetConversationsCallsHistoryOK, error)
	/*
	   GetConversationsCallsMaximumconferenceparties gets the maximum number of participants that this user can have on a conference
	*/
	GetConversationsCallsMaximumconferenceparties(ctx context.Context, params *GetConversationsCallsMaximumconferencepartiesParams) (*GetConversationsCallsMaximumconferencepartiesOK, error)
	/*
	   GetConversationsChat gets chat conversation
	*/
	GetConversationsChat(ctx context.Context, params *GetConversationsChatParams) (*GetConversationsChatOK, error)
	/*
	   GetConversationsChatMessage gets a web chat conversation message
	   The current user must be involved with the conversation to get its messages.
	*/
	GetConversationsChatMessage(ctx context.Context, params *GetConversationsChatMessageParams) (*GetConversationsChatMessageOK, error)
	/*
	   GetConversationsChatMessages gets the messages of a chat conversation
	   The current user must be involved with the conversation to get its messages.
	*/
	GetConversationsChatMessages(ctx context.Context, params *GetConversationsChatMessagesParams) (*GetConversationsChatMessagesOK, error)
	/*
	   GetConversationsChatParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsChatParticipantWrapup(ctx context.Context, params *GetConversationsChatParticipantWrapupParams) (*GetConversationsChatParticipantWrapupOK, error)
	/*
	   GetConversationsChatParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsChatParticipantWrapupcodes(ctx context.Context, params *GetConversationsChatParticipantWrapupcodesParams) (*GetConversationsChatParticipantWrapupcodesOK, error)
	/*
	   GetConversationsChats gets active chat conversations for the logged in user
	*/
	GetConversationsChats(ctx context.Context, params *GetConversationsChatsParams) (*GetConversationsChatsOK, error)
	/*
	   GetConversationsCobrowsesession gets cobrowse conversation
	*/
	GetConversationsCobrowsesession(ctx context.Context, params *GetConversationsCobrowsesessionParams) (*GetConversationsCobrowsesessionOK, error)
	/*
	   GetConversationsCobrowsesessionParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsCobrowsesessionParticipantWrapup(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupParams) (*GetConversationsCobrowsesessionParticipantWrapupOK, error)
	/*
	   GetConversationsCobrowsesessionParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsCobrowsesessionParticipantWrapupcodes(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupcodesParams) (*GetConversationsCobrowsesessionParticipantWrapupcodesOK, error)
	/*
	   GetConversationsCobrowsesessions gets active cobrowse conversations for the logged in user
	*/
	GetConversationsCobrowsesessions(ctx context.Context, params *GetConversationsCobrowsesessionsParams) (*GetConversationsCobrowsesessionsOK, error)
	/*
	   GetConversationsEmail gets email conversation
	*/
	GetConversationsEmail(ctx context.Context, params *GetConversationsEmailParams) (*GetConversationsEmailOK, error)
	/*
	   GetConversationsEmailMessage gets conversation message
	*/
	GetConversationsEmailMessage(ctx context.Context, params *GetConversationsEmailMessageParams) (*GetConversationsEmailMessageOK, error)
	/*
	   GetConversationsEmailMessages gets conversation messages
	*/
	GetConversationsEmailMessages(ctx context.Context, params *GetConversationsEmailMessagesParams) (*GetConversationsEmailMessagesOK, error)
	/*
	   GetConversationsEmailMessagesDraft gets conversation draft reply
	*/
	GetConversationsEmailMessagesDraft(ctx context.Context, params *GetConversationsEmailMessagesDraftParams) (*GetConversationsEmailMessagesDraftOK, error)
	/*
	   GetConversationsEmailParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsEmailParticipantWrapup(ctx context.Context, params *GetConversationsEmailParticipantWrapupParams) (*GetConversationsEmailParticipantWrapupOK, error)
	/*
	   GetConversationsEmailParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsEmailParticipantWrapupcodes(ctx context.Context, params *GetConversationsEmailParticipantWrapupcodesParams) (*GetConversationsEmailParticipantWrapupcodesOK, error)
	/*
	   GetConversationsEmailSettings gets emails settings for a given conversation
	*/
	GetConversationsEmailSettings(ctx context.Context, params *GetConversationsEmailSettingsParams) (*GetConversationsEmailSettingsOK, error)
	/*
	   GetConversationsEmails gets active email conversations for the logged in user
	*/
	GetConversationsEmails(ctx context.Context, params *GetConversationsEmailsParams) (*GetConversationsEmailsOK, error)
	/*
	   GetConversationsKeyconfiguration gets the encryption key configurations
	*/
	GetConversationsKeyconfiguration(ctx context.Context, params *GetConversationsKeyconfigurationParams) (*GetConversationsKeyconfigurationOK, error)
	/*
	   GetConversationsKeyconfigurations gets a list of key configurations data
	*/
	GetConversationsKeyconfigurations(ctx context.Context, params *GetConversationsKeyconfigurationsParams) (*GetConversationsKeyconfigurationsOK, error)
	/*
	   GetConversationsMessage gets message conversation
	*/
	GetConversationsMessage(ctx context.Context, params *GetConversationsMessageParams) (*GetConversationsMessageOK, error)
	/*
	   GetConversationsMessageCommunicationMessagesMediaMediaID gets media
	   See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage.
	*/
	GetConversationsMessageCommunicationMessagesMediaMediaID(ctx context.Context, params *GetConversationsMessageCommunicationMessagesMediaMediaIDParams) (*GetConversationsMessageCommunicationMessagesMediaMediaIDOK, error)
	/*
	   GetConversationsMessageDetails gets message
	*/
	GetConversationsMessageDetails(ctx context.Context, params *GetConversationsMessageDetailsParams) (*GetConversationsMessageDetailsOK, error)
	/*
	   GetConversationsMessageMessage gets conversation message
	*/
	GetConversationsMessageMessage(ctx context.Context, params *GetConversationsMessageMessageParams) (*GetConversationsMessageMessageOK, error)
	/*
	   GetConversationsMessageParticipantWrapup gets the wrap up for this conversation participant
	*/
	GetConversationsMessageParticipantWrapup(ctx context.Context, params *GetConversationsMessageParticipantWrapupParams) (*GetConversationsMessageParticipantWrapupOK, error)
	/*
	   GetConversationsMessageParticipantWrapupcodes gets list of wrapup codes for this conversation participant
	*/
	GetConversationsMessageParticipantWrapupcodes(ctx context.Context, params *GetConversationsMessageParticipantWrapupcodesParams) (*GetConversationsMessageParticipantWrapupcodesOK, error)
	/*
	   GetConversationsMessages gets active message conversations for the logged in user
	*/
	GetConversationsMessages(ctx context.Context, params *GetConversationsMessagesParams) (*GetConversationsMessagesOK, error)
	/*
	   GetConversationsMessagingFacebookApp gets genesys facebook app Id
	*/
	GetConversationsMessagingFacebookApp(ctx context.Context, params *GetConversationsMessagingFacebookAppParams) (*GetConversationsMessagingFacebookAppOK, error)
	/*
	   GetConversationsMessagingIntegrations gets a list of integrations
	*/
	GetConversationsMessagingIntegrations(ctx context.Context, params *GetConversationsMessagingIntegrationsParams) (*GetConversationsMessagingIntegrationsOK, error)
	/*
	   GetConversationsMessagingIntegrationsFacebook gets a list of facebook integrations
	*/
	GetConversationsMessagingIntegrationsFacebook(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookParams) (*GetConversationsMessagingIntegrationsFacebookOK, error)
	/*
	   GetConversationsMessagingIntegrationsFacebookIntegrationID gets a facebook messaging integration
	*/
	GetConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*GetConversationsMessagingIntegrationsFacebookIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsLine gets a list of l i n e messenger integrations
	*/
	GetConversationsMessagingIntegrationsLine(ctx context.Context, params *GetConversationsMessagingIntegrationsLineParams) (*GetConversationsMessagingIntegrationsLineOK, error)
	/*
	   GetConversationsMessagingIntegrationsLineIntegrationID gets a l i n e messenger integration
	*/
	GetConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsLineIntegrationIDParams) (*GetConversationsMessagingIntegrationsLineIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsOpen gets a list of open messaging integrations
	   See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
	*/
	GetConversationsMessagingIntegrationsOpen(ctx context.Context, params *GetConversationsMessagingIntegrationsOpenParams) (*GetConversationsMessagingIntegrationsOpenOK, error)
	/*
	   GetConversationsMessagingIntegrationsOpenIntegrationID gets an open messaging integration
	   See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
	*/
	GetConversationsMessagingIntegrationsOpenIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsOpenIntegrationIDParams) (*GetConversationsMessagingIntegrationsOpenIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsTwitter gets a list of twitter integrations
	*/
	GetConversationsMessagingIntegrationsTwitter(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterParams) (*GetConversationsMessagingIntegrationsTwitterOK, error)
	/*
	   GetConversationsMessagingIntegrationsTwitterIntegrationID gets a twitter messaging integration
	*/
	GetConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*GetConversationsMessagingIntegrationsTwitterIntegrationIDOK, error)
	/*
	   GetConversationsMessagingIntegrationsWhatsapp gets a list of whats app integrations
	*/
	GetConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappParams) (*GetConversationsMessagingIntegrationsWhatsappOK, error)
	/*
	   GetConversationsMessagingIntegrationsWhatsappIntegrationID gets a whats app messaging integration
	*/
	GetConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*GetConversationsMessagingIntegrationsWhatsappIntegrationIDOK, error)
	/*
	   GetConversationsMessagingSticker gets a list of messaging stickers
	*/
	GetConversationsMessagingSticker(ctx context.Context, params *GetConversationsMessagingStickerParams) (*GetConversationsMessagingStickerOK, error)
	/*
	   GetConversationsMessagingSupportedcontent gets a list of supported content profiles
	*/
	GetConversationsMessagingSupportedcontent(ctx context.Context, params *GetConversationsMessagingSupportedcontentParams) (*GetConversationsMessagingSupportedcontentOK, error)
	/*
	   GetConversationsMessagingSupportedcontentDefault gets the organization s default supported content profile that will be used as the default when creating an integration
	   When an integration is created a supported content ID may be assigned to it. If the supported content ID is not supplied, the default supported content profile will be assigned to it.
	*/
	GetConversationsMessagingSupportedcontentDefault(ctx context.Context, params *GetConversationsMessagingSupportedcontentDefaultParams) (*GetConversationsMessagingSupportedcontentDefaultOK, error)
	/*
	   GetConversationsMessagingSupportedcontentSupportedContentID gets a supported content profile
	*/
	GetConversationsMessagingSupportedcontentSupportedContentID(ctx context.Context, params *GetConversationsMessagingSupportedcontentSupportedContentIDParams) (*GetConversationsMessagingSupportedcontentSupportedContentIDOK, error)
	/*
	   GetConversationsMessagingThreadingtimeline gets conversation threading window timeline for each messaging type
	   Conversation messaging threading timeline is a setting defined for each messenger type in your organization. This setting will dictate whether a new message is added to the most recent existing conversation, or creates a new Conversation. If the existing Conversation is still in a connected state the threading timeline setting will never play a role. After the conversation is disconnected, if an inbound message is received or an outbound message is sent after the setting for threading timeline expires, a new conversation is created.
	*/
	GetConversationsMessagingThreadingtimeline(ctx context.Context, params *GetConversationsMessagingThreadingtimelineParams) (*GetConversationsMessagingThreadingtimelineOK, error)
	/*
	   PatchConversationParticipant updates a participant
	   Update conversation participant.
	*/
	PatchConversationParticipant(ctx context.Context, params *PatchConversationParticipantParams) (*PatchConversationParticipantAccepted, error)
	/*
	   PatchConversationParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationParticipantAttributes(ctx context.Context, params *PatchConversationParticipantAttributesParams) (*PatchConversationParticipantAttributesAccepted, error)
	/*
	   PatchConversationSecureattributes updates the secure attributes on a conversation
	*/
	PatchConversationSecureattributes(ctx context.Context, params *PatchConversationSecureattributesParams) (*PatchConversationSecureattributesAccepted, error)
	/*
	   PatchConversationsCall updates a conversation by setting its recording state merging in other conversations to create a conference or disconnecting all of the participants
	*/
	PatchConversationsCall(ctx context.Context, params *PatchConversationsCallParams) (*PatchConversationsCallOK, *PatchConversationsCallAccepted, error)
	/*
	   PatchConversationsCallParticipant updates conversation participant
	*/
	PatchConversationsCallParticipant(ctx context.Context, params *PatchConversationsCallParticipantParams) (*PatchConversationsCallParticipantAccepted, error)
	/*
	   PatchConversationsCallParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsCallParticipantAttributes(ctx context.Context, params *PatchConversationsCallParticipantAttributesParams) (*PatchConversationsCallParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCallParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsCallParticipantCommunication(ctx context.Context, params *PatchConversationsCallParticipantCommunicationParams) (*PatchConversationsCallParticipantCommunicationOK, error)
	/*
	   PatchConversationsCallParticipantConsult changes who can speak
	*/
	PatchConversationsCallParticipantConsult(ctx context.Context, params *PatchConversationsCallParticipantConsultParams) (*PatchConversationsCallParticipantConsultOK, error)
	/*
	   PatchConversationsCallback updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsCallback(ctx context.Context, params *PatchConversationsCallbackParams) (*PatchConversationsCallbackOK, error)
	/*
	   PatchConversationsCallbackParticipant updates conversation participant
	*/
	PatchConversationsCallbackParticipant(ctx context.Context, params *PatchConversationsCallbackParticipantParams) (*PatchConversationsCallbackParticipantAccepted, error)
	/*
	   PatchConversationsCallbackParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsCallbackParticipantAttributes(ctx context.Context, params *PatchConversationsCallbackParticipantAttributesParams) (*PatchConversationsCallbackParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCallbackParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsCallbackParticipantCommunication(ctx context.Context, params *PatchConversationsCallbackParticipantCommunicationParams) (*PatchConversationsCallbackParticipantCommunicationOK, error)
	/*
	   PatchConversationsCallbacks updates a scheduled callback
	*/
	PatchConversationsCallbacks(ctx context.Context, params *PatchConversationsCallbacksParams) (*PatchConversationsCallbacksOK, error)
	/*
	   PatchConversationsChat updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsChat(ctx context.Context, params *PatchConversationsChatParams) (*PatchConversationsChatOK, error)
	/*
	   PatchConversationsChatParticipant updates conversation participant
	*/
	PatchConversationsChatParticipant(ctx context.Context, params *PatchConversationsChatParticipantParams) (*PatchConversationsChatParticipantAccepted, error)
	/*
	   PatchConversationsChatParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsChatParticipantAttributes(ctx context.Context, params *PatchConversationsChatParticipantAttributesParams) (*PatchConversationsChatParticipantAttributesAccepted, error)
	/*
	   PatchConversationsChatParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsChatParticipantCommunication(ctx context.Context, params *PatchConversationsChatParticipantCommunicationParams) (*PatchConversationsChatParticipantCommunicationOK, error)
	/*
	   PatchConversationsCobrowsesession updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsCobrowsesession(ctx context.Context, params *PatchConversationsCobrowsesessionParams) (*PatchConversationsCobrowsesessionOK, error)
	/*
	   PatchConversationsCobrowsesessionParticipant updates conversation participant
	*/
	PatchConversationsCobrowsesessionParticipant(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantParams) (*PatchConversationsCobrowsesessionParticipantAccepted, error)
	/*
	   PatchConversationsCobrowsesessionParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsCobrowsesessionParticipantAttributes(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantAttributesParams) (*PatchConversationsCobrowsesessionParticipantAttributesAccepted, error)
	/*
	   PatchConversationsCobrowsesessionParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsCobrowsesessionParticipantCommunication(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantCommunicationParams) (*PatchConversationsCobrowsesessionParticipantCommunicationOK, error)
	/*
	   PatchConversationsEmail updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsEmail(ctx context.Context, params *PatchConversationsEmailParams) (*PatchConversationsEmailOK, error)
	/*
	   PatchConversationsEmailParticipant updates conversation participant
	*/
	PatchConversationsEmailParticipant(ctx context.Context, params *PatchConversationsEmailParticipantParams) (*PatchConversationsEmailParticipantAccepted, error)
	/*
	   PatchConversationsEmailParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsEmailParticipantAttributes(ctx context.Context, params *PatchConversationsEmailParticipantAttributesParams) (*PatchConversationsEmailParticipantAttributesAccepted, error)
	/*
	   PatchConversationsEmailParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsEmailParticipantCommunication(ctx context.Context, params *PatchConversationsEmailParticipantCommunicationParams) (*PatchConversationsEmailParticipantCommunicationOK, error)
	/*
	   PatchConversationsMessage updates a conversation by disconnecting all of the participants
	*/
	PatchConversationsMessage(ctx context.Context, params *PatchConversationsMessageParams) (*PatchConversationsMessageOK, error)
	/*
	   PatchConversationsMessageParticipant updates conversation participant
	*/
	PatchConversationsMessageParticipant(ctx context.Context, params *PatchConversationsMessageParticipantParams) (*PatchConversationsMessageParticipantAccepted, error)
	/*
	   PatchConversationsMessageParticipantAttributes updates the attributes on a conversation participant
	*/
	PatchConversationsMessageParticipantAttributes(ctx context.Context, params *PatchConversationsMessageParticipantAttributesParams) (*PatchConversationsMessageParticipantAttributesAccepted, error)
	/*
	   PatchConversationsMessageParticipantCommunication updates conversation participant s communication by disconnecting it
	*/
	PatchConversationsMessageParticipantCommunication(ctx context.Context, params *PatchConversationsMessageParticipantCommunicationParams) (*PatchConversationsMessageParticipantCommunicationOK, error)
	/*
	   PatchConversationsMessagingIntegrationsFacebookIntegrationID updates facebook messaging integration
	*/
	PatchConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*PatchConversationsMessagingIntegrationsFacebookIntegrationIDOK, error)
	/*
	   PatchConversationsMessagingIntegrationsOpenIntegrationID updates an open messaging integration
	   See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
	*/
	PatchConversationsMessagingIntegrationsOpenIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsOpenIntegrationIDParams) (*PatchConversationsMessagingIntegrationsOpenIntegrationIDOK, error)
	/*
	   PatchConversationsMessagingIntegrationsTwitterIntegrationID updates twitter messaging integration
	*/
	PatchConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*PatchConversationsMessagingIntegrationsTwitterIntegrationIDOK, error)
	/*
	   PatchConversationsMessagingIntegrationsWhatsappIntegrationID updates or activate a whats app messaging integration
	   The following steps are required in order to fully activate a WhatsApp Integration: Initially, you will need to get an activation code by sending: an action set to Activate, and an authenticationMethod choosing from Sms or Voice. Finally, once you have been informed of an activation code on selected authenticationMethod, you will need to confirm the code by sending: an action set to Confirm, and the confirmationCode you have received from Whatsapp.
	*/
	PatchConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*PatchConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error)
	/*
	   PatchConversationsMessagingSupportedcontentSupportedContentID updates a supported content profile
	*/
	PatchConversationsMessagingSupportedcontentSupportedContentID(ctx context.Context, params *PatchConversationsMessagingSupportedcontentSupportedContentIDParams) (*PatchConversationsMessagingSupportedcontentSupportedContentIDOK, error)
	/*
	   PostConversationAssign attempts to manually assign a specified conversation to a specified user ignores bullseye ring p a r score skills and languages
	*/
	PostConversationAssign(ctx context.Context, params *PostConversationAssignParams) (*PostConversationAssignAccepted, error)
	/*
	   PostConversationDisconnect performs a full conversation teardown issues disconnect requests for any connected media applies a system wrap up code to any participants that are pending wrap up this is not intended to be the normal way of ending interactions but is available in the event of problems with the application to allow a resynchronization of state across all components it is recommended that users submit a support case if they are relying on this endpoint systematically as there is likely something that needs investigation
	*/
	PostConversationDisconnect(ctx context.Context, params *PostConversationDisconnectParams) (*PostConversationDisconnectAccepted, error)
	/*
	   PostConversationParticipantCallbacks creates a new callback for the specified participant on the conversation
	*/
	PostConversationParticipantCallbacks(ctx context.Context, params *PostConversationParticipantCallbacksParams) (*PostConversationParticipantCallbacksCreated, error)
	/*
	   PostConversationParticipantDigits sends d t m f to the participant
	*/
	PostConversationParticipantDigits(ctx context.Context, params *PostConversationParticipantDigitsParams) (*PostConversationParticipantDigitsAccepted, error)
	/*
	   PostConversationParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationParticipantReplace(ctx context.Context, params *PostConversationParticipantReplaceParams) (*PostConversationParticipantReplaceAccepted, error)
	/*
	   PostConversationParticipantSecureivrsessions creates secure i v r session only a participant in the conversation can invoke a secure i v r
	*/
	PostConversationParticipantSecureivrsessions(ctx context.Context, params *PostConversationParticipantSecureivrsessionsParams) (*PostConversationParticipantSecureivrsessionsOK, error)
	/*
	   PostConversationsCall places a new call as part of a callback conversation
	*/
	PostConversationsCall(ctx context.Context, params *PostConversationsCallParams) (*PostConversationsCallOK, error)
	/*
	   PostConversationsCallParticipantCoach listens in on the conversation from the point of view of a given participant while speaking to just the given participant
	*/
	PostConversationsCallParticipantCoach(ctx context.Context, params *PostConversationsCallParticipantCoachParams) (*PostConversationsCallParticipantCoachCreated, error)
	/*
	   PostConversationsCallParticipantConsult initiates and update consult transfer
	*/
	PostConversationsCallParticipantConsult(ctx context.Context, params *PostConversationsCallParticipantConsultParams) (*PostConversationsCallParticipantConsultOK, error)
	/*
	   PostConversationsCallParticipantMonitor listens in on the conversation from the point of view of a given participant
	*/
	PostConversationsCallParticipantMonitor(ctx context.Context, params *PostConversationsCallParticipantMonitorParams) (*PostConversationsCallParticipantMonitorCreated, error)
	/*
	   PostConversationsCallParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsCallParticipantReplace(ctx context.Context, params *PostConversationsCallParticipantReplaceParams) (*PostConversationsCallParticipantReplaceAccepted, error)
	/*
	   PostConversationsCallParticipants adds participants to a conversation
	*/
	PostConversationsCallParticipants(ctx context.Context, params *PostConversationsCallParticipantsParams) (*PostConversationsCallParticipantsOK, error)
	/*
	   PostConversationsCallbackParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsCallbackParticipantReplace(ctx context.Context, params *PostConversationsCallbackParticipantReplaceParams) (*PostConversationsCallbackParticipantReplaceAccepted, error)
	/*
	   PostConversationsCallbacks creates a callback
	*/
	PostConversationsCallbacks(ctx context.Context, params *PostConversationsCallbacksParams) (*PostConversationsCallbacksOK, *PostConversationsCallbacksAccepted, error)
	/*
	   PostConversationsCallbacksBulkDisconnect disconnects multiple scheduled callbacks
	*/
	PostConversationsCallbacksBulkDisconnect(ctx context.Context, params *PostConversationsCallbacksBulkDisconnectParams) (*PostConversationsCallbacksBulkDisconnectAccepted, error)
	/*
	   PostConversationsCallbacksBulkUpdate updates multiple scheduled callbacks
	*/
	PostConversationsCallbacksBulkUpdate(ctx context.Context, params *PostConversationsCallbacksBulkUpdateParams) (*PostConversationsCallbacksBulkUpdateOK, error)
	/*
	   PostConversationsCalls creates a call conversation
	*/
	PostConversationsCalls(ctx context.Context, params *PostConversationsCallsParams) (*PostConversationsCallsOK, error)
	/*
	   PostConversationsChatCommunicationMessages sends a message on behalf of a communication in a chat conversation
	*/
	PostConversationsChatCommunicationMessages(ctx context.Context, params *PostConversationsChatCommunicationMessagesParams) (*PostConversationsChatCommunicationMessagesOK, error)
	/*
	   PostConversationsChatCommunicationTyping sends a typing indicator on behalf of a communication in a chat conversation
	*/
	PostConversationsChatCommunicationTyping(ctx context.Context, params *PostConversationsChatCommunicationTypingParams) (*PostConversationsChatCommunicationTypingOK, error)
	/*
	   PostConversationsChatParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsChatParticipantReplace(ctx context.Context, params *PostConversationsChatParticipantReplaceParams) (*PostConversationsChatParticipantReplaceAccepted, error)
	/*
	   PostConversationsChats creates a web chat conversation
	*/
	PostConversationsChats(ctx context.Context, params *PostConversationsChatsParams) (*PostConversationsChatsOK, error)
	/*
	   PostConversationsCobrowsesessionParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsCobrowsesessionParticipantReplace(ctx context.Context, params *PostConversationsCobrowsesessionParticipantReplaceParams) (*PostConversationsCobrowsesessionParticipantReplaceAccepted, error)
	/*
	   PostConversationsEmailInboundmessages sends an email to an external conversation an external conversation is one where the provider is not pure cloud based this endpoint allows the sender of the external email to reply or send a new message to the existing conversation the new message will be treated as part of the existing conversation and chained to it
	*/
	PostConversationsEmailInboundmessages(ctx context.Context, params *PostConversationsEmailInboundmessagesParams) (*PostConversationsEmailInboundmessagesOK, error)
	/*
	   PostConversationsEmailMessages sends an email reply
	*/
	PostConversationsEmailMessages(ctx context.Context, params *PostConversationsEmailMessagesParams) (*PostConversationsEmailMessagesOK, error)
	/*
	   PostConversationsEmailMessagesDraftAttachmentsCopy copies attachments from an email message to the current draft
	*/
	PostConversationsEmailMessagesDraftAttachmentsCopy(ctx context.Context, params *PostConversationsEmailMessagesDraftAttachmentsCopyParams) (*PostConversationsEmailMessagesDraftAttachmentsCopyOK, error)
	/*
	   PostConversationsEmailParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsEmailParticipantReplace(ctx context.Context, params *PostConversationsEmailParticipantReplaceParams) (*PostConversationsEmailParticipantReplaceAccepted, error)
	/*
	   PostConversationsEmails creates an email conversation
	   If the direction of the request is INBOUND, this will create an external conversation with a third party provider. If the direction of the the request is OUTBOUND, this will create a conversation to send outbound emails on behalf of a queue.
	*/
	PostConversationsEmails(ctx context.Context, params *PostConversationsEmailsParams) (*PostConversationsEmailsOK, error)
	/*
	   PostConversationsEmailsAgentless creates an email conversation per API
	*/
	PostConversationsEmailsAgentless(ctx context.Context, params *PostConversationsEmailsAgentlessParams) (*PostConversationsEmailsAgentlessOK, error)
	/*
	   PostConversationsFaxes creates fax conversation
	*/
	PostConversationsFaxes(ctx context.Context, params *PostConversationsFaxesParams) (*PostConversationsFaxesOK, error)
	/*
	   PostConversationsKeyconfigurations setups configurations for encryption key creation
	*/
	PostConversationsKeyconfigurations(ctx context.Context, params *PostConversationsKeyconfigurationsParams) (*PostConversationsKeyconfigurationsOK, error)
	/*
	   PostConversationsKeyconfigurationsValidate validates encryption key configurations without saving it
	*/
	PostConversationsKeyconfigurationsValidate(ctx context.Context, params *PostConversationsKeyconfigurationsValidateParams) (*PostConversationsKeyconfigurationsValidateOK, error)
	/*
	   PostConversationsMessageCommunicationMessages sends message
	   Send message on existing conversation/communication. Only one message body field can be accepted, per request. Example: 1 textBody, 1 mediaId, 1 stickerId, or 1 messageTemplate.
	*/
	PostConversationsMessageCommunicationMessages(ctx context.Context, params *PostConversationsMessageCommunicationMessagesParams) (*PostConversationsMessageCommunicationMessagesOK, *PostConversationsMessageCommunicationMessagesAccepted, error)
	/*
	   PostConversationsMessageCommunicationMessagesMedia creates media
	   See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage.
	*/
	PostConversationsMessageCommunicationMessagesMedia(ctx context.Context, params *PostConversationsMessageCommunicationMessagesMediaParams) (*PostConversationsMessageCommunicationMessagesMediaAccepted, error)
	/*
	   PostConversationsMessageMessagesBulk gets messages in batch
	   The path parameter [conversationId] should contain the conversationId of the conversation being filtered. The body should contain the messageId(s) of messages being requested. For example: ["a3069a33b-bbb1-4703-9d68-061d9e9db96e", "55bc6be3-078c-4a49-a4e6-1e05776ed7e8"]
	*/
	PostConversationsMessageMessagesBulk(ctx context.Context, params *PostConversationsMessageMessagesBulkParams) (*PostConversationsMessageMessagesBulkOK, error)
	/*
	   PostConversationsMessageParticipantReplace replaces this participant with the specified user and or address
	*/
	PostConversationsMessageParticipantReplace(ctx context.Context, params *PostConversationsMessageParticipantReplaceParams) (*PostConversationsMessageParticipantReplaceAccepted, error)
	/*
	   PostConversationsMessages creates an outbound messaging conversation
	   If there is an existing conversation between the remote address and the address associated with the queue specified in createOutboundRequest then the result of this request depends on the state of that conversation and the useExistingConversation field of createOutboundRequest. If the existing conversation is in alerting or connected state, then the request will fail. If the existing conversation is disconnected but still within the conversation window then the request will fail unless useExistingConversation is set to true.
	*/
	PostConversationsMessages(ctx context.Context, params *PostConversationsMessagesParams) (*PostConversationsMessagesOK, error)
	/*
	   PostConversationsMessagesAgentless sends an agentless outbound message
	   Send an agentless (api participant) outbound message using a client credential grant. In order to call this endpoint you will need OAuth token generated using OAuth client credentials authorized with at least messaging scope. This will generate a new Conversation, if there is an existing active Conversation between the fromAddress and toAddress already, then this POST will fail.
	*/
	PostConversationsMessagesAgentless(ctx context.Context, params *PostConversationsMessagesAgentlessParams) (*PostConversationsMessagesAgentlessOK, *PostConversationsMessagesAgentlessAccepted, error)
	/*
	   PostConversationsMessagesInboundOpen sends an inbound open message
	   Send an inbound message to an Open Messaging integration. In order to call this endpoint you will need OAuth token generated using OAuth client credentials authorized with at least messaging scope. This will either generate a new Conversation, or be a part of an existing conversation. See https://developer.genesys.cloud/api/digital/openmessaging/ for example usage.
	*/
	PostConversationsMessagesInboundOpen(ctx context.Context, params *PostConversationsMessagesInboundOpenParams) (*PostConversationsMessagesInboundOpenOK, *PostConversationsMessagesInboundOpenAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsFacebook creates a facebook integration
	*/
	PostConversationsMessagingIntegrationsFacebook(ctx context.Context, params *PostConversationsMessagingIntegrationsFacebookParams) (*PostConversationsMessagingIntegrationsFacebookOK, *PostConversationsMessagingIntegrationsFacebookAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsLine creates a l i n e messenger integration
	*/
	PostConversationsMessagingIntegrationsLine(ctx context.Context, params *PostConversationsMessagingIntegrationsLineParams) (*PostConversationsMessagingIntegrationsLineOK, *PostConversationsMessagingIntegrationsLineAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsOpen creates an open messaging integration
	   See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
	*/
	PostConversationsMessagingIntegrationsOpen(ctx context.Context, params *PostConversationsMessagingIntegrationsOpenParams) (*PostConversationsMessagingIntegrationsOpenOK, *PostConversationsMessagingIntegrationsOpenAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsTwitter creates a twitter integration
	*/
	PostConversationsMessagingIntegrationsTwitter(ctx context.Context, params *PostConversationsMessagingIntegrationsTwitterParams) (*PostConversationsMessagingIntegrationsTwitterOK, *PostConversationsMessagingIntegrationsTwitterAccepted, error)
	/*
	   PostConversationsMessagingIntegrationsWhatsapp creates a whats app integration
	   You must be approved by WhatsApp to use this feature. Your approved e164-formatted phone number and valid WhatsApp certificate for your number are required. Your WhatsApp certificate must have valid base64 encoding. Please paste carefully and do not add any leading or trailing spaces. Do not alter any characters. An integration must be activated within 7 days of certificate generation. If you cannot complete the addition and activation of the number within 7 days, please obtain a new certificate before creating the integration. Integrations created with an invalid number or certificate may immediately incur additional integration fees. Please carefully enter your number and certificate as described.
	*/
	PostConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *PostConversationsMessagingIntegrationsWhatsappParams) (*PostConversationsMessagingIntegrationsWhatsappOK, *PostConversationsMessagingIntegrationsWhatsappAccepted, error)
	/*
	   PostConversationsMessagingSupportedcontent creates a supported content profile
	*/
	PostConversationsMessagingSupportedcontent(ctx context.Context, params *PostConversationsMessagingSupportedcontentParams) (*PostConversationsMessagingSupportedcontentOK, *PostConversationsMessagingSupportedcontentCreated, error)
	/*
	   PutConversationParticipantFlaggedreason sets flagged reason on conversation participant to indicate bad conversation quality
	*/
	PutConversationParticipantFlaggedreason(ctx context.Context, params *PutConversationParticipantFlaggedreasonParams) (*PutConversationParticipantFlaggedreasonNoContent, error)
	/*
	   PutConversationSecureattributes sets the secure attributes on a conversation
	*/
	PutConversationSecureattributes(ctx context.Context, params *PutConversationSecureattributesParams) (*PutConversationSecureattributesAccepted, error)
	/*
	   PutConversationTags updates the tags on a conversation
	*/
	PutConversationTags(ctx context.Context, params *PutConversationTagsParams) (*PutConversationTagsAccepted, error)
	/*
	   PutConversationsCallParticipantCommunicationUuidata sets uui data to be sent on future commands
	*/
	PutConversationsCallParticipantCommunicationUuidata(ctx context.Context, params *PutConversationsCallParticipantCommunicationUuidataParams) (*PutConversationsCallParticipantCommunicationUuidataOK, error)
	/*
	   PutConversationsCallRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsCallRecordingstate(ctx context.Context, params *PutConversationsCallRecordingstateParams) (*PutConversationsCallRecordingstateOK, *PutConversationsCallRecordingstateAccepted, error)
	/*
	   PutConversationsCallbackRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsCallbackRecordingstate(ctx context.Context, params *PutConversationsCallbackRecordingstateParams) (*PutConversationsCallbackRecordingstateOK, *PutConversationsCallbackRecordingstateAccepted, error)
	/*
	   PutConversationsChatRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsChatRecordingstate(ctx context.Context, params *PutConversationsChatRecordingstateParams) (*PutConversationsChatRecordingstateOK, *PutConversationsChatRecordingstateAccepted, error)
	/*
	   PutConversationsCobrowsesessionRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsCobrowsesessionRecordingstate(ctx context.Context, params *PutConversationsCobrowsesessionRecordingstateParams) (*PutConversationsCobrowsesessionRecordingstateOK, *PutConversationsCobrowsesessionRecordingstateAccepted, error)
	/*
	   PutConversationsEmailMessagesDraft updates conversation draft reply
	*/
	PutConversationsEmailMessagesDraft(ctx context.Context, params *PutConversationsEmailMessagesDraftParams) (*PutConversationsEmailMessagesDraftOK, error)
	/*
	   PutConversationsEmailRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsEmailRecordingstate(ctx context.Context, params *PutConversationsEmailRecordingstateParams) (*PutConversationsEmailRecordingstateOK, *PutConversationsEmailRecordingstateAccepted, error)
	/*
	   PutConversationsKeyconfiguration updates the encryption key configurations
	*/
	PutConversationsKeyconfiguration(ctx context.Context, params *PutConversationsKeyconfigurationParams) (*PutConversationsKeyconfigurationOK, error)
	/*
	   PutConversationsMessageRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsMessageRecordingstate(ctx context.Context, params *PutConversationsMessageRecordingstateParams) (*PutConversationsMessageRecordingstateOK, *PutConversationsMessageRecordingstateAccepted, error)
	/*
	   PutConversationsMessagingIntegrationsLineIntegrationID updates a l i n e messenger integration
	*/
	PutConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *PutConversationsMessagingIntegrationsLineIntegrationIDParams) (*PutConversationsMessagingIntegrationsLineIntegrationIDOK, error)
	/*
	   PutConversationsMessagingSupportedcontentDefault sets the organization s default supported content profile that may be assigned to an integration when it is created
	   When an integration is created a supported content ID may be assigned to it. If the supported content ID is not supplied, the default supported content profile will be assigned to it.
	*/
	PutConversationsMessagingSupportedcontentDefault(ctx context.Context, params *PutConversationsMessagingSupportedcontentDefaultParams) (*PutConversationsMessagingSupportedcontentDefaultOK, error)
	/*
	   PutConversationsMessagingThreadingtimeline updates conversation threading window timeline for each messaging type
	   PUT Conversation messaging threading timeline is intended to set the conversation threading settings for ALL messengerTypes. If you omit a messengerType in the request body then the setting for that messengerType will use the platform default value. The PUT replaces the existing setting(s) that were previously set for each messengerType.
	*/
	PutConversationsMessagingThreadingtimeline(ctx context.Context, params *PutConversationsMessagingThreadingtimelineParams) (*PutConversationsMessagingThreadingtimelineOK, error)
	/*
	   PutConversationsScreenshareRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsScreenshareRecordingstate(ctx context.Context, params *PutConversationsScreenshareRecordingstateParams) (*PutConversationsScreenshareRecordingstateOK, *PutConversationsScreenshareRecordingstateAccepted, error)
	/*
	   PutConversationsSocialRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsSocialRecordingstate(ctx context.Context, params *PutConversationsSocialRecordingstateParams) (*PutConversationsSocialRecordingstateOK, *PutConversationsSocialRecordingstateAccepted, error)
	/*
	   PutConversationsVideoRecordingstate updates a conversation by setting its recording state
	*/
	PutConversationsVideoRecordingstate(ctx context.Context, params *PutConversationsVideoRecordingstateParams) (*PutConversationsVideoRecordingstateOK, *PutConversationsVideoRecordingstateAccepted, error)
}

// New creates a new conversations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for conversations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
DeleteConversationParticipantCode deletes a code used to add a communication to this participant
*/
func (a *Client) DeleteConversationParticipantCode(ctx context.Context, params *DeleteConversationParticipantCodeParams) error {

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationParticipantCode",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/codes/{addCommunicationCode}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationParticipantCodeReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
DeleteConversationParticipantFlaggedreason removes flagged reason from conversation participant
*/
func (a *Client) DeleteConversationParticipantFlaggedreason(ctx context.Context, params *DeleteConversationParticipantFlaggedreasonParams) (*DeleteConversationParticipantFlaggedreasonNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationParticipantFlaggedreason",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationParticipantFlaggedreasonReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationParticipantFlaggedreasonNoContent), nil

}

/*
DeleteConversationsCallParticipantConsult cancels the transfer
*/
func (a *Client) DeleteConversationsCallParticipantConsult(ctx context.Context, params *DeleteConversationsCallParticipantConsultParams) (*DeleteConversationsCallParticipantConsultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsCallParticipantConsult",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsCallParticipantConsultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsCallParticipantConsultOK), nil

}

/*
DeleteConversationsEmailMessagesDraftAttachment deletes attachment from draft
*/
func (a *Client) DeleteConversationsEmailMessagesDraftAttachment(ctx context.Context, params *DeleteConversationsEmailMessagesDraftAttachmentParams) (*DeleteConversationsEmailMessagesDraftAttachmentOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsEmailMessagesDraftAttachment",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/{attachmentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsEmailMessagesDraftAttachmentReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsEmailMessagesDraftAttachmentOK), nil

}

/*
DeleteConversationsMessagingIntegrationsFacebookIntegrationID deletes a facebook messaging integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsFacebookIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsFacebookIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsFacebookIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsFacebookIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsLineIntegrationID deletes a l i n e messenger integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsLineIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsLineIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsLineIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsLineIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsLineIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsOpenIntegrationID deletes an open messaging integration

See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
*/
func (a *Client) DeleteConversationsMessagingIntegrationsOpenIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsOpenIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsOpenIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsOpenIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/open/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsOpenIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsOpenIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsTwitterIntegrationID deletes a twitter messaging integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsTwitterIntegrationIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsTwitterIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsTwitterIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingIntegrationsTwitterIntegrationIDNoContent), nil

}

/*
DeleteConversationsMessagingIntegrationsWhatsappIntegrationID deletes a whats app messaging integration
*/
func (a *Client) DeleteConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingIntegrationsWhatsappIntegrationId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDOK:
		return value, nil, nil
	case *DeleteConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteConversationsMessagingSupportedcontentSupportedContentID deletes a supported content profile
*/
func (a *Client) DeleteConversationsMessagingSupportedcontentSupportedContentID(ctx context.Context, params *DeleteConversationsMessagingSupportedcontentSupportedContentIDParams) (*DeleteConversationsMessagingSupportedcontentSupportedContentIDNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationsMessagingSupportedcontentSupportedContentId",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationsMessagingSupportedcontentSupportedContentIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteConversationsMessagingSupportedcontentSupportedContentIDNoContent), nil

}

/*
GetConversation gets conversation
*/
func (a *Client) GetConversation(ctx context.Context, params *GetConversationParams) (*GetConversationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversation",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationOK), nil

}

/*
GetConversationParticipantSecureivrsession fetches info on a secure session
*/
func (a *Client) GetConversationParticipantSecureivrsession(ctx context.Context, params *GetConversationParticipantSecureivrsessionParams) (*GetConversationParticipantSecureivrsessionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantSecureivrsession",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions/{secureSessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantSecureivrsessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantSecureivrsessionOK), nil

}

/*
GetConversationParticipantSecureivrsessions gets a list of secure sessions for this participant
*/
func (a *Client) GetConversationParticipantSecureivrsessions(ctx context.Context, params *GetConversationParticipantSecureivrsessionsParams) (*GetConversationParticipantSecureivrsessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantSecureivrsessions",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantSecureivrsessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantSecureivrsessionsOK), nil

}

/*
GetConversationParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationParticipantWrapup(ctx context.Context, params *GetConversationParticipantWrapupParams) (*GetConversationParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantWrapupOK), nil

}

/*
GetConversationParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationParticipantWrapupcodes(ctx context.Context, params *GetConversationParticipantWrapupcodesParams) (*GetConversationParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationParticipantWrapupcodesOK), nil

}

/*
GetConversationSecureattributes gets the secure attributes on a conversation
*/
func (a *Client) GetConversationSecureattributes(ctx context.Context, params *GetConversationSecureattributesParams) (*GetConversationSecureattributesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationSecureattributes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/secureattributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationSecureattributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationSecureattributesOK), nil

}

/*
GetConversations gets active conversations for the logged in user
*/
func (a *Client) GetConversations(ctx context.Context, params *GetConversationsParams) (*GetConversationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversations",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsOK), nil

}

/*
GetConversationsCall gets call conversation
*/
func (a *Client) GetConversationsCall(ctx context.Context, params *GetConversationsCallParams) (*GetConversationsCallOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCall",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallOK), nil

}

/*
GetConversationsCallParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsCallParticipantWrapup(ctx context.Context, params *GetConversationsCallParticipantWrapupParams) (*GetConversationsCallParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallParticipantWrapupOK), nil

}

/*
GetConversationsCallParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsCallParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallParticipantWrapupcodesParams) (*GetConversationsCallParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallParticipantWrapupcodesOK), nil

}

/*
GetConversationsCallback gets callback conversation
*/
func (a *Client) GetConversationsCallback(ctx context.Context, params *GetConversationsCallbackParams) (*GetConversationsCallbackOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallback",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbackReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbackOK), nil

}

/*
GetConversationsCallbackParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsCallbackParticipantWrapup(ctx context.Context, params *GetConversationsCallbackParticipantWrapupParams) (*GetConversationsCallbackParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallbackParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbackParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbackParticipantWrapupOK), nil

}

/*
GetConversationsCallbackParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsCallbackParticipantWrapupcodes(ctx context.Context, params *GetConversationsCallbackParticipantWrapupcodesParams) (*GetConversationsCallbackParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallbackParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbackParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbackParticipantWrapupcodesOK), nil

}

/*
GetConversationsCallbacks gets active callback conversations for the logged in user
*/
func (a *Client) GetConversationsCallbacks(ctx context.Context, params *GetConversationsCallbacksParams) (*GetConversationsCallbacksOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallbacks",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallbacksOK), nil

}

/*
GetConversationsCalls gets active call conversations for the logged in user
*/
func (a *Client) GetConversationsCalls(ctx context.Context, params *GetConversationsCallsParams) (*GetConversationsCallsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCalls",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallsOK), nil

}

/*
GetConversationsCallsHistory gets call history
*/
func (a *Client) GetConversationsCallsHistory(ctx context.Context, params *GetConversationsCallsHistoryParams) (*GetConversationsCallsHistoryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallsHistory",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallsHistoryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallsHistoryOK), nil

}

/*
GetConversationsCallsMaximumconferenceparties gets the maximum number of participants that this user can have on a conference
*/
func (a *Client) GetConversationsCallsMaximumconferenceparties(ctx context.Context, params *GetConversationsCallsMaximumconferencepartiesParams) (*GetConversationsCallsMaximumconferencepartiesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCallsMaximumconferenceparties",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/calls/maximumconferenceparties",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCallsMaximumconferencepartiesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCallsMaximumconferencepartiesOK), nil

}

/*
GetConversationsChat gets chat conversation
*/
func (a *Client) GetConversationsChat(ctx context.Context, params *GetConversationsChatParams) (*GetConversationsChatOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChat",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatOK), nil

}

/*
GetConversationsChatMessage gets a web chat conversation message

The current user must be involved with the conversation to get its messages.
*/
func (a *Client) GetConversationsChatMessage(ctx context.Context, params *GetConversationsChatMessageParams) (*GetConversationsChatMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/messages/{messageId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatMessageOK), nil

}

/*
GetConversationsChatMessages gets the messages of a chat conversation

The current user must be involved with the conversation to get its messages.
*/
func (a *Client) GetConversationsChatMessages(ctx context.Context, params *GetConversationsChatMessagesParams) (*GetConversationsChatMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatMessages",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatMessagesOK), nil

}

/*
GetConversationsChatParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsChatParticipantWrapup(ctx context.Context, params *GetConversationsChatParticipantWrapupParams) (*GetConversationsChatParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatParticipantWrapupOK), nil

}

/*
GetConversationsChatParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsChatParticipantWrapupcodes(ctx context.Context, params *GetConversationsChatParticipantWrapupcodesParams) (*GetConversationsChatParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChatParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatParticipantWrapupcodesOK), nil

}

/*
GetConversationsChats gets active chat conversations for the logged in user
*/
func (a *Client) GetConversationsChats(ctx context.Context, params *GetConversationsChatsParams) (*GetConversationsChatsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsChats",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/chats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsChatsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsChatsOK), nil

}

/*
GetConversationsCobrowsesession gets cobrowse conversation
*/
func (a *Client) GetConversationsCobrowsesession(ctx context.Context, params *GetConversationsCobrowsesessionParams) (*GetConversationsCobrowsesessionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesession",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionOK), nil

}

/*
GetConversationsCobrowsesessionParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsCobrowsesessionParticipantWrapup(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupParams) (*GetConversationsCobrowsesessionParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesessionParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionParticipantWrapupOK), nil

}

/*
GetConversationsCobrowsesessionParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsCobrowsesessionParticipantWrapupcodes(ctx context.Context, params *GetConversationsCobrowsesessionParticipantWrapupcodesParams) (*GetConversationsCobrowsesessionParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesessionParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionParticipantWrapupcodesOK), nil

}

/*
GetConversationsCobrowsesessions gets active cobrowse conversations for the logged in user
*/
func (a *Client) GetConversationsCobrowsesessions(ctx context.Context, params *GetConversationsCobrowsesessionsParams) (*GetConversationsCobrowsesessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsCobrowsesessions",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/cobrowsesessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsCobrowsesessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsCobrowsesessionsOK), nil

}

/*
GetConversationsEmail gets email conversation
*/
func (a *Client) GetConversationsEmail(ctx context.Context, params *GetConversationsEmailParams) (*GetConversationsEmailOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmail",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailOK), nil

}

/*
GetConversationsEmailMessage gets conversation message
*/
func (a *Client) GetConversationsEmailMessage(ctx context.Context, params *GetConversationsEmailMessageParams) (*GetConversationsEmailMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/{messageId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailMessageOK), nil

}

/*
GetConversationsEmailMessages gets conversation messages
*/
func (a *Client) GetConversationsEmailMessages(ctx context.Context, params *GetConversationsEmailMessagesParams) (*GetConversationsEmailMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailMessages",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailMessagesOK), nil

}

/*
GetConversationsEmailMessagesDraft gets conversation draft reply
*/
func (a *Client) GetConversationsEmailMessagesDraft(ctx context.Context, params *GetConversationsEmailMessagesDraftParams) (*GetConversationsEmailMessagesDraftOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailMessagesDraft",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailMessagesDraftReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailMessagesDraftOK), nil

}

/*
GetConversationsEmailParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsEmailParticipantWrapup(ctx context.Context, params *GetConversationsEmailParticipantWrapupParams) (*GetConversationsEmailParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailParticipantWrapupOK), nil

}

/*
GetConversationsEmailParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsEmailParticipantWrapupcodes(ctx context.Context, params *GetConversationsEmailParticipantWrapupcodesParams) (*GetConversationsEmailParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailParticipantWrapupcodesOK), nil

}

/*
GetConversationsEmailSettings gets emails settings for a given conversation
*/
func (a *Client) GetConversationsEmailSettings(ctx context.Context, params *GetConversationsEmailSettingsParams) (*GetConversationsEmailSettingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmailSettings",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailSettingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailSettingsOK), nil

}

/*
GetConversationsEmails gets active email conversations for the logged in user
*/
func (a *Client) GetConversationsEmails(ctx context.Context, params *GetConversationsEmailsParams) (*GetConversationsEmailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsEmails",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsEmailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsEmailsOK), nil

}

/*
GetConversationsKeyconfiguration gets the encryption key configurations
*/
func (a *Client) GetConversationsKeyconfiguration(ctx context.Context, params *GetConversationsKeyconfigurationParams) (*GetConversationsKeyconfigurationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsKeyconfiguration",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/keyconfigurations/{keyconfigurationsId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsKeyconfigurationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsKeyconfigurationOK), nil

}

/*
GetConversationsKeyconfigurations gets a list of key configurations data
*/
func (a *Client) GetConversationsKeyconfigurations(ctx context.Context, params *GetConversationsKeyconfigurationsParams) (*GetConversationsKeyconfigurationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsKeyconfigurations",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/keyconfigurations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsKeyconfigurationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsKeyconfigurationsOK), nil

}

/*
GetConversationsMessage gets message conversation
*/
func (a *Client) GetConversationsMessage(ctx context.Context, params *GetConversationsMessageParams) (*GetConversationsMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageOK), nil

}

/*
GetConversationsMessageCommunicationMessagesMediaMediaID gets media

See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage.
*/
func (a *Client) GetConversationsMessageCommunicationMessagesMediaMediaID(ctx context.Context, params *GetConversationsMessageCommunicationMessagesMediaMediaIDParams) (*GetConversationsMessageCommunicationMessagesMediaMediaIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageCommunicationMessagesMediaMediaId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media/{mediaId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageCommunicationMessagesMediaMediaIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageCommunicationMessagesMediaMediaIDOK), nil

}

/*
GetConversationsMessageDetails gets message
*/
func (a *Client) GetConversationsMessageDetails(ctx context.Context, params *GetConversationsMessageDetailsParams) (*GetConversationsMessageDetailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageDetails",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{messageId}/details",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageDetailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageDetailsOK), nil

}

/*
GetConversationsMessageMessage gets conversation message
*/
func (a *Client) GetConversationsMessageMessage(ctx context.Context, params *GetConversationsMessageMessageParams) (*GetConversationsMessageMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageMessage",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/messages/{messageId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageMessageOK), nil

}

/*
GetConversationsMessageParticipantWrapup gets the wrap up for this conversation participant
*/
func (a *Client) GetConversationsMessageParticipantWrapup(ctx context.Context, params *GetConversationsMessageParticipantWrapupParams) (*GetConversationsMessageParticipantWrapupOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageParticipantWrapup",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapup",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageParticipantWrapupReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageParticipantWrapupOK), nil

}

/*
GetConversationsMessageParticipantWrapupcodes gets list of wrapup codes for this conversation participant
*/
func (a *Client) GetConversationsMessageParticipantWrapupcodes(ctx context.Context, params *GetConversationsMessageParticipantWrapupcodesParams) (*GetConversationsMessageParticipantWrapupcodesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessageParticipantWrapupcodes",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/wrapupcodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessageParticipantWrapupcodesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessageParticipantWrapupcodesOK), nil

}

/*
GetConversationsMessages gets active message conversations for the logged in user
*/
func (a *Client) GetConversationsMessages(ctx context.Context, params *GetConversationsMessagesParams) (*GetConversationsMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessages",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagesOK), nil

}

/*
GetConversationsMessagingFacebookApp gets genesys facebook app Id
*/
func (a *Client) GetConversationsMessagingFacebookApp(ctx context.Context, params *GetConversationsMessagingFacebookAppParams) (*GetConversationsMessagingFacebookAppOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingFacebookApp",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/facebook/app",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingFacebookAppReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingFacebookAppOK), nil

}

/*
GetConversationsMessagingIntegrations gets a list of integrations
*/
func (a *Client) GetConversationsMessagingIntegrations(ctx context.Context, params *GetConversationsMessagingIntegrationsParams) (*GetConversationsMessagingIntegrationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrations",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsOK), nil

}

/*
GetConversationsMessagingIntegrationsFacebook gets a list of facebook integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsFacebook(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookParams) (*GetConversationsMessagingIntegrationsFacebookOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsFacebook",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsFacebookReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsFacebookOK), nil

}

/*
GetConversationsMessagingIntegrationsFacebookIntegrationID gets a facebook messaging integration
*/
func (a *Client) GetConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*GetConversationsMessagingIntegrationsFacebookIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsFacebookIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsFacebookIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsFacebookIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsLine gets a list of l i n e messenger integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsLine(ctx context.Context, params *GetConversationsMessagingIntegrationsLineParams) (*GetConversationsMessagingIntegrationsLineOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsLine",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsLineReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsLineOK), nil

}

/*
GetConversationsMessagingIntegrationsLineIntegrationID gets a l i n e messenger integration
*/
func (a *Client) GetConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsLineIntegrationIDParams) (*GetConversationsMessagingIntegrationsLineIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsLineIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsLineIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsLineIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsOpen gets a list of open messaging integrations

See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
*/
func (a *Client) GetConversationsMessagingIntegrationsOpen(ctx context.Context, params *GetConversationsMessagingIntegrationsOpenParams) (*GetConversationsMessagingIntegrationsOpenOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsOpen",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/open",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsOpenReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsOpenOK), nil

}

/*
GetConversationsMessagingIntegrationsOpenIntegrationID gets an open messaging integration

See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
*/
func (a *Client) GetConversationsMessagingIntegrationsOpenIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsOpenIntegrationIDParams) (*GetConversationsMessagingIntegrationsOpenIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsOpenIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/open/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsOpenIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsOpenIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsTwitter gets a list of twitter integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsTwitter(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterParams) (*GetConversationsMessagingIntegrationsTwitterOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsTwitter",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsTwitterReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsTwitterOK), nil

}

/*
GetConversationsMessagingIntegrationsTwitterIntegrationID gets a twitter messaging integration
*/
func (a *Client) GetConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*GetConversationsMessagingIntegrationsTwitterIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsTwitterIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsTwitterIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsTwitterIntegrationIDOK), nil

}

/*
GetConversationsMessagingIntegrationsWhatsapp gets a list of whats app integrations
*/
func (a *Client) GetConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappParams) (*GetConversationsMessagingIntegrationsWhatsappOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsWhatsapp",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsWhatsappReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsWhatsappOK), nil

}

/*
GetConversationsMessagingIntegrationsWhatsappIntegrationID gets a whats app messaging integration
*/
func (a *Client) GetConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *GetConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*GetConversationsMessagingIntegrationsWhatsappIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingIntegrationsWhatsappIntegrationId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingIntegrationsWhatsappIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingIntegrationsWhatsappIntegrationIDOK), nil

}

/*
GetConversationsMessagingSticker gets a list of messaging stickers
*/
func (a *Client) GetConversationsMessagingSticker(ctx context.Context, params *GetConversationsMessagingStickerParams) (*GetConversationsMessagingStickerOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingSticker",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/stickers/{messengerType}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingStickerReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingStickerOK), nil

}

/*
GetConversationsMessagingSupportedcontent gets a list of supported content profiles
*/
func (a *Client) GetConversationsMessagingSupportedcontent(ctx context.Context, params *GetConversationsMessagingSupportedcontentParams) (*GetConversationsMessagingSupportedcontentOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingSupportedcontent",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingSupportedcontentReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingSupportedcontentOK), nil

}

/*
GetConversationsMessagingSupportedcontentDefault gets the organization s default supported content profile that will be used as the default when creating an integration

When an integration is created a supported content ID may be assigned to it. If the supported content ID is not supplied, the default supported content profile will be assigned to it.
*/
func (a *Client) GetConversationsMessagingSupportedcontentDefault(ctx context.Context, params *GetConversationsMessagingSupportedcontentDefaultParams) (*GetConversationsMessagingSupportedcontentDefaultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingSupportedcontentDefault",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent/default",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingSupportedcontentDefaultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingSupportedcontentDefaultOK), nil

}

/*
GetConversationsMessagingSupportedcontentSupportedContentID gets a supported content profile
*/
func (a *Client) GetConversationsMessagingSupportedcontentSupportedContentID(ctx context.Context, params *GetConversationsMessagingSupportedcontentSupportedContentIDParams) (*GetConversationsMessagingSupportedcontentSupportedContentIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingSupportedcontentSupportedContentId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingSupportedcontentSupportedContentIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingSupportedcontentSupportedContentIDOK), nil

}

/*
GetConversationsMessagingThreadingtimeline gets conversation threading window timeline for each messaging type

Conversation messaging threading timeline is a setting defined for each messenger type in your organization. This setting will dictate whether a new message is added to the most recent existing conversation, or creates a new Conversation. If the existing Conversation is still in a connected state the threading timeline setting will never play a role. After the conversation is disconnected, if an inbound message is received or an outbound message is sent after the setting for threading timeline expires, a new conversation is created.
*/
func (a *Client) GetConversationsMessagingThreadingtimeline(ctx context.Context, params *GetConversationsMessagingThreadingtimelineParams) (*GetConversationsMessagingThreadingtimelineOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationsMessagingThreadingtimeline",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/messaging/threadingtimeline",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationsMessagingThreadingtimelineReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationsMessagingThreadingtimelineOK), nil

}

/*
PatchConversationParticipant updates a participant

Update conversation participant.
*/
func (a *Client) PatchConversationParticipant(ctx context.Context, params *PatchConversationParticipantParams) (*PatchConversationParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationParticipantAccepted), nil

}

/*
PatchConversationParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationParticipantAttributes(ctx context.Context, params *PatchConversationParticipantAttributesParams) (*PatchConversationParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationParticipantAttributesAccepted), nil

}

/*
PatchConversationSecureattributes updates the secure attributes on a conversation
*/
func (a *Client) PatchConversationSecureattributes(ctx context.Context, params *PatchConversationSecureattributesParams) (*PatchConversationSecureattributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationSecureattributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/{conversationId}/secureattributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationSecureattributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationSecureattributesAccepted), nil

}

/*
PatchConversationsCall updates a conversation by setting its recording state merging in other conversations to create a conference or disconnecting all of the participants
*/
func (a *Client) PatchConversationsCall(ctx context.Context, params *PatchConversationsCallParams) (*PatchConversationsCallOK, *PatchConversationsCallAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCall",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchConversationsCallOK:
		return value, nil, nil
	case *PatchConversationsCallAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PatchConversationsCallParticipant updates conversation participant
*/
func (a *Client) PatchConversationsCallParticipant(ctx context.Context, params *PatchConversationsCallParticipantParams) (*PatchConversationsCallParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantAccepted), nil

}

/*
PatchConversationsCallParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsCallParticipantAttributes(ctx context.Context, params *PatchConversationsCallParticipantAttributesParams) (*PatchConversationsCallParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantAttributesAccepted), nil

}

/*
PatchConversationsCallParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsCallParticipantCommunication(ctx context.Context, params *PatchConversationsCallParticipantCommunicationParams) (*PatchConversationsCallParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantCommunicationOK), nil

}

/*
PatchConversationsCallParticipantConsult changes who can speak
*/
func (a *Client) PatchConversationsCallParticipantConsult(ctx context.Context, params *PatchConversationsCallParticipantConsultParams) (*PatchConversationsCallParticipantConsultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallParticipantConsult",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallParticipantConsultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallParticipantConsultOK), nil

}

/*
PatchConversationsCallback updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsCallback(ctx context.Context, params *PatchConversationsCallbackParams) (*PatchConversationsCallbackOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallback",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackOK), nil

}

/*
PatchConversationsCallbackParticipant updates conversation participant
*/
func (a *Client) PatchConversationsCallbackParticipant(ctx context.Context, params *PatchConversationsCallbackParticipantParams) (*PatchConversationsCallbackParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbackParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackParticipantAccepted), nil

}

/*
PatchConversationsCallbackParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsCallbackParticipantAttributes(ctx context.Context, params *PatchConversationsCallbackParticipantAttributesParams) (*PatchConversationsCallbackParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbackParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackParticipantAttributesAccepted), nil

}

/*
PatchConversationsCallbackParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsCallbackParticipantCommunication(ctx context.Context, params *PatchConversationsCallbackParticipantCommunicationParams) (*PatchConversationsCallbackParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbackParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbackParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbackParticipantCommunicationOK), nil

}

/*
PatchConversationsCallbacks updates a scheduled callback
*/
func (a *Client) PatchConversationsCallbacks(ctx context.Context, params *PatchConversationsCallbacksParams) (*PatchConversationsCallbacksOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCallbacks",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCallbacksOK), nil

}

/*
PatchConversationsChat updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsChat(ctx context.Context, params *PatchConversationsChatParams) (*PatchConversationsChatOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChat",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatOK), nil

}

/*
PatchConversationsChatParticipant updates conversation participant
*/
func (a *Client) PatchConversationsChatParticipant(ctx context.Context, params *PatchConversationsChatParticipantParams) (*PatchConversationsChatParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChatParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatParticipantAccepted), nil

}

/*
PatchConversationsChatParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsChatParticipantAttributes(ctx context.Context, params *PatchConversationsChatParticipantAttributesParams) (*PatchConversationsChatParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChatParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatParticipantAttributesAccepted), nil

}

/*
PatchConversationsChatParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsChatParticipantCommunication(ctx context.Context, params *PatchConversationsChatParticipantCommunicationParams) (*PatchConversationsChatParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsChatParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsChatParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsChatParticipantCommunicationOK), nil

}

/*
PatchConversationsCobrowsesession updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsCobrowsesession(ctx context.Context, params *PatchConversationsCobrowsesessionParams) (*PatchConversationsCobrowsesessionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesession",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionOK), nil

}

/*
PatchConversationsCobrowsesessionParticipant updates conversation participant
*/
func (a *Client) PatchConversationsCobrowsesessionParticipant(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantParams) (*PatchConversationsCobrowsesessionParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesessionParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionParticipantAccepted), nil

}

/*
PatchConversationsCobrowsesessionParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsCobrowsesessionParticipantAttributes(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantAttributesParams) (*PatchConversationsCobrowsesessionParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesessionParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionParticipantAttributesAccepted), nil

}

/*
PatchConversationsCobrowsesessionParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsCobrowsesessionParticipantCommunication(ctx context.Context, params *PatchConversationsCobrowsesessionParticipantCommunicationParams) (*PatchConversationsCobrowsesessionParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsCobrowsesessionParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsCobrowsesessionParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsCobrowsesessionParticipantCommunicationOK), nil

}

/*
PatchConversationsEmail updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsEmail(ctx context.Context, params *PatchConversationsEmailParams) (*PatchConversationsEmailOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmail",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailOK), nil

}

/*
PatchConversationsEmailParticipant updates conversation participant
*/
func (a *Client) PatchConversationsEmailParticipant(ctx context.Context, params *PatchConversationsEmailParticipantParams) (*PatchConversationsEmailParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmailParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailParticipantAccepted), nil

}

/*
PatchConversationsEmailParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsEmailParticipantAttributes(ctx context.Context, params *PatchConversationsEmailParticipantAttributesParams) (*PatchConversationsEmailParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmailParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailParticipantAttributesAccepted), nil

}

/*
PatchConversationsEmailParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsEmailParticipantCommunication(ctx context.Context, params *PatchConversationsEmailParticipantCommunicationParams) (*PatchConversationsEmailParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsEmailParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsEmailParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsEmailParticipantCommunicationOK), nil

}

/*
PatchConversationsMessage updates a conversation by disconnecting all of the participants
*/
func (a *Client) PatchConversationsMessage(ctx context.Context, params *PatchConversationsMessageParams) (*PatchConversationsMessageOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessage",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageOK), nil

}

/*
PatchConversationsMessageParticipant updates conversation participant
*/
func (a *Client) PatchConversationsMessageParticipant(ctx context.Context, params *PatchConversationsMessageParticipantParams) (*PatchConversationsMessageParticipantAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessageParticipant",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageParticipantReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageParticipantAccepted), nil

}

/*
PatchConversationsMessageParticipantAttributes updates the attributes on a conversation participant
*/
func (a *Client) PatchConversationsMessageParticipantAttributes(ctx context.Context, params *PatchConversationsMessageParticipantAttributesParams) (*PatchConversationsMessageParticipantAttributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessageParticipantAttributes",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/attributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageParticipantAttributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageParticipantAttributesAccepted), nil

}

/*
PatchConversationsMessageParticipantCommunication updates conversation participant s communication by disconnecting it
*/
func (a *Client) PatchConversationsMessageParticipantCommunication(ctx context.Context, params *PatchConversationsMessageParticipantCommunicationParams) (*PatchConversationsMessageParticipantCommunicationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessageParticipantCommunication",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/communications/{communicationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessageParticipantCommunicationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessageParticipantCommunicationOK), nil

}

/*
PatchConversationsMessagingIntegrationsFacebookIntegrationID updates facebook messaging integration
*/
func (a *Client) PatchConversationsMessagingIntegrationsFacebookIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsFacebookIntegrationIDParams) (*PatchConversationsMessagingIntegrationsFacebookIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsFacebookIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsFacebookIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessagingIntegrationsFacebookIntegrationIDOK), nil

}

/*
PatchConversationsMessagingIntegrationsOpenIntegrationID updates an open messaging integration

See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
*/
func (a *Client) PatchConversationsMessagingIntegrationsOpenIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsOpenIntegrationIDParams) (*PatchConversationsMessagingIntegrationsOpenIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsOpenIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/open/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsOpenIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessagingIntegrationsOpenIntegrationIDOK), nil

}

/*
PatchConversationsMessagingIntegrationsTwitterIntegrationID updates twitter messaging integration
*/
func (a *Client) PatchConversationsMessagingIntegrationsTwitterIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsTwitterIntegrationIDParams) (*PatchConversationsMessagingIntegrationsTwitterIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsTwitterIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsTwitterIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessagingIntegrationsTwitterIntegrationIDOK), nil

}

/*
PatchConversationsMessagingIntegrationsWhatsappIntegrationID updates or activate a whats app messaging integration

The following steps are required in order to fully activate a WhatsApp Integration: Initially, you will need to get an activation code by sending: an action set to Activate, and an authenticationMethod choosing from Sms or Voice. Finally, once you have been informed of an activation code on selected authenticationMethod, you will need to confirm the code by sending: an action set to Confirm, and the confirmationCode you have received from Whatsapp.
*/
func (a *Client) PatchConversationsMessagingIntegrationsWhatsappIntegrationID(ctx context.Context, params *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDParams) (*PatchConversationsMessagingIntegrationsWhatsappIntegrationIDOK, *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingIntegrationsWhatsappIntegrationId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingIntegrationsWhatsappIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDOK:
		return value, nil, nil
	case *PatchConversationsMessagingIntegrationsWhatsappIntegrationIDAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PatchConversationsMessagingSupportedcontentSupportedContentID updates a supported content profile
*/
func (a *Client) PatchConversationsMessagingSupportedcontentSupportedContentID(ctx context.Context, params *PatchConversationsMessagingSupportedcontentSupportedContentIDParams) (*PatchConversationsMessagingSupportedcontentSupportedContentIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchConversationsMessagingSupportedcontentSupportedContentId",
		Method:             "PATCH",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent/{supportedContentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchConversationsMessagingSupportedcontentSupportedContentIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchConversationsMessagingSupportedcontentSupportedContentIDOK), nil

}

/*
PostConversationAssign attempts to manually assign a specified conversation to a specified user ignores bullseye ring p a r score skills and languages
*/
func (a *Client) PostConversationAssign(ctx context.Context, params *PostConversationAssignParams) (*PostConversationAssignAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationAssign",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/assign",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationAssignReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationAssignAccepted), nil

}

/*
PostConversationDisconnect performs a full conversation teardown issues disconnect requests for any connected media applies a system wrap up code to any participants that are pending wrap up this is not intended to be the normal way of ending interactions but is available in the event of problems with the application to allow a resynchronization of state across all components it is recommended that users submit a support case if they are relying on this endpoint systematically as there is likely something that needs investigation
*/
func (a *Client) PostConversationDisconnect(ctx context.Context, params *PostConversationDisconnectParams) (*PostConversationDisconnectAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationDisconnect",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/disconnect",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationDisconnectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationDisconnectAccepted), nil

}

/*
PostConversationParticipantCallbacks creates a new callback for the specified participant on the conversation
*/
func (a *Client) PostConversationParticipantCallbacks(ctx context.Context, params *PostConversationParticipantCallbacksParams) (*PostConversationParticipantCallbacksCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantCallbacks",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantCallbacksCreated), nil

}

/*
PostConversationParticipantDigits sends d t m f to the participant
*/
func (a *Client) PostConversationParticipantDigits(ctx context.Context, params *PostConversationParticipantDigitsParams) (*PostConversationParticipantDigitsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantDigits",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/digits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantDigitsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantDigitsAccepted), nil

}

/*
PostConversationParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationParticipantReplace(ctx context.Context, params *PostConversationParticipantReplaceParams) (*PostConversationParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantReplaceAccepted), nil

}

/*
PostConversationParticipantSecureivrsessions creates secure i v r session only a participant in the conversation can invoke a secure i v r
*/
func (a *Client) PostConversationParticipantSecureivrsessions(ctx context.Context, params *PostConversationParticipantSecureivrsessionsParams) (*PostConversationParticipantSecureivrsessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationParticipantSecureivrsessions",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/secureivrsessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationParticipantSecureivrsessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationParticipantSecureivrsessionsOK), nil

}

/*
PostConversationsCall places a new call as part of a callback conversation
*/
func (a *Client) PostConversationsCall(ctx context.Context, params *PostConversationsCallParams) (*PostConversationsCallOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCall",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallOK), nil

}

/*
PostConversationsCallParticipantCoach listens in on the conversation from the point of view of a given participant while speaking to just the given participant
*/
func (a *Client) PostConversationsCallParticipantCoach(ctx context.Context, params *PostConversationsCallParticipantCoachParams) (*PostConversationsCallParticipantCoachCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantCoach",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/coach",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantCoachReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantCoachCreated), nil

}

/*
PostConversationsCallParticipantConsult initiates and update consult transfer
*/
func (a *Client) PostConversationsCallParticipantConsult(ctx context.Context, params *PostConversationsCallParticipantConsultParams) (*PostConversationsCallParticipantConsultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantConsult",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/consult",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantConsultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantConsultOK), nil

}

/*
PostConversationsCallParticipantMonitor listens in on the conversation from the point of view of a given participant
*/
func (a *Client) PostConversationsCallParticipantMonitor(ctx context.Context, params *PostConversationsCallParticipantMonitorParams) (*PostConversationsCallParticipantMonitorCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantMonitor",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/monitor",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantMonitorReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantMonitorCreated), nil

}

/*
PostConversationsCallParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsCallParticipantReplace(ctx context.Context, params *PostConversationsCallParticipantReplaceParams) (*PostConversationsCallParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantReplaceAccepted), nil

}

/*
PostConversationsCallParticipants adds participants to a conversation
*/
func (a *Client) PostConversationsCallParticipants(ctx context.Context, params *PostConversationsCallParticipantsParams) (*PostConversationsCallParticipantsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallParticipants",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallParticipantsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallParticipantsOK), nil

}

/*
PostConversationsCallbackParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsCallbackParticipantReplace(ctx context.Context, params *PostConversationsCallbackParticipantReplaceParams) (*PostConversationsCallbackParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallbackParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallbackParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallbackParticipantReplaceAccepted), nil

}

/*
PostConversationsCallbacks creates a callback
*/
func (a *Client) PostConversationsCallbacks(ctx context.Context, params *PostConversationsCallbacksParams) (*PostConversationsCallbacksOK, *PostConversationsCallbacksAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallbacks",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/callbacks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallbacksReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsCallbacksOK:
		return value, nil, nil
	case *PostConversationsCallbacksAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsCallbacksBulkDisconnect disconnects multiple scheduled callbacks
*/
func (a *Client) PostConversationsCallbacksBulkDisconnect(ctx context.Context, params *PostConversationsCallbacksBulkDisconnectParams) (*PostConversationsCallbacksBulkDisconnectAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallbacksBulkDisconnect",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/callbacks/bulk/disconnect",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallbacksBulkDisconnectReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallbacksBulkDisconnectAccepted), nil

}

/*
PostConversationsCallbacksBulkUpdate updates multiple scheduled callbacks
*/
func (a *Client) PostConversationsCallbacksBulkUpdate(ctx context.Context, params *PostConversationsCallbacksBulkUpdateParams) (*PostConversationsCallbacksBulkUpdateOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCallbacksBulkUpdate",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/callbacks/bulk/update",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallbacksBulkUpdateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallbacksBulkUpdateOK), nil

}

/*
PostConversationsCalls creates a call conversation
*/
func (a *Client) PostConversationsCalls(ctx context.Context, params *PostConversationsCallsParams) (*PostConversationsCallsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCalls",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/calls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCallsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCallsOK), nil

}

/*
PostConversationsChatCommunicationMessages sends a message on behalf of a communication in a chat conversation
*/
func (a *Client) PostConversationsChatCommunicationMessages(ctx context.Context, params *PostConversationsChatCommunicationMessagesParams) (*PostConversationsChatCommunicationMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChatCommunicationMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatCommunicationMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatCommunicationMessagesOK), nil

}

/*
PostConversationsChatCommunicationTyping sends a typing indicator on behalf of a communication in a chat conversation
*/
func (a *Client) PostConversationsChatCommunicationTyping(ctx context.Context, params *PostConversationsChatCommunicationTypingParams) (*PostConversationsChatCommunicationTypingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChatCommunicationTyping",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/communications/{communicationId}/typing",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatCommunicationTypingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatCommunicationTypingOK), nil

}

/*
PostConversationsChatParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsChatParticipantReplace(ctx context.Context, params *PostConversationsChatParticipantReplaceParams) (*PostConversationsChatParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChatParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatParticipantReplaceAccepted), nil

}

/*
PostConversationsChats creates a web chat conversation
*/
func (a *Client) PostConversationsChats(ctx context.Context, params *PostConversationsChatsParams) (*PostConversationsChatsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsChats",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/chats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsChatsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsChatsOK), nil

}

/*
PostConversationsCobrowsesessionParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsCobrowsesessionParticipantReplace(ctx context.Context, params *PostConversationsCobrowsesessionParticipantReplaceParams) (*PostConversationsCobrowsesessionParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsCobrowsesessionParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsCobrowsesessionParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsCobrowsesessionParticipantReplaceAccepted), nil

}

/*
PostConversationsEmailInboundmessages sends an email to an external conversation an external conversation is one where the provider is not pure cloud based this endpoint allows the sender of the external email to reply or send a new message to the existing conversation the new message will be treated as part of the existing conversation and chained to it
*/
func (a *Client) PostConversationsEmailInboundmessages(ctx context.Context, params *PostConversationsEmailInboundmessagesParams) (*PostConversationsEmailInboundmessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailInboundmessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/inboundmessages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailInboundmessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailInboundmessagesOK), nil

}

/*
PostConversationsEmailMessages sends an email reply
*/
func (a *Client) PostConversationsEmailMessages(ctx context.Context, params *PostConversationsEmailMessagesParams) (*PostConversationsEmailMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailMessagesOK), nil

}

/*
PostConversationsEmailMessagesDraftAttachmentsCopy copies attachments from an email message to the current draft
*/
func (a *Client) PostConversationsEmailMessagesDraftAttachmentsCopy(ctx context.Context, params *PostConversationsEmailMessagesDraftAttachmentsCopyParams) (*PostConversationsEmailMessagesDraftAttachmentsCopyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailMessagesDraftAttachmentsCopy",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft/attachments/copy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailMessagesDraftAttachmentsCopyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailMessagesDraftAttachmentsCopyOK), nil

}

/*
PostConversationsEmailParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsEmailParticipantReplace(ctx context.Context, params *PostConversationsEmailParticipantReplaceParams) (*PostConversationsEmailParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailParticipantReplaceAccepted), nil

}

/*
PostConversationsEmails creates an email conversation

If the direction of the request is INBOUND, this will create an external conversation with a third party provider. If the direction of the the request is OUTBOUND, this will create a conversation to send outbound emails on behalf of a queue.
*/
func (a *Client) PostConversationsEmails(ctx context.Context, params *PostConversationsEmailsParams) (*PostConversationsEmailsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmails",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailsOK), nil

}

/*
PostConversationsEmailsAgentless creates an email conversation per API
*/
func (a *Client) PostConversationsEmailsAgentless(ctx context.Context, params *PostConversationsEmailsAgentlessParams) (*PostConversationsEmailsAgentlessOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsEmailsAgentless",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/emails/agentless",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsEmailsAgentlessReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsEmailsAgentlessOK), nil

}

/*
PostConversationsFaxes creates fax conversation
*/
func (a *Client) PostConversationsFaxes(ctx context.Context, params *PostConversationsFaxesParams) (*PostConversationsFaxesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsFaxes",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/faxes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsFaxesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsFaxesOK), nil

}

/*
PostConversationsKeyconfigurations setups configurations for encryption key creation
*/
func (a *Client) PostConversationsKeyconfigurations(ctx context.Context, params *PostConversationsKeyconfigurationsParams) (*PostConversationsKeyconfigurationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsKeyconfigurations",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/keyconfigurations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsKeyconfigurationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsKeyconfigurationsOK), nil

}

/*
PostConversationsKeyconfigurationsValidate validates encryption key configurations without saving it
*/
func (a *Client) PostConversationsKeyconfigurationsValidate(ctx context.Context, params *PostConversationsKeyconfigurationsValidateParams) (*PostConversationsKeyconfigurationsValidateOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsKeyconfigurationsValidate",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/keyconfigurations/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsKeyconfigurationsValidateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsKeyconfigurationsValidateOK), nil

}

/*
PostConversationsMessageCommunicationMessages sends message

Send message on existing conversation/communication. Only one message body field can be accepted, per request. Example: 1 textBody, 1 mediaId, 1 stickerId, or 1 messageTemplate.
*/
func (a *Client) PostConversationsMessageCommunicationMessages(ctx context.Context, params *PostConversationsMessageCommunicationMessagesParams) (*PostConversationsMessageCommunicationMessagesOK, *PostConversationsMessageCommunicationMessagesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageCommunicationMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageCommunicationMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessageCommunicationMessagesOK:
		return value, nil, nil
	case *PostConversationsMessageCommunicationMessagesAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessageCommunicationMessagesMedia creates media

See https://developer.genesys.cloud/api/rest/v2/conversations/messaging-media-upload for example usage.
*/
func (a *Client) PostConversationsMessageCommunicationMessagesMedia(ctx context.Context, params *PostConversationsMessageCommunicationMessagesMediaParams) (*PostConversationsMessageCommunicationMessagesMediaAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageCommunicationMessagesMedia",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/communications/{communicationId}/messages/media",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageCommunicationMessagesMediaReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessageCommunicationMessagesMediaAccepted), nil

}

/*
PostConversationsMessageMessagesBulk gets messages in batch

The path parameter [conversationId] should contain the conversationId of the conversation being filtered. The body should contain the messageId(s) of messages being requested. For example: ["a3069a33b-bbb1-4703-9d68-061d9e9db96e", "55bc6be3-078c-4a49-a4e6-1e05776ed7e8"]
*/
func (a *Client) PostConversationsMessageMessagesBulk(ctx context.Context, params *PostConversationsMessageMessagesBulkParams) (*PostConversationsMessageMessagesBulkOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageMessagesBulk",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/messages/bulk",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageMessagesBulkReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessageMessagesBulkOK), nil

}

/*
PostConversationsMessageParticipantReplace replaces this participant with the specified user and or address
*/
func (a *Client) PostConversationsMessageParticipantReplace(ctx context.Context, params *PostConversationsMessageParticipantReplaceParams) (*PostConversationsMessageParticipantReplaceAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessageParticipantReplace",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/participants/{participantId}/replace",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessageParticipantReplaceReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessageParticipantReplaceAccepted), nil

}

/*
PostConversationsMessages creates an outbound messaging conversation

If there is an existing conversation between the remote address and the address associated with the queue specified in createOutboundRequest then the result of this request depends on the state of that conversation and the useExistingConversation field of createOutboundRequest. If the existing conversation is in alerting or connected state, then the request will fail. If the existing conversation is disconnected but still within the conversation window then the request will fail unless useExistingConversation is set to true.
*/
func (a *Client) PostConversationsMessages(ctx context.Context, params *PostConversationsMessagesParams) (*PostConversationsMessagesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessages",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationsMessagesOK), nil

}

/*
PostConversationsMessagesAgentless sends an agentless outbound message

Send an agentless (api participant) outbound message using a client credential grant. In order to call this endpoint you will need OAuth token generated using OAuth client credentials authorized with at least messaging scope. This will generate a new Conversation, if there is an existing active Conversation between the fromAddress and toAddress already, then this POST will fail.
*/
func (a *Client) PostConversationsMessagesAgentless(ctx context.Context, params *PostConversationsMessagesAgentlessParams) (*PostConversationsMessagesAgentlessOK, *PostConversationsMessagesAgentlessAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagesAgentless",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/agentless",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagesAgentlessReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagesAgentlessOK:
		return value, nil, nil
	case *PostConversationsMessagesAgentlessAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagesInboundOpen sends an inbound open message

Send an inbound message to an Open Messaging integration. In order to call this endpoint you will need OAuth token generated using OAuth client credentials authorized with at least messaging scope. This will either generate a new Conversation, or be a part of an existing conversation. See https://developer.genesys.cloud/api/digital/openmessaging/ for example usage.
*/
func (a *Client) PostConversationsMessagesInboundOpen(ctx context.Context, params *PostConversationsMessagesInboundOpenParams) (*PostConversationsMessagesInboundOpenOK, *PostConversationsMessagesInboundOpenAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagesInboundOpen",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messages/inbound/open",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagesInboundOpenReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagesInboundOpenOK:
		return value, nil, nil
	case *PostConversationsMessagesInboundOpenAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsFacebook creates a facebook integration
*/
func (a *Client) PostConversationsMessagingIntegrationsFacebook(ctx context.Context, params *PostConversationsMessagingIntegrationsFacebookParams) (*PostConversationsMessagingIntegrationsFacebookOK, *PostConversationsMessagingIntegrationsFacebookAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsFacebook",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/facebook",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsFacebookReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsFacebookOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsFacebookAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsLine creates a l i n e messenger integration
*/
func (a *Client) PostConversationsMessagingIntegrationsLine(ctx context.Context, params *PostConversationsMessagingIntegrationsLineParams) (*PostConversationsMessagingIntegrationsLineOK, *PostConversationsMessagingIntegrationsLineAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsLine",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsLineReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsLineOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsLineAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsOpen creates an open messaging integration

See https://developer.genesys.cloud/api/digital/openmessaging/ for more information.
*/
func (a *Client) PostConversationsMessagingIntegrationsOpen(ctx context.Context, params *PostConversationsMessagingIntegrationsOpenParams) (*PostConversationsMessagingIntegrationsOpenOK, *PostConversationsMessagingIntegrationsOpenAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsOpen",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/open",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsOpenReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsOpenOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsOpenAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsTwitter creates a twitter integration
*/
func (a *Client) PostConversationsMessagingIntegrationsTwitter(ctx context.Context, params *PostConversationsMessagingIntegrationsTwitterParams) (*PostConversationsMessagingIntegrationsTwitterOK, *PostConversationsMessagingIntegrationsTwitterAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsTwitter",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/twitter",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsTwitterReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsTwitterOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsTwitterAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingIntegrationsWhatsapp creates a whats app integration

You must be approved by WhatsApp to use this feature. Your approved e164-formatted phone number and valid WhatsApp certificate for your number are required. Your WhatsApp certificate must have valid base64 encoding. Please paste carefully and do not add any leading or trailing spaces. Do not alter any characters. An integration must be activated within 7 days of certificate generation. If you cannot complete the addition and activation of the number within 7 days, please obtain a new certificate before creating the integration. Integrations created with an invalid number or certificate may immediately incur additional integration fees. Please carefully enter your number and certificate as described.
*/
func (a *Client) PostConversationsMessagingIntegrationsWhatsapp(ctx context.Context, params *PostConversationsMessagingIntegrationsWhatsappParams) (*PostConversationsMessagingIntegrationsWhatsappOK, *PostConversationsMessagingIntegrationsWhatsappAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingIntegrationsWhatsapp",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/integrations/whatsapp",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingIntegrationsWhatsappReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingIntegrationsWhatsappOK:
		return value, nil, nil
	case *PostConversationsMessagingIntegrationsWhatsappAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PostConversationsMessagingSupportedcontent creates a supported content profile
*/
func (a *Client) PostConversationsMessagingSupportedcontent(ctx context.Context, params *PostConversationsMessagingSupportedcontentParams) (*PostConversationsMessagingSupportedcontentOK, *PostConversationsMessagingSupportedcontentCreated, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationsMessagingSupportedcontent",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationsMessagingSupportedcontentReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostConversationsMessagingSupportedcontentOK:
		return value, nil, nil
	case *PostConversationsMessagingSupportedcontentCreated:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationParticipantFlaggedreason sets flagged reason on conversation participant to indicate bad conversation quality
*/
func (a *Client) PutConversationParticipantFlaggedreason(ctx context.Context, params *PutConversationParticipantFlaggedreasonParams) (*PutConversationParticipantFlaggedreasonNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationParticipantFlaggedreason",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/{conversationId}/participants/{participantId}/flaggedreason",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationParticipantFlaggedreasonReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationParticipantFlaggedreasonNoContent), nil

}

/*
PutConversationSecureattributes sets the secure attributes on a conversation
*/
func (a *Client) PutConversationSecureattributes(ctx context.Context, params *PutConversationSecureattributesParams) (*PutConversationSecureattributesAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationSecureattributes",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/{conversationId}/secureattributes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationSecureattributesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationSecureattributesAccepted), nil

}

/*
PutConversationTags updates the tags on a conversation
*/
func (a *Client) PutConversationTags(ctx context.Context, params *PutConversationTagsParams) (*PutConversationTagsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationTags",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/{conversationId}/tags",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationTagsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationTagsAccepted), nil

}

/*
PutConversationsCallParticipantCommunicationUuidata sets uui data to be sent on future commands
*/
func (a *Client) PutConversationsCallParticipantCommunicationUuidata(ctx context.Context, params *PutConversationsCallParticipantCommunicationUuidataParams) (*PutConversationsCallParticipantCommunicationUuidataOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsCallParticipantCommunicationUuidata",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/participants/{participantId}/communications/{communicationId}/uuidata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsCallParticipantCommunicationUuidataReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsCallParticipantCommunicationUuidataOK), nil

}

/*
PutConversationsCallRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsCallRecordingstate(ctx context.Context, params *PutConversationsCallRecordingstateParams) (*PutConversationsCallRecordingstateOK, *PutConversationsCallRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsCallRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/calls/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsCallRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsCallRecordingstateOK:
		return value, nil, nil
	case *PutConversationsCallRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsCallbackRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsCallbackRecordingstate(ctx context.Context, params *PutConversationsCallbackRecordingstateParams) (*PutConversationsCallbackRecordingstateOK, *PutConversationsCallbackRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsCallbackRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/callbacks/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsCallbackRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsCallbackRecordingstateOK:
		return value, nil, nil
	case *PutConversationsCallbackRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsChatRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsChatRecordingstate(ctx context.Context, params *PutConversationsChatRecordingstateParams) (*PutConversationsChatRecordingstateOK, *PutConversationsChatRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsChatRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/chats/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsChatRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsChatRecordingstateOK:
		return value, nil, nil
	case *PutConversationsChatRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsCobrowsesessionRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsCobrowsesessionRecordingstate(ctx context.Context, params *PutConversationsCobrowsesessionRecordingstateParams) (*PutConversationsCobrowsesessionRecordingstateOK, *PutConversationsCobrowsesessionRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsCobrowsesessionRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/cobrowsesessions/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsCobrowsesessionRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsCobrowsesessionRecordingstateOK:
		return value, nil, nil
	case *PutConversationsCobrowsesessionRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsEmailMessagesDraft updates conversation draft reply
*/
func (a *Client) PutConversationsEmailMessagesDraft(ctx context.Context, params *PutConversationsEmailMessagesDraftParams) (*PutConversationsEmailMessagesDraftOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsEmailMessagesDraft",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/messages/draft",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsEmailMessagesDraftReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsEmailMessagesDraftOK), nil

}

/*
PutConversationsEmailRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsEmailRecordingstate(ctx context.Context, params *PutConversationsEmailRecordingstateParams) (*PutConversationsEmailRecordingstateOK, *PutConversationsEmailRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsEmailRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/emails/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsEmailRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsEmailRecordingstateOK:
		return value, nil, nil
	case *PutConversationsEmailRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsKeyconfiguration updates the encryption key configurations
*/
func (a *Client) PutConversationsKeyconfiguration(ctx context.Context, params *PutConversationsKeyconfigurationParams) (*PutConversationsKeyconfigurationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsKeyconfiguration",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/keyconfigurations/{keyconfigurationsId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsKeyconfigurationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsKeyconfigurationOK), nil

}

/*
PutConversationsMessageRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsMessageRecordingstate(ctx context.Context, params *PutConversationsMessageRecordingstateParams) (*PutConversationsMessageRecordingstateOK, *PutConversationsMessageRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsMessageRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/messages/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsMessageRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsMessageRecordingstateOK:
		return value, nil, nil
	case *PutConversationsMessageRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsMessagingIntegrationsLineIntegrationID updates a l i n e messenger integration
*/
func (a *Client) PutConversationsMessagingIntegrationsLineIntegrationID(ctx context.Context, params *PutConversationsMessagingIntegrationsLineIntegrationIDParams) (*PutConversationsMessagingIntegrationsLineIntegrationIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsMessagingIntegrationsLineIntegrationId",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/messaging/integrations/line/{integrationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsMessagingIntegrationsLineIntegrationIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsMessagingIntegrationsLineIntegrationIDOK), nil

}

/*
PutConversationsMessagingSupportedcontentDefault sets the organization s default supported content profile that may be assigned to an integration when it is created

When an integration is created a supported content ID may be assigned to it. If the supported content ID is not supplied, the default supported content profile will be assigned to it.
*/
func (a *Client) PutConversationsMessagingSupportedcontentDefault(ctx context.Context, params *PutConversationsMessagingSupportedcontentDefaultParams) (*PutConversationsMessagingSupportedcontentDefaultOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsMessagingSupportedcontentDefault",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/messaging/supportedcontent/default",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsMessagingSupportedcontentDefaultReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsMessagingSupportedcontentDefaultOK), nil

}

/*
PutConversationsMessagingThreadingtimeline updates conversation threading window timeline for each messaging type

PUT Conversation messaging threading timeline is intended to set the conversation threading settings for ALL messengerTypes. If you omit a messengerType in the request body then the setting for that messengerType will use the platform default value. The PUT replaces the existing setting(s) that were previously set for each messengerType.
*/
func (a *Client) PutConversationsMessagingThreadingtimeline(ctx context.Context, params *PutConversationsMessagingThreadingtimelineParams) (*PutConversationsMessagingThreadingtimelineOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsMessagingThreadingtimeline",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/messaging/threadingtimeline",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsMessagingThreadingtimelineReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationsMessagingThreadingtimelineOK), nil

}

/*
PutConversationsScreenshareRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsScreenshareRecordingstate(ctx context.Context, params *PutConversationsScreenshareRecordingstateParams) (*PutConversationsScreenshareRecordingstateOK, *PutConversationsScreenshareRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsScreenshareRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/screenshares/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsScreenshareRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsScreenshareRecordingstateOK:
		return value, nil, nil
	case *PutConversationsScreenshareRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsSocialRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsSocialRecordingstate(ctx context.Context, params *PutConversationsSocialRecordingstateParams) (*PutConversationsSocialRecordingstateOK, *PutConversationsSocialRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsSocialRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/socials/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsSocialRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsSocialRecordingstateOK:
		return value, nil, nil
	case *PutConversationsSocialRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
PutConversationsVideoRecordingstate updates a conversation by setting its recording state
*/
func (a *Client) PutConversationsVideoRecordingstate(ctx context.Context, params *PutConversationsVideoRecordingstateParams) (*PutConversationsVideoRecordingstateOK, *PutConversationsVideoRecordingstateAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationsVideoRecordingstate",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/videos/{conversationId}/recordingstate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationsVideoRecordingstateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PutConversationsVideoRecordingstateOK:
		return value, nil, nil
	case *PutConversationsVideoRecordingstateAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}
