// Code generated by go-swagger; DO NOT EDIT.

package architect

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/freman/genesysapi/models"
)

// DeleteFlowsReader is a Reader for the DeleteFlows structure.
type DeleteFlowsReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *DeleteFlowsReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewDeleteFlowsOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewDeleteFlowsBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewDeleteFlowsUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewDeleteFlowsForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewDeleteFlowsNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 409:
		result := NewDeleteFlowsConflict()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 413:
		result := NewDeleteFlowsRequestEntityTooLarge()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 415:
		result := NewDeleteFlowsUnsupportedMediaType()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewDeleteFlowsTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewDeleteFlowsInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 503:
		result := NewDeleteFlowsServiceUnavailable()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 504:
		result := NewDeleteFlowsGatewayTimeout()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewDeleteFlowsOK creates a DeleteFlowsOK with default headers values
func NewDeleteFlowsOK() *DeleteFlowsOK {
	return &DeleteFlowsOK{}
}

/*DeleteFlowsOK handles this case with default header values.

successful operation
*/
type DeleteFlowsOK struct {
	Payload *models.Operation
}

func (o *DeleteFlowsOK) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsOK  %+v", 200, o.Payload)
}

func (o *DeleteFlowsOK) GetPayload() *models.Operation {
	return o.Payload
}

func (o *DeleteFlowsOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.Operation)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsBadRequest creates a DeleteFlowsBadRequest with default headers values
func NewDeleteFlowsBadRequest() *DeleteFlowsBadRequest {
	return &DeleteFlowsBadRequest{}
}

/*DeleteFlowsBadRequest handles this case with default header values.

The request could not be understood by the server due to malformed syntax.
*/
type DeleteFlowsBadRequest struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsBadRequest) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsBadRequest  %+v", 400, o.Payload)
}

func (o *DeleteFlowsBadRequest) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsUnauthorized creates a DeleteFlowsUnauthorized with default headers values
func NewDeleteFlowsUnauthorized() *DeleteFlowsUnauthorized {
	return &DeleteFlowsUnauthorized{}
}

/*DeleteFlowsUnauthorized handles this case with default header values.

No authentication bearer token specified in authorization header.
*/
type DeleteFlowsUnauthorized struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsUnauthorized) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsUnauthorized  %+v", 401, o.Payload)
}

func (o *DeleteFlowsUnauthorized) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsForbidden creates a DeleteFlowsForbidden with default headers values
func NewDeleteFlowsForbidden() *DeleteFlowsForbidden {
	return &DeleteFlowsForbidden{}
}

/*DeleteFlowsForbidden handles this case with default header values.

You are not authorized to perform the requested action.
*/
type DeleteFlowsForbidden struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsForbidden) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsForbidden  %+v", 403, o.Payload)
}

func (o *DeleteFlowsForbidden) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsNotFound creates a DeleteFlowsNotFound with default headers values
func NewDeleteFlowsNotFound() *DeleteFlowsNotFound {
	return &DeleteFlowsNotFound{}
}

/*DeleteFlowsNotFound handles this case with default header values.

The requested resource was not found.
*/
type DeleteFlowsNotFound struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsNotFound) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsNotFound  %+v", 404, o.Payload)
}

func (o *DeleteFlowsNotFound) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsConflict creates a DeleteFlowsConflict with default headers values
func NewDeleteFlowsConflict() *DeleteFlowsConflict {
	return &DeleteFlowsConflict{}
}

/*DeleteFlowsConflict handles this case with default header values.

Conflict
*/
type DeleteFlowsConflict struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsConflict) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsConflict  %+v", 409, o.Payload)
}

func (o *DeleteFlowsConflict) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsConflict) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsRequestEntityTooLarge creates a DeleteFlowsRequestEntityTooLarge with default headers values
func NewDeleteFlowsRequestEntityTooLarge() *DeleteFlowsRequestEntityTooLarge {
	return &DeleteFlowsRequestEntityTooLarge{}
}

/*DeleteFlowsRequestEntityTooLarge handles this case with default header values.

The request is over the size limit. Content-Length: %s
*/
type DeleteFlowsRequestEntityTooLarge struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsRequestEntityTooLarge) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsRequestEntityTooLarge  %+v", 413, o.Payload)
}

func (o *DeleteFlowsRequestEntityTooLarge) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsRequestEntityTooLarge) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsUnsupportedMediaType creates a DeleteFlowsUnsupportedMediaType with default headers values
func NewDeleteFlowsUnsupportedMediaType() *DeleteFlowsUnsupportedMediaType {
	return &DeleteFlowsUnsupportedMediaType{}
}

/*DeleteFlowsUnsupportedMediaType handles this case with default header values.

Unsupported Media Type - Unsupported or incorrect media type, such as an incorrect Content-Type value in the header.
*/
type DeleteFlowsUnsupportedMediaType struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsUnsupportedMediaType) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsUnsupportedMediaType  %+v", 415, o.Payload)
}

func (o *DeleteFlowsUnsupportedMediaType) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsUnsupportedMediaType) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsTooManyRequests creates a DeleteFlowsTooManyRequests with default headers values
func NewDeleteFlowsTooManyRequests() *DeleteFlowsTooManyRequests {
	return &DeleteFlowsTooManyRequests{}
}

/*DeleteFlowsTooManyRequests handles this case with default header values.

Rate limit exceeded the maximum [%s] requests within [%s] seconds
*/
type DeleteFlowsTooManyRequests struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsTooManyRequests) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsTooManyRequests  %+v", 429, o.Payload)
}

func (o *DeleteFlowsTooManyRequests) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsInternalServerError creates a DeleteFlowsInternalServerError with default headers values
func NewDeleteFlowsInternalServerError() *DeleteFlowsInternalServerError {
	return &DeleteFlowsInternalServerError{}
}

/*DeleteFlowsInternalServerError handles this case with default header values.

The server encountered an unexpected condition which prevented it from fulfilling the request.
*/
type DeleteFlowsInternalServerError struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsInternalServerError) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsInternalServerError  %+v", 500, o.Payload)
}

func (o *DeleteFlowsInternalServerError) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsServiceUnavailable creates a DeleteFlowsServiceUnavailable with default headers values
func NewDeleteFlowsServiceUnavailable() *DeleteFlowsServiceUnavailable {
	return &DeleteFlowsServiceUnavailable{}
}

/*DeleteFlowsServiceUnavailable handles this case with default header values.

Service Unavailable - The server is currently unavailable (because it is overloaded or down for maintenance).
*/
type DeleteFlowsServiceUnavailable struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsServiceUnavailable) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsServiceUnavailable  %+v", 503, o.Payload)
}

func (o *DeleteFlowsServiceUnavailable) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsServiceUnavailable) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewDeleteFlowsGatewayTimeout creates a DeleteFlowsGatewayTimeout with default headers values
func NewDeleteFlowsGatewayTimeout() *DeleteFlowsGatewayTimeout {
	return &DeleteFlowsGatewayTimeout{}
}

/*DeleteFlowsGatewayTimeout handles this case with default header values.

The request timed out.
*/
type DeleteFlowsGatewayTimeout struct {
	Payload *models.ErrorBody
}

func (o *DeleteFlowsGatewayTimeout) Error() string {
	return fmt.Sprintf("[DELETE /api/v2/flows][%d] deleteFlowsGatewayTimeout  %+v", 504, o.Payload)
}

func (o *DeleteFlowsGatewayTimeout) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *DeleteFlowsGatewayTimeout) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
