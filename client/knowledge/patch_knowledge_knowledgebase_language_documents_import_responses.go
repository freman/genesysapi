// Code generated by go-swagger; DO NOT EDIT.

package knowledge

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/freman/genesysapi/models"
)

// PatchKnowledgeKnowledgebaseLanguageDocumentsImportReader is a Reader for the PatchKnowledgeKnowledgebaseLanguageDocumentsImport structure.
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 202:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 408:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 413:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 415:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 503:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 504:
		result := NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportOK creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportOK() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK handles this case with default header values.

Import operation finished
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK struct {
	Payload *models.KnowledgeImport
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportOK  %+v", 200, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK) GetPayload() *models.KnowledgeImport {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.KnowledgeImport)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted handles this case with default header values.

Import operation started
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted struct {
	Payload *models.KnowledgeImport
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted  %+v", 202, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted) GetPayload() *models.KnowledgeImport {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportAccepted) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.KnowledgeImport)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest handles this case with default header values.

The request could not be understood by the server due to malformed syntax.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest  %+v", 400, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized handles this case with default header values.

No authentication bearer token specified in authorization header.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized  %+v", 401, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden handles this case with default header values.

You are not authorized to perform the requested action.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden  %+v", 403, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound handles this case with default header values.

The requested resource was not found.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound  %+v", 404, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout handles this case with default header values.

The client did not produce a request within the server timeout limit. This can be caused by a slow network connection and/or large payloads.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout  %+v", 408, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestTimeout) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge handles this case with default header values.

The request is over the size limit. Content-Length: %s
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge  %+v", 413, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportRequestEntityTooLarge) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType handles this case with default header values.

Unsupported Media Type - Unsupported or incorrect media type, such as an incorrect Content-Type value in the header.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType  %+v", 415, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportUnsupportedMediaType) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests handles this case with default header values.

Rate limit exceeded the maximum. Retry the request in [%s] seconds
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests  %+v", 429, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError handles this case with default header values.

The server encountered an unexpected condition which prevented it from fulfilling the request.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError  %+v", 500, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable handles this case with default header values.

Service Unavailable - The server is currently unavailable (because it is overloaded or down for maintenance).
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable  %+v", 503, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportServiceUnavailable) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout creates a PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout with default headers values
func NewPatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout() *PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout {
	return &PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout{}
}

/*PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout handles this case with default header values.

The request timed out.
*/
type PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout struct {
	Payload *models.ErrorBody
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout) Error() string {
	return fmt.Sprintf("[PATCH /api/v2/knowledge/knowledgebases/{knowledgeBaseId}/languages/{languageCode}/documents/imports/{importId}][%d] patchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout  %+v", 504, o.Payload)
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PatchKnowledgeKnowledgebaseLanguageDocumentsImportGatewayTimeout) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
