// Code generated by go-swagger; DO NOT EDIT.

package recording

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery -name API -inpkg

// API is the interface of the recording client
type API interface {
	/*
	   DeleteConversationRecordingAnnotation deletes annotation
	*/
	DeleteConversationRecordingAnnotation(ctx context.Context, params *DeleteConversationRecordingAnnotationParams) error
	/*
	   DeleteOrphanrecording deletes a single orphan recording
	*/
	DeleteOrphanrecording(ctx context.Context, params *DeleteOrphanrecordingParams) (*DeleteOrphanrecordingOK, error)
	/*
	   DeleteRecordingCrossplatformMediaretentionpolicies deletes media retention policies
	   Bulk delete of media retention policies, this will only delete the polices that match the ids specified in the query param.
	*/
	DeleteRecordingCrossplatformMediaretentionpolicies(ctx context.Context, params *DeleteRecordingCrossplatformMediaretentionpoliciesParams) (*DeleteRecordingCrossplatformMediaretentionpoliciesOK, error)
	/*
	   DeleteRecordingCrossplatformMediaretentionpolicy deletes a media retention policy
	*/
	DeleteRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *DeleteRecordingCrossplatformMediaretentionpolicyParams) (*DeleteRecordingCrossplatformMediaretentionpolicyOK, error)
	/*
	   DeleteRecordingJob deletes the recording bulk job
	*/
	DeleteRecordingJob(ctx context.Context, params *DeleteRecordingJobParams) (*DeleteRecordingJobNoContent, error)
	/*
	   DeleteRecordingMediaretentionpolicies deletes media retention policies
	   Bulk delete of media retention policies, this will only delete the polices that match the ids specified in the query param.
	*/
	DeleteRecordingMediaretentionpolicies(ctx context.Context, params *DeleteRecordingMediaretentionpoliciesParams) (*DeleteRecordingMediaretentionpoliciesOK, error)
	/*
	   DeleteRecordingMediaretentionpolicy deletes a media retention policy
	*/
	DeleteRecordingMediaretentionpolicy(ctx context.Context, params *DeleteRecordingMediaretentionpolicyParams) (*DeleteRecordingMediaretentionpolicyOK, error)
	/*
	   GetConversationRecording gets a specific recording
	*/
	GetConversationRecording(ctx context.Context, params *GetConversationRecordingParams) (*GetConversationRecordingAccepted, error)
	/*
	   GetConversationRecordingAnnotation gets annotation
	*/
	GetConversationRecordingAnnotation(ctx context.Context, params *GetConversationRecordingAnnotationParams) (*GetConversationRecordingAnnotationOK, error)
	/*
	   GetConversationRecordingAnnotations gets annotations for recording
	*/
	GetConversationRecordingAnnotations(ctx context.Context, params *GetConversationRecordingAnnotationsParams) (*GetConversationRecordingAnnotationsOK, error)
	/*
	   GetConversationRecordingmetadata gets recording metadata for a conversation does not return playable media annotations won t be included in the response if recording recording view permission is missing
	*/
	GetConversationRecordingmetadata(ctx context.Context, params *GetConversationRecordingmetadataParams) (*GetConversationRecordingmetadataOK, error)
	/*
	   GetConversationRecordingmetadataRecordingID gets metadata for a specific recording does not return playable media
	*/
	GetConversationRecordingmetadataRecordingID(ctx context.Context, params *GetConversationRecordingmetadataRecordingIDParams) (*GetConversationRecordingmetadataRecordingIDOK, error)
	/*
	   GetConversationRecordings gets all of a conversation s recordings
	*/
	GetConversationRecordings(ctx context.Context, params *GetConversationRecordingsParams) (*GetConversationRecordingsOK, *GetConversationRecordingsAccepted, error)
	/*
	   GetOrphanrecording gets a single orphan recording
	*/
	GetOrphanrecording(ctx context.Context, params *GetOrphanrecordingParams) (*GetOrphanrecordingOK, error)
	/*
	   GetOrphanrecordingMedia gets the media of a single orphan recording
	   A 202 response means the orphaned media is currently transcoding and will be available shortly.A 200 response denotes the transcoded orphan media is available now and is contained in the response body.
	*/
	GetOrphanrecordingMedia(ctx context.Context, params *GetOrphanrecordingMediaParams) (*GetOrphanrecordingMediaOK, *GetOrphanrecordingMediaAccepted, error)
	/*
	   GetOrphanrecordings gets all orphan recordings
	*/
	GetOrphanrecordings(ctx context.Context, params *GetOrphanrecordingsParams) (*GetOrphanrecordingsOK, error)
	/*
	   GetRecordingBatchrequest gets the status and results for a batch request job only the user that submitted the job may retrieve results
	*/
	GetRecordingBatchrequest(ctx context.Context, params *GetRecordingBatchrequestParams) (*GetRecordingBatchrequestOK, error)
	/*
	   GetRecordingCrossplatformMediaretentionpolicies gets media retention policy list with query options to filter on name and enabled
	   for a less verbose response, add summary=true to this endpoint
	*/
	GetRecordingCrossplatformMediaretentionpolicies(ctx context.Context, params *GetRecordingCrossplatformMediaretentionpoliciesParams) (*GetRecordingCrossplatformMediaretentionpoliciesOK, error)
	/*
	   GetRecordingCrossplatformMediaretentionpolicy gets a media retention policy
	*/
	GetRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *GetRecordingCrossplatformMediaretentionpolicyParams) (*GetRecordingCrossplatformMediaretentionpolicyOK, error)
	/*
	   GetRecordingJob gets the status of the job associated with the job id
	*/
	GetRecordingJob(ctx context.Context, params *GetRecordingJobParams) (*GetRecordingJobOK, error)
	/*
	   GetRecordingJobFailedrecordings gets i ds of recordings that the bulk job failed for
	*/
	GetRecordingJobFailedrecordings(ctx context.Context, params *GetRecordingJobFailedrecordingsParams) (*GetRecordingJobFailedrecordingsOK, error)
	/*
	   GetRecordingJobs gets the status of all jobs within the user s organization
	*/
	GetRecordingJobs(ctx context.Context, params *GetRecordingJobsParams) (*GetRecordingJobsOK, error)
	/*
	   GetRecordingKeyconfiguration gets the encryption key configurations
	*/
	GetRecordingKeyconfiguration(ctx context.Context, params *GetRecordingKeyconfigurationParams) (*GetRecordingKeyconfigurationOK, error)
	/*
	   GetRecordingKeyconfigurations gets a list of key configurations data
	*/
	GetRecordingKeyconfigurations(ctx context.Context, params *GetRecordingKeyconfigurationsParams) (*GetRecordingKeyconfigurationsOK, error)
	/*
	   GetRecordingLocalkeysSetting gets the local encryption settings replaced by API recording keyconfigurations key configuration Id
	*/
	GetRecordingLocalkeysSetting(ctx context.Context, params *GetRecordingLocalkeysSettingParams) (*GetRecordingLocalkeysSettingOK, error)
	/*
	   GetRecordingLocalkeysSettings gets a list local key settings data replaced by API recording keyconfigurations
	*/
	GetRecordingLocalkeysSettings(ctx context.Context, params *GetRecordingLocalkeysSettingsParams) (*GetRecordingLocalkeysSettingsOK, error)
	/*
	   GetRecordingMediaretentionpolicies gets media retention policy list with query options to filter on name and enabled
	   for a less verbose response, add summary=true to this endpoint
	*/
	GetRecordingMediaretentionpolicies(ctx context.Context, params *GetRecordingMediaretentionpoliciesParams) (*GetRecordingMediaretentionpoliciesOK, error)
	/*
	   GetRecordingMediaretentionpolicy gets a media retention policy
	*/
	GetRecordingMediaretentionpolicy(ctx context.Context, params *GetRecordingMediaretentionpolicyParams) (*GetRecordingMediaretentionpolicyOK, error)
	/*
	   GetRecordingRecordingkeys gets encryption key list
	*/
	GetRecordingRecordingkeys(ctx context.Context, params *GetRecordingRecordingkeysParams) (*GetRecordingRecordingkeysOK, error)
	/*
	   GetRecordingRecordingkeysRotationschedule gets key rotation schedule
	*/
	GetRecordingRecordingkeysRotationschedule(ctx context.Context, params *GetRecordingRecordingkeysRotationscheduleParams) (*GetRecordingRecordingkeysRotationscheduleOK, error)
	/*
	   GetRecordingSettings gets the recording settings for the organization
	*/
	GetRecordingSettings(ctx context.Context, params *GetRecordingSettingsParams) (*GetRecordingSettingsOK, error)
	/*
	   GetRecordingUploadsReport gets the status of a recording upload status report
	*/
	GetRecordingUploadsReport(ctx context.Context, params *GetRecordingUploadsReportParams) (*GetRecordingUploadsReportOK, error)
	/*
	   GetRecordingsRetentionQuery queries for recording retention data
	*/
	GetRecordingsRetentionQuery(ctx context.Context, params *GetRecordingsRetentionQueryParams) (*GetRecordingsRetentionQueryOK, error)
	/*
	   GetRecordingsScreensessions retrieves a paged listing of screen recording sessions
	*/
	GetRecordingsScreensessions(ctx context.Context, params *GetRecordingsScreensessionsParams) (*GetRecordingsScreensessionsOK, error)
	/*
	   PatchRecordingCrossplatformMediaretentionpolicy patches a media retention policy
	*/
	PatchRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *PatchRecordingCrossplatformMediaretentionpolicyParams) (*PatchRecordingCrossplatformMediaretentionpolicyOK, error)
	/*
	   PatchRecordingMediaretentionpolicy patches a media retention policy
	*/
	PatchRecordingMediaretentionpolicy(ctx context.Context, params *PatchRecordingMediaretentionpolicyParams) (*PatchRecordingMediaretentionpolicyOK, error)
	/*
	   PatchRecordingsScreensession updates a screen recording session
	*/
	PatchRecordingsScreensession(ctx context.Context, params *PatchRecordingsScreensessionParams) error
	/*
	   PostConversationRecordingAnnotations creates annotation
	*/
	PostConversationRecordingAnnotations(ctx context.Context, params *PostConversationRecordingAnnotationsParams) (*PostConversationRecordingAnnotationsOK, error)
	/*
	   PostRecordingBatchrequests submits a batch download request for recordings recordings in response will be in their original format codec configured in the trunk configuration
	*/
	PostRecordingBatchrequests(ctx context.Context, params *PostRecordingBatchrequestsParams) (*PostRecordingBatchrequestsOK, error)
	/*
	   PostRecordingCrossplatformMediaretentionpolicies creates media retention policy
	   Policy does not work retroactively
	*/
	PostRecordingCrossplatformMediaretentionpolicies(ctx context.Context, params *PostRecordingCrossplatformMediaretentionpoliciesParams) (*PostRecordingCrossplatformMediaretentionpoliciesOK, error)
	/*
	   PostRecordingJobs creates a recording bulk job
	   Each organization can run up to a maximum of two concurrent jobs that are either in pending or processing state. Furthermore, the recording:recording:viewSensitiveData permission is required to access recordings with PCI DSS and/or PII data. If the requester does not have that permission and includeRecordingsWithSensitiveData is set to true, then their request will be rejected.
	*/
	PostRecordingJobs(ctx context.Context, params *PostRecordingJobsParams) (*PostRecordingJobsAccepted, error)
	/*
	   PostRecordingKeyconfigurations setups configurations for encryption key creation
	*/
	PostRecordingKeyconfigurations(ctx context.Context, params *PostRecordingKeyconfigurationsParams) (*PostRecordingKeyconfigurationsOK, error)
	/*
	   PostRecordingKeyconfigurationsValidate validates encryption key configurations without saving it
	*/
	PostRecordingKeyconfigurationsValidate(ctx context.Context, params *PostRecordingKeyconfigurationsValidateParams) (*PostRecordingKeyconfigurationsValidateOK, error)
	/*
	   PostRecordingLocalkeys creates a local key management recording key
	*/
	PostRecordingLocalkeys(ctx context.Context, params *PostRecordingLocalkeysParams) (*PostRecordingLocalkeysOK, error)
	/*
	   PostRecordingLocalkeysSettings creates settings for local key creation replaced by API recording keyconfigurations
	*/
	PostRecordingLocalkeysSettings(ctx context.Context, params *PostRecordingLocalkeysSettingsParams) (*PostRecordingLocalkeysSettingsOK, error)
	/*
	   PostRecordingMediaretentionpolicies creates media retention policy
	   Policy does not work retroactively
	*/
	PostRecordingMediaretentionpolicies(ctx context.Context, params *PostRecordingMediaretentionpoliciesParams) (*PostRecordingMediaretentionpoliciesOK, error)
	/*
	   PostRecordingRecordingkeys creates encryption key
	*/
	PostRecordingRecordingkeys(ctx context.Context, params *PostRecordingRecordingkeysParams) (*PostRecordingRecordingkeysOK, error)
	/*
	   PostRecordingUploadsReports creates a recording upload status report
	*/
	PostRecordingUploadsReports(ctx context.Context, params *PostRecordingUploadsReportsParams) (*PostRecordingUploadsReportsAccepted, error)
	/*
	   PostRecordingsDeletionprotection gets a list of conversations with protected recordings
	*/
	PostRecordingsDeletionprotection(ctx context.Context, params *PostRecordingsDeletionprotectionParams) (*PostRecordingsDeletionprotectionOK, error)
	/*
	   PostRecordingsScreensessionsAcknowledge acknowledges a screen recording
	*/
	PostRecordingsScreensessionsAcknowledge(ctx context.Context, params *PostRecordingsScreensessionsAcknowledgeParams) (*PostRecordingsScreensessionsAcknowledgeNoContent, error)
	/*
	   PostRecordingsScreensessionsMetadata provides meta data a screen recording
	*/
	PostRecordingsScreensessionsMetadata(ctx context.Context, params *PostRecordingsScreensessionsMetadataParams) (*PostRecordingsScreensessionsMetadataNoContent, error)
	/*
	   PutConversationRecording updates the retention records on a recording
	   Currently supports updating and removing both archive and delete dates for eligible recordings. A request to change the archival date of an archived recording will result in a restoration of the recording until the new date set. The recording:recording:view permission is required for the recording, as well as either the recording:recording:editRetention or recording:screenRecording:editRetention permissions depending on the type of recording.
	*/
	PutConversationRecording(ctx context.Context, params *PutConversationRecordingParams) (*PutConversationRecordingOK, error)
	/*
	   PutConversationRecordingAnnotation updates annotation
	*/
	PutConversationRecordingAnnotation(ctx context.Context, params *PutConversationRecordingAnnotationParams) (*PutConversationRecordingAnnotationOK, error)
	/*
	   PutOrphanrecording updates an orphan recording to a regular recording with retention values
	   If this operation is successful the orphan will no longer exist. It will be replaced by the resulting recording in the response. This replacement recording is accessible by the normal Recording api.
	*/
	PutOrphanrecording(ctx context.Context, params *PutOrphanrecordingParams) (*PutOrphanrecordingOK, error)
	/*
	   PutRecordingCrossplatformMediaretentionpolicy updates a media retention policy
	   Policy does not work retroactively
	*/
	PutRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *PutRecordingCrossplatformMediaretentionpolicyParams) (*PutRecordingCrossplatformMediaretentionpolicyOK, error)
	/*
	   PutRecordingJob executes the recording bulk job
	   A job must be executed by the same user whom originally created the job.  In addition, the user must have permission to update the recording's retention.
	*/
	PutRecordingJob(ctx context.Context, params *PutRecordingJobParams) (*PutRecordingJobOK, error)
	/*
	   PutRecordingKeyconfiguration updates the encryption key configurations
	*/
	PutRecordingKeyconfiguration(ctx context.Context, params *PutRecordingKeyconfigurationParams) (*PutRecordingKeyconfigurationOK, error)
	/*
	   PutRecordingLocalkeysSetting updates the local encryption settings replaced by API recording keyconfigurations key configuration Id
	*/
	PutRecordingLocalkeysSetting(ctx context.Context, params *PutRecordingLocalkeysSettingParams) (*PutRecordingLocalkeysSettingOK, error)
	/*
	   PutRecordingMediaretentionpolicy updates a media retention policy
	   Policy does not work retroactively
	*/
	PutRecordingMediaretentionpolicy(ctx context.Context, params *PutRecordingMediaretentionpolicyParams) (*PutRecordingMediaretentionpolicyOK, error)
	/*
	   PutRecordingRecordingkeysRotationschedule updates key rotation schedule
	*/
	PutRecordingRecordingkeysRotationschedule(ctx context.Context, params *PutRecordingRecordingkeysRotationscheduleParams) (*PutRecordingRecordingkeysRotationscheduleOK, error)
	/*
	   PutRecordingSettings updates the recording settings for the organization
	*/
	PutRecordingSettings(ctx context.Context, params *PutRecordingSettingsParams) (*PutRecordingSettingsOK, error)
	/*
	   PutRecordingsDeletionprotection applies or revoke recording protection for conversations
	*/
	PutRecordingsDeletionprotection(ctx context.Context, params *PutRecordingsDeletionprotectionParams) (*PutRecordingsDeletionprotectionNoContent, error)
}

// New creates a new recording API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for recording API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
DeleteConversationRecordingAnnotation deletes annotation
*/
func (a *Client) DeleteConversationRecordingAnnotation(ctx context.Context, params *DeleteConversationRecordingAnnotationParams) error {

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteConversationRecordingAnnotation",
		Method:             "DELETE",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteConversationRecordingAnnotationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
DeleteOrphanrecording deletes a single orphan recording
*/
func (a *Client) DeleteOrphanrecording(ctx context.Context, params *DeleteOrphanrecordingParams) (*DeleteOrphanrecordingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteOrphanrecording",
		Method:             "DELETE",
		PathPattern:        "/api/v2/orphanrecordings/{orphanId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteOrphanrecordingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteOrphanrecordingOK), nil

}

/*
DeleteRecordingCrossplatformMediaretentionpolicies deletes media retention policies

Bulk delete of media retention policies, this will only delete the polices that match the ids specified in the query param.
*/
func (a *Client) DeleteRecordingCrossplatformMediaretentionpolicies(ctx context.Context, params *DeleteRecordingCrossplatformMediaretentionpoliciesParams) (*DeleteRecordingCrossplatformMediaretentionpoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteRecordingCrossplatformMediaretentionpolicies",
		Method:             "DELETE",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRecordingCrossplatformMediaretentionpoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRecordingCrossplatformMediaretentionpoliciesOK), nil

}

/*
DeleteRecordingCrossplatformMediaretentionpolicy deletes a media retention policy
*/
func (a *Client) DeleteRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *DeleteRecordingCrossplatformMediaretentionpolicyParams) (*DeleteRecordingCrossplatformMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteRecordingCrossplatformMediaretentionpolicy",
		Method:             "DELETE",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRecordingCrossplatformMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRecordingCrossplatformMediaretentionpolicyOK), nil

}

/*
DeleteRecordingJob deletes the recording bulk job
*/
func (a *Client) DeleteRecordingJob(ctx context.Context, params *DeleteRecordingJobParams) (*DeleteRecordingJobNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteRecordingJob",
		Method:             "DELETE",
		PathPattern:        "/api/v2/recording/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRecordingJobReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRecordingJobNoContent), nil

}

/*
DeleteRecordingMediaretentionpolicies deletes media retention policies

Bulk delete of media retention policies, this will only delete the polices that match the ids specified in the query param.
*/
func (a *Client) DeleteRecordingMediaretentionpolicies(ctx context.Context, params *DeleteRecordingMediaretentionpoliciesParams) (*DeleteRecordingMediaretentionpoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteRecordingMediaretentionpolicies",
		Method:             "DELETE",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRecordingMediaretentionpoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRecordingMediaretentionpoliciesOK), nil

}

/*
DeleteRecordingMediaretentionpolicy deletes a media retention policy
*/
func (a *Client) DeleteRecordingMediaretentionpolicy(ctx context.Context, params *DeleteRecordingMediaretentionpolicyParams) (*DeleteRecordingMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteRecordingMediaretentionpolicy",
		Method:             "DELETE",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteRecordingMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteRecordingMediaretentionpolicyOK), nil

}

/*
GetConversationRecording gets a specific recording
*/
func (a *Client) GetConversationRecording(ctx context.Context, params *GetConversationRecordingParams) (*GetConversationRecordingAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationRecording",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationRecordingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationRecordingAccepted), nil

}

/*
GetConversationRecordingAnnotation gets annotation
*/
func (a *Client) GetConversationRecordingAnnotation(ctx context.Context, params *GetConversationRecordingAnnotationParams) (*GetConversationRecordingAnnotationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationRecordingAnnotation",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationRecordingAnnotationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationRecordingAnnotationOK), nil

}

/*
GetConversationRecordingAnnotations gets annotations for recording
*/
func (a *Client) GetConversationRecordingAnnotations(ctx context.Context, params *GetConversationRecordingAnnotationsParams) (*GetConversationRecordingAnnotationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationRecordingAnnotations",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationRecordingAnnotationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationRecordingAnnotationsOK), nil

}

/*
GetConversationRecordingmetadata gets recording metadata for a conversation does not return playable media annotations won t be included in the response if recording recording view permission is missing
*/
func (a *Client) GetConversationRecordingmetadata(ctx context.Context, params *GetConversationRecordingmetadataParams) (*GetConversationRecordingmetadataOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationRecordingmetadata",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordingmetadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationRecordingmetadataReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationRecordingmetadataOK), nil

}

/*
GetConversationRecordingmetadataRecordingID gets metadata for a specific recording does not return playable media
*/
func (a *Client) GetConversationRecordingmetadataRecordingID(ctx context.Context, params *GetConversationRecordingmetadataRecordingIDParams) (*GetConversationRecordingmetadataRecordingIDOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationRecordingmetadataRecordingId",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordingmetadata/{recordingId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationRecordingmetadataRecordingIDReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConversationRecordingmetadataRecordingIDOK), nil

}

/*
GetConversationRecordings gets all of a conversation s recordings
*/
func (a *Client) GetConversationRecordings(ctx context.Context, params *GetConversationRecordingsParams) (*GetConversationRecordingsOK, *GetConversationRecordingsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getConversationRecordings",
		Method:             "GET",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetConversationRecordingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetConversationRecordingsOK:
		return value, nil, nil
	case *GetConversationRecordingsAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetOrphanrecording gets a single orphan recording
*/
func (a *Client) GetOrphanrecording(ctx context.Context, params *GetOrphanrecordingParams) (*GetOrphanrecordingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOrphanrecording",
		Method:             "GET",
		PathPattern:        "/api/v2/orphanrecordings/{orphanId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOrphanrecordingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOrphanrecordingOK), nil

}

/*
GetOrphanrecordingMedia gets the media of a single orphan recording

A 202 response means the orphaned media is currently transcoding and will be available shortly.A 200 response denotes the transcoded orphan media is available now and is contained in the response body.
*/
func (a *Client) GetOrphanrecordingMedia(ctx context.Context, params *GetOrphanrecordingMediaParams) (*GetOrphanrecordingMediaOK, *GetOrphanrecordingMediaAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOrphanrecordingMedia",
		Method:             "GET",
		PathPattern:        "/api/v2/orphanrecordings/{orphanId}/media",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOrphanrecordingMediaReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *GetOrphanrecordingMediaOK:
		return value, nil, nil
	case *GetOrphanrecordingMediaAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetOrphanrecordings gets all orphan recordings
*/
func (a *Client) GetOrphanrecordings(ctx context.Context, params *GetOrphanrecordingsParams) (*GetOrphanrecordingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOrphanrecordings",
		Method:             "GET",
		PathPattern:        "/api/v2/orphanrecordings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOrphanrecordingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOrphanrecordingsOK), nil

}

/*
GetRecordingBatchrequest gets the status and results for a batch request job only the user that submitted the job may retrieve results
*/
func (a *Client) GetRecordingBatchrequest(ctx context.Context, params *GetRecordingBatchrequestParams) (*GetRecordingBatchrequestOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingBatchrequest",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/batchrequests/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingBatchrequestReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingBatchrequestOK), nil

}

/*
GetRecordingCrossplatformMediaretentionpolicies gets media retention policy list with query options to filter on name and enabled

for a less verbose response, add summary=true to this endpoint
*/
func (a *Client) GetRecordingCrossplatformMediaretentionpolicies(ctx context.Context, params *GetRecordingCrossplatformMediaretentionpoliciesParams) (*GetRecordingCrossplatformMediaretentionpoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingCrossplatformMediaretentionpolicies",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingCrossplatformMediaretentionpoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingCrossplatformMediaretentionpoliciesOK), nil

}

/*
GetRecordingCrossplatformMediaretentionpolicy gets a media retention policy
*/
func (a *Client) GetRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *GetRecordingCrossplatformMediaretentionpolicyParams) (*GetRecordingCrossplatformMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingCrossplatformMediaretentionpolicy",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingCrossplatformMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingCrossplatformMediaretentionpolicyOK), nil

}

/*
GetRecordingJob gets the status of the job associated with the job id
*/
func (a *Client) GetRecordingJob(ctx context.Context, params *GetRecordingJobParams) (*GetRecordingJobOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingJob",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingJobReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingJobOK), nil

}

/*
GetRecordingJobFailedrecordings gets i ds of recordings that the bulk job failed for
*/
func (a *Client) GetRecordingJobFailedrecordings(ctx context.Context, params *GetRecordingJobFailedrecordingsParams) (*GetRecordingJobFailedrecordingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingJobFailedrecordings",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/jobs/{jobId}/failedrecordings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingJobFailedrecordingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingJobFailedrecordingsOK), nil

}

/*
GetRecordingJobs gets the status of all jobs within the user s organization
*/
func (a *Client) GetRecordingJobs(ctx context.Context, params *GetRecordingJobsParams) (*GetRecordingJobsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingJobs",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingJobsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingJobsOK), nil

}

/*
GetRecordingKeyconfiguration gets the encryption key configurations
*/
func (a *Client) GetRecordingKeyconfiguration(ctx context.Context, params *GetRecordingKeyconfigurationParams) (*GetRecordingKeyconfigurationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingKeyconfiguration",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/keyconfigurations/{keyConfigurationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingKeyconfigurationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingKeyconfigurationOK), nil

}

/*
GetRecordingKeyconfigurations gets a list of key configurations data
*/
func (a *Client) GetRecordingKeyconfigurations(ctx context.Context, params *GetRecordingKeyconfigurationsParams) (*GetRecordingKeyconfigurationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingKeyconfigurations",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/keyconfigurations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingKeyconfigurationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingKeyconfigurationsOK), nil

}

/*
GetRecordingLocalkeysSetting gets the local encryption settings replaced by API recording keyconfigurations key configuration Id
*/
func (a *Client) GetRecordingLocalkeysSetting(ctx context.Context, params *GetRecordingLocalkeysSettingParams) (*GetRecordingLocalkeysSettingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingLocalkeysSetting",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/localkeys/settings/{settingsId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingLocalkeysSettingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingLocalkeysSettingOK), nil

}

/*
GetRecordingLocalkeysSettings gets a list local key settings data replaced by API recording keyconfigurations
*/
func (a *Client) GetRecordingLocalkeysSettings(ctx context.Context, params *GetRecordingLocalkeysSettingsParams) (*GetRecordingLocalkeysSettingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingLocalkeysSettings",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/localkeys/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingLocalkeysSettingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingLocalkeysSettingsOK), nil

}

/*
GetRecordingMediaretentionpolicies gets media retention policy list with query options to filter on name and enabled

for a less verbose response, add summary=true to this endpoint
*/
func (a *Client) GetRecordingMediaretentionpolicies(ctx context.Context, params *GetRecordingMediaretentionpoliciesParams) (*GetRecordingMediaretentionpoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingMediaretentionpolicies",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingMediaretentionpoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingMediaretentionpoliciesOK), nil

}

/*
GetRecordingMediaretentionpolicy gets a media retention policy
*/
func (a *Client) GetRecordingMediaretentionpolicy(ctx context.Context, params *GetRecordingMediaretentionpolicyParams) (*GetRecordingMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingMediaretentionpolicy",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingMediaretentionpolicyOK), nil

}

/*
GetRecordingRecordingkeys gets encryption key list
*/
func (a *Client) GetRecordingRecordingkeys(ctx context.Context, params *GetRecordingRecordingkeysParams) (*GetRecordingRecordingkeysOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingRecordingkeys",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/recordingkeys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingRecordingkeysReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingRecordingkeysOK), nil

}

/*
GetRecordingRecordingkeysRotationschedule gets key rotation schedule
*/
func (a *Client) GetRecordingRecordingkeysRotationschedule(ctx context.Context, params *GetRecordingRecordingkeysRotationscheduleParams) (*GetRecordingRecordingkeysRotationscheduleOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingRecordingkeysRotationschedule",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/recordingkeys/rotationschedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingRecordingkeysRotationscheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingRecordingkeysRotationscheduleOK), nil

}

/*
GetRecordingSettings gets the recording settings for the organization
*/
func (a *Client) GetRecordingSettings(ctx context.Context, params *GetRecordingSettingsParams) (*GetRecordingSettingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingSettings",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingSettingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingSettingsOK), nil

}

/*
GetRecordingUploadsReport gets the status of a recording upload status report
*/
func (a *Client) GetRecordingUploadsReport(ctx context.Context, params *GetRecordingUploadsReportParams) (*GetRecordingUploadsReportOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingUploadsReport",
		Method:             "GET",
		PathPattern:        "/api/v2/recording/uploads/reports/{reportId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingUploadsReportReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingUploadsReportOK), nil

}

/*
GetRecordingsRetentionQuery queries for recording retention data
*/
func (a *Client) GetRecordingsRetentionQuery(ctx context.Context, params *GetRecordingsRetentionQueryParams) (*GetRecordingsRetentionQueryOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingsRetentionQuery",
		Method:             "GET",
		PathPattern:        "/api/v2/recordings/retention/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingsRetentionQueryReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingsRetentionQueryOK), nil

}

/*
GetRecordingsScreensessions retrieves a paged listing of screen recording sessions
*/
func (a *Client) GetRecordingsScreensessions(ctx context.Context, params *GetRecordingsScreensessionsParams) (*GetRecordingsScreensessionsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRecordingsScreensessions",
		Method:             "GET",
		PathPattern:        "/api/v2/recordings/screensessions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRecordingsScreensessionsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRecordingsScreensessionsOK), nil

}

/*
PatchRecordingCrossplatformMediaretentionpolicy patches a media retention policy
*/
func (a *Client) PatchRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *PatchRecordingCrossplatformMediaretentionpolicyParams) (*PatchRecordingCrossplatformMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchRecordingCrossplatformMediaretentionpolicy",
		Method:             "PATCH",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchRecordingCrossplatformMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchRecordingCrossplatformMediaretentionpolicyOK), nil

}

/*
PatchRecordingMediaretentionpolicy patches a media retention policy
*/
func (a *Client) PatchRecordingMediaretentionpolicy(ctx context.Context, params *PatchRecordingMediaretentionpolicyParams) (*PatchRecordingMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchRecordingMediaretentionpolicy",
		Method:             "PATCH",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchRecordingMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchRecordingMediaretentionpolicyOK), nil

}

/*
PatchRecordingsScreensession updates a screen recording session
*/
func (a *Client) PatchRecordingsScreensession(ctx context.Context, params *PatchRecordingsScreensessionParams) error {

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "patchRecordingsScreensession",
		Method:             "PATCH",
		PathPattern:        "/api/v2/recordings/screensessions/{recordingSessionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PatchRecordingsScreensessionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
PostConversationRecordingAnnotations creates annotation
*/
func (a *Client) PostConversationRecordingAnnotations(ctx context.Context, params *PostConversationRecordingAnnotationsParams) (*PostConversationRecordingAnnotationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postConversationRecordingAnnotations",
		Method:             "POST",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostConversationRecordingAnnotationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConversationRecordingAnnotationsOK), nil

}

/*
PostRecordingBatchrequests submits a batch download request for recordings recordings in response will be in their original format codec configured in the trunk configuration
*/
func (a *Client) PostRecordingBatchrequests(ctx context.Context, params *PostRecordingBatchrequestsParams) (*PostRecordingBatchrequestsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingBatchrequests",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/batchrequests",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingBatchrequestsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingBatchrequestsOK), nil

}

/*
PostRecordingCrossplatformMediaretentionpolicies creates media retention policy

Policy does not work retroactively
*/
func (a *Client) PostRecordingCrossplatformMediaretentionpolicies(ctx context.Context, params *PostRecordingCrossplatformMediaretentionpoliciesParams) (*PostRecordingCrossplatformMediaretentionpoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingCrossplatformMediaretentionpolicies",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingCrossplatformMediaretentionpoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingCrossplatformMediaretentionpoliciesOK), nil

}

/*
PostRecordingJobs creates a recording bulk job

Each organization can run up to a maximum of two concurrent jobs that are either in pending or processing state. Furthermore, the recording:recording:viewSensitiveData permission is required to access recordings with PCI DSS and/or PII data. If the requester does not have that permission and includeRecordingsWithSensitiveData is set to true, then their request will be rejected.
*/
func (a *Client) PostRecordingJobs(ctx context.Context, params *PostRecordingJobsParams) (*PostRecordingJobsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingJobs",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingJobsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingJobsAccepted), nil

}

/*
PostRecordingKeyconfigurations setups configurations for encryption key creation
*/
func (a *Client) PostRecordingKeyconfigurations(ctx context.Context, params *PostRecordingKeyconfigurationsParams) (*PostRecordingKeyconfigurationsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingKeyconfigurations",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/keyconfigurations",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingKeyconfigurationsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingKeyconfigurationsOK), nil

}

/*
PostRecordingKeyconfigurationsValidate validates encryption key configurations without saving it
*/
func (a *Client) PostRecordingKeyconfigurationsValidate(ctx context.Context, params *PostRecordingKeyconfigurationsValidateParams) (*PostRecordingKeyconfigurationsValidateOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingKeyconfigurationsValidate",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/keyconfigurations/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingKeyconfigurationsValidateReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingKeyconfigurationsValidateOK), nil

}

/*
PostRecordingLocalkeys creates a local key management recording key
*/
func (a *Client) PostRecordingLocalkeys(ctx context.Context, params *PostRecordingLocalkeysParams) (*PostRecordingLocalkeysOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingLocalkeys",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/localkeys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingLocalkeysReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingLocalkeysOK), nil

}

/*
PostRecordingLocalkeysSettings creates settings for local key creation replaced by API recording keyconfigurations
*/
func (a *Client) PostRecordingLocalkeysSettings(ctx context.Context, params *PostRecordingLocalkeysSettingsParams) (*PostRecordingLocalkeysSettingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingLocalkeysSettings",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/localkeys/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingLocalkeysSettingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingLocalkeysSettingsOK), nil

}

/*
PostRecordingMediaretentionpolicies creates media retention policy

Policy does not work retroactively
*/
func (a *Client) PostRecordingMediaretentionpolicies(ctx context.Context, params *PostRecordingMediaretentionpoliciesParams) (*PostRecordingMediaretentionpoliciesOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingMediaretentionpolicies",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingMediaretentionpoliciesReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingMediaretentionpoliciesOK), nil

}

/*
PostRecordingRecordingkeys creates encryption key
*/
func (a *Client) PostRecordingRecordingkeys(ctx context.Context, params *PostRecordingRecordingkeysParams) (*PostRecordingRecordingkeysOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingRecordingkeys",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/recordingkeys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingRecordingkeysReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingRecordingkeysOK), nil

}

/*
PostRecordingUploadsReports creates a recording upload status report
*/
func (a *Client) PostRecordingUploadsReports(ctx context.Context, params *PostRecordingUploadsReportsParams) (*PostRecordingUploadsReportsAccepted, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingUploadsReports",
		Method:             "POST",
		PathPattern:        "/api/v2/recording/uploads/reports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingUploadsReportsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingUploadsReportsAccepted), nil

}

/*
PostRecordingsDeletionprotection gets a list of conversations with protected recordings
*/
func (a *Client) PostRecordingsDeletionprotection(ctx context.Context, params *PostRecordingsDeletionprotectionParams) (*PostRecordingsDeletionprotectionOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingsDeletionprotection",
		Method:             "POST",
		PathPattern:        "/api/v2/recordings/deletionprotection",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingsDeletionprotectionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingsDeletionprotectionOK), nil

}

/*
PostRecordingsScreensessionsAcknowledge acknowledges a screen recording
*/
func (a *Client) PostRecordingsScreensessionsAcknowledge(ctx context.Context, params *PostRecordingsScreensessionsAcknowledgeParams) (*PostRecordingsScreensessionsAcknowledgeNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingsScreensessionsAcknowledge",
		Method:             "POST",
		PathPattern:        "/api/v2/recordings/screensessions/acknowledge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingsScreensessionsAcknowledgeReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingsScreensessionsAcknowledgeNoContent), nil

}

/*
PostRecordingsScreensessionsMetadata provides meta data a screen recording
*/
func (a *Client) PostRecordingsScreensessionsMetadata(ctx context.Context, params *PostRecordingsScreensessionsMetadataParams) (*PostRecordingsScreensessionsMetadataNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postRecordingsScreensessionsMetadata",
		Method:             "POST",
		PathPattern:        "/api/v2/recordings/screensessions/metadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostRecordingsScreensessionsMetadataReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostRecordingsScreensessionsMetadataNoContent), nil

}

/*
PutConversationRecording updates the retention records on a recording

Currently supports updating and removing both archive and delete dates for eligible recordings. A request to change the archival date of an archived recording will result in a restoration of the recording until the new date set. The recording:recording:view permission is required for the recording, as well as either the recording:recording:editRetention or recording:screenRecording:editRetention permissions depending on the type of recording.
*/
func (a *Client) PutConversationRecording(ctx context.Context, params *PutConversationRecordingParams) (*PutConversationRecordingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationRecording",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationRecordingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationRecordingOK), nil

}

/*
PutConversationRecordingAnnotation updates annotation
*/
func (a *Client) PutConversationRecordingAnnotation(ctx context.Context, params *PutConversationRecordingAnnotationParams) (*PutConversationRecordingAnnotationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putConversationRecordingAnnotation",
		Method:             "PUT",
		PathPattern:        "/api/v2/conversations/{conversationId}/recordings/{recordingId}/annotations/{annotationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutConversationRecordingAnnotationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutConversationRecordingAnnotationOK), nil

}

/*
PutOrphanrecording updates an orphan recording to a regular recording with retention values

If this operation is successful the orphan will no longer exist. It will be replaced by the resulting recording in the response. This replacement recording is accessible by the normal Recording api.
*/
func (a *Client) PutOrphanrecording(ctx context.Context, params *PutOrphanrecordingParams) (*PutOrphanrecordingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putOrphanrecording",
		Method:             "PUT",
		PathPattern:        "/api/v2/orphanrecordings/{orphanId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutOrphanrecordingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutOrphanrecordingOK), nil

}

/*
PutRecordingCrossplatformMediaretentionpolicy updates a media retention policy

Policy does not work retroactively
*/
func (a *Client) PutRecordingCrossplatformMediaretentionpolicy(ctx context.Context, params *PutRecordingCrossplatformMediaretentionpolicyParams) (*PutRecordingCrossplatformMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingCrossplatformMediaretentionpolicy",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/crossplatform/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingCrossplatformMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingCrossplatformMediaretentionpolicyOK), nil

}

/*
PutRecordingJob executes the recording bulk job

A job must be executed by the same user whom originally created the job.  In addition, the user must have permission to update the recording's retention.
*/
func (a *Client) PutRecordingJob(ctx context.Context, params *PutRecordingJobParams) (*PutRecordingJobOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingJob",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingJobReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingJobOK), nil

}

/*
PutRecordingKeyconfiguration updates the encryption key configurations
*/
func (a *Client) PutRecordingKeyconfiguration(ctx context.Context, params *PutRecordingKeyconfigurationParams) (*PutRecordingKeyconfigurationOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingKeyconfiguration",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/keyconfigurations/{keyConfigurationId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingKeyconfigurationReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingKeyconfigurationOK), nil

}

/*
PutRecordingLocalkeysSetting updates the local encryption settings replaced by API recording keyconfigurations key configuration Id
*/
func (a *Client) PutRecordingLocalkeysSetting(ctx context.Context, params *PutRecordingLocalkeysSettingParams) (*PutRecordingLocalkeysSettingOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingLocalkeysSetting",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/localkeys/settings/{settingsId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingLocalkeysSettingReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingLocalkeysSettingOK), nil

}

/*
PutRecordingMediaretentionpolicy updates a media retention policy

Policy does not work retroactively
*/
func (a *Client) PutRecordingMediaretentionpolicy(ctx context.Context, params *PutRecordingMediaretentionpolicyParams) (*PutRecordingMediaretentionpolicyOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingMediaretentionpolicy",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/mediaretentionpolicies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingMediaretentionpolicyReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingMediaretentionpolicyOK), nil

}

/*
PutRecordingRecordingkeysRotationschedule updates key rotation schedule
*/
func (a *Client) PutRecordingRecordingkeysRotationschedule(ctx context.Context, params *PutRecordingRecordingkeysRotationscheduleParams) (*PutRecordingRecordingkeysRotationscheduleOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingRecordingkeysRotationschedule",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/recordingkeys/rotationschedule",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingRecordingkeysRotationscheduleReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingRecordingkeysRotationscheduleOK), nil

}

/*
PutRecordingSettings updates the recording settings for the organization
*/
func (a *Client) PutRecordingSettings(ctx context.Context, params *PutRecordingSettingsParams) (*PutRecordingSettingsOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingSettings",
		Method:             "PUT",
		PathPattern:        "/api/v2/recording/settings",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingSettingsReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingSettingsOK), nil

}

/*
PutRecordingsDeletionprotection applies or revoke recording protection for conversations
*/
func (a *Client) PutRecordingsDeletionprotection(ctx context.Context, params *PutRecordingsDeletionprotectionParams) (*PutRecordingsDeletionprotectionNoContent, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "putRecordingsDeletionprotection",
		Method:             "PUT",
		PathPattern:        "/api/v2/recordings/deletionprotection",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutRecordingsDeletionprotectionReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PutRecordingsDeletionprotectionNoContent), nil

}
