// Code generated by go-swagger; DO NOT EDIT.

package recording

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"github.com/freman/genesysapi/models"
)

// PostRecordingCrossplatformMediaretentionpoliciesReader is a Reader for the PostRecordingCrossplatformMediaretentionpolicies structure.
type PostRecordingCrossplatformMediaretentionpoliciesReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PostRecordingCrossplatformMediaretentionpoliciesReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 408:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesRequestTimeout()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 413:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 415:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 429:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesTooManyRequests()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 503:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 504:
		result := NewPostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPostRecordingCrossplatformMediaretentionpoliciesOK creates a PostRecordingCrossplatformMediaretentionpoliciesOK with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesOK() *PostRecordingCrossplatformMediaretentionpoliciesOK {
	return &PostRecordingCrossplatformMediaretentionpoliciesOK{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesOK handles this case with default header values.

successful operation
*/
type PostRecordingCrossplatformMediaretentionpoliciesOK struct {
	Payload *models.CrossPlatformPolicy
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesOK) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesOK  %+v", 200, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesOK) GetPayload() *models.CrossPlatformPolicy {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.CrossPlatformPolicy)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesBadRequest creates a PostRecordingCrossplatformMediaretentionpoliciesBadRequest with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesBadRequest() *PostRecordingCrossplatformMediaretentionpoliciesBadRequest {
	return &PostRecordingCrossplatformMediaretentionpoliciesBadRequest{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesBadRequest handles this case with default header values.

The request could not be understood by the server due to malformed syntax.
*/
type PostRecordingCrossplatformMediaretentionpoliciesBadRequest struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesBadRequest) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesBadRequest  %+v", 400, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesBadRequest) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesUnauthorized creates a PostRecordingCrossplatformMediaretentionpoliciesUnauthorized with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesUnauthorized() *PostRecordingCrossplatformMediaretentionpoliciesUnauthorized {
	return &PostRecordingCrossplatformMediaretentionpoliciesUnauthorized{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesUnauthorized handles this case with default header values.

No authentication bearer token specified in authorization header.
*/
type PostRecordingCrossplatformMediaretentionpoliciesUnauthorized struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesUnauthorized) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesUnauthorized  %+v", 401, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesUnauthorized) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesForbidden creates a PostRecordingCrossplatformMediaretentionpoliciesForbidden with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesForbidden() *PostRecordingCrossplatformMediaretentionpoliciesForbidden {
	return &PostRecordingCrossplatformMediaretentionpoliciesForbidden{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesForbidden handles this case with default header values.

You are not authorized to perform the requested action.
*/
type PostRecordingCrossplatformMediaretentionpoliciesForbidden struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesForbidden) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesForbidden  %+v", 403, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesForbidden) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesNotFound creates a PostRecordingCrossplatformMediaretentionpoliciesNotFound with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesNotFound() *PostRecordingCrossplatformMediaretentionpoliciesNotFound {
	return &PostRecordingCrossplatformMediaretentionpoliciesNotFound{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesNotFound handles this case with default header values.

The requested resource was not found.
*/
type PostRecordingCrossplatformMediaretentionpoliciesNotFound struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesNotFound) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesNotFound  %+v", 404, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesNotFound) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesRequestTimeout creates a PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesRequestTimeout() *PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout {
	return &PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout handles this case with default header values.

The client did not produce a request within the server timeout limit. This can be caused by a slow network connection and/or large payloads.
*/
type PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesRequestTimeout  %+v", 408, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesRequestTimeout) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge creates a PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge() *PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge {
	return &PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge handles this case with default header values.

The request is over the size limit. Content-Length: %s, Maximum bytes: %s
*/
type PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge  %+v", 413, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesRequestEntityTooLarge) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType creates a PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType() *PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType {
	return &PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType handles this case with default header values.

Unsupported Media Type - Unsupported or incorrect media type, such as an incorrect Content-Type value in the header.
*/
type PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType  %+v", 415, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesUnsupportedMediaType) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesTooManyRequests creates a PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesTooManyRequests() *PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests {
	return &PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests handles this case with default header values.

Rate limit exceeded the maximum. Retry the request in [%s] seconds
*/
type PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesTooManyRequests  %+v", 429, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesTooManyRequests) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesInternalServerError creates a PostRecordingCrossplatformMediaretentionpoliciesInternalServerError with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesInternalServerError() *PostRecordingCrossplatformMediaretentionpoliciesInternalServerError {
	return &PostRecordingCrossplatformMediaretentionpoliciesInternalServerError{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesInternalServerError handles this case with default header values.

The server encountered an unexpected condition which prevented it from fulfilling the request.
*/
type PostRecordingCrossplatformMediaretentionpoliciesInternalServerError struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesInternalServerError) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesInternalServerError  %+v", 500, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesInternalServerError) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable creates a PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable() *PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable {
	return &PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable handles this case with default header values.

Service Unavailable - The server is currently unavailable (because it is overloaded or down for maintenance).
*/
type PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesServiceUnavailable  %+v", 503, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesServiceUnavailable) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout creates a PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout with default headers values
func NewPostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout() *PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout {
	return &PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout{}
}

/*PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout handles this case with default header values.

The request timed out.
*/
type PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout struct {
	Payload *models.ErrorBody
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout) Error() string {
	return fmt.Sprintf("[POST /api/v2/recording/crossplatform/mediaretentionpolicies][%d] postRecordingCrossplatformMediaretentionpoliciesGatewayTimeout  %+v", 504, o.Payload)
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout) GetPayload() *models.ErrorBody {
	return o.Payload
}

func (o *PostRecordingCrossplatformMediaretentionpoliciesGatewayTimeout) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
