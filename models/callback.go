// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Callback callback
//
// swagger:model Callback
type Callback struct {

	// After-call work for the communication.
	AfterCallWork *AfterCallWork `json:"afterCallWork,omitempty"`

	// Indicates if after-call work is required for a communication. Only used when the ACW Setting is Agent Requested.
	AfterCallWorkRequired bool `json:"afterCallWorkRequired"`

	// The id of the config for automatically placing the callback (and handling the disposition). If null, the callback will not be placed automatically but routed to an agent as per normal.
	AutomatedCallbackConfigID string `json:"automatedCallbackConfigId,omitempty"`

	// The phone number(s) to use to place the callback.
	CallbackNumbers []string `json:"callbackNumbers"`

	// The timestamp when this communication is scheduled in the provider clock. If this value is missing it indicates the callback will be placed immediately. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	CallbackScheduledTime strfmt.DateTime `json:"callbackScheduledTime,omitempty"`

	// The name of the user requesting a callback.
	CallbackUserName string `json:"callbackUserName,omitempty"`

	// The timestamp when this communication was connected in the cloud clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	ConnectedTime strfmt.DateTime `json:"connectedTime,omitempty"`

	// The preview data to be used when this callback is a Preview.
	DialerPreview *DialerPreview `json:"dialerPreview,omitempty"`

	// The direction of the call
	// Enum: [inbound outbound]
	Direction string `json:"direction,omitempty"`

	// System defined string indicating what caused the communication to disconnect. Will be null until the communication disconnects.
	// Enum: [endpoint client system timeout transfer transfer.conference transfer.consult transfer.forward transfer.noanswer transfer.notavailable transport.failure error peer other spam uncallable]
	DisconnectType string `json:"disconnectType,omitempty"`

	// The timestamp when this communication disconnected from the conversation in the provider clock. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	DisconnectedTime strfmt.DateTime `json:"disconnectedTime,omitempty"`

	// True if the call for the callback uses external dialing.
	ExternalCampaign bool `json:"externalCampaign"`

	// True if this call is held and the person on this side hears silence.
	Held bool `json:"held"`

	// A globally unique identifier for this communication.
	ID string `json:"id,omitempty"`

	// The id of the peer communication corresponding to a matching leg for this communication.
	PeerID string `json:"peerId,omitempty"`

	// The source provider for the callback.
	Provider string `json:"provider,omitempty"`

	// The UUID of the script to use.
	ScriptID string `json:"scriptId,omitempty"`

	// The time line of the participant's callback, divided into activity segments.
	Segments []*Segment `json:"segments"`

	// True if the ability to skip a callback should be enabled.
	SkipEnabled bool `json:"skipEnabled"`

	// The timestamp the communication has when it is first put into an alerting state. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	StartAlertingTime strfmt.DateTime `json:"startAlertingTime,omitempty"`

	// The timestamp the callback was placed on hold in the cloud clock if the callback is currently on hold. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	StartHoldTime strfmt.DateTime `json:"startHoldTime,omitempty"`

	// The connection state of this communication.
	// Enum: [alerting dialing contacting offering connected disconnected terminated scheduled none]
	State string `json:"state,omitempty"`

	// The number of seconds before the system automatically places a call for a callback.  0 means the automatic placement is disabled.
	TimeoutSeconds int32 `json:"timeoutSeconds,omitempty"`

	// The voicemail data to be used when this callback is an ACD voicemail.
	Voicemail *Voicemail `json:"voicemail,omitempty"`

	// Call wrap up or disposition data.
	Wrapup *Wrapup `json:"wrapup,omitempty"`
}

// Validate validates this callback
func (m *Callback) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAfterCallWork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCallbackScheduledTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnectedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDialerPreview(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisconnectType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisconnectedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSegments(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartAlertingTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartHoldTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoicemail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWrapup(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Callback) validateAfterCallWork(formats strfmt.Registry) error {

	if swag.IsZero(m.AfterCallWork) { // not required
		return nil
	}

	if m.AfterCallWork != nil {
		if err := m.AfterCallWork.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("afterCallWork")
			}
			return err
		}
	}

	return nil
}

func (m *Callback) validateCallbackScheduledTime(formats strfmt.Registry) error {

	if swag.IsZero(m.CallbackScheduledTime) { // not required
		return nil
	}

	if err := validate.FormatOf("callbackScheduledTime", "body", "date-time", m.CallbackScheduledTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Callback) validateConnectedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.ConnectedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("connectedTime", "body", "date-time", m.ConnectedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Callback) validateDialerPreview(formats strfmt.Registry) error {

	if swag.IsZero(m.DialerPreview) { // not required
		return nil
	}

	if m.DialerPreview != nil {
		if err := m.DialerPreview.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dialerPreview")
			}
			return err
		}
	}

	return nil
}

var callbackTypeDirectionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["inbound","outbound"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		callbackTypeDirectionPropEnum = append(callbackTypeDirectionPropEnum, v)
	}
}

const (

	// CallbackDirectionInbound captures enum value "inbound"
	CallbackDirectionInbound string = "inbound"

	// CallbackDirectionOutbound captures enum value "outbound"
	CallbackDirectionOutbound string = "outbound"
)

// prop value enum
func (m *Callback) validateDirectionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, callbackTypeDirectionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Callback) validateDirection(formats strfmt.Registry) error {

	if swag.IsZero(m.Direction) { // not required
		return nil
	}

	// value enum
	if err := m.validateDirectionEnum("direction", "body", m.Direction); err != nil {
		return err
	}

	return nil
}

var callbackTypeDisconnectTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["endpoint","client","system","timeout","transfer","transfer.conference","transfer.consult","transfer.forward","transfer.noanswer","transfer.notavailable","transport.failure","error","peer","other","spam","uncallable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		callbackTypeDisconnectTypePropEnum = append(callbackTypeDisconnectTypePropEnum, v)
	}
}

const (

	// CallbackDisconnectTypeEndpoint captures enum value "endpoint"
	CallbackDisconnectTypeEndpoint string = "endpoint"

	// CallbackDisconnectTypeClient captures enum value "client"
	CallbackDisconnectTypeClient string = "client"

	// CallbackDisconnectTypeSystem captures enum value "system"
	CallbackDisconnectTypeSystem string = "system"

	// CallbackDisconnectTypeTimeout captures enum value "timeout"
	CallbackDisconnectTypeTimeout string = "timeout"

	// CallbackDisconnectTypeTransfer captures enum value "transfer"
	CallbackDisconnectTypeTransfer string = "transfer"

	// CallbackDisconnectTypeTransferConference captures enum value "transfer.conference"
	CallbackDisconnectTypeTransferConference string = "transfer.conference"

	// CallbackDisconnectTypeTransferConsult captures enum value "transfer.consult"
	CallbackDisconnectTypeTransferConsult string = "transfer.consult"

	// CallbackDisconnectTypeTransferForward captures enum value "transfer.forward"
	CallbackDisconnectTypeTransferForward string = "transfer.forward"

	// CallbackDisconnectTypeTransferNoanswer captures enum value "transfer.noanswer"
	CallbackDisconnectTypeTransferNoanswer string = "transfer.noanswer"

	// CallbackDisconnectTypeTransferNotavailable captures enum value "transfer.notavailable"
	CallbackDisconnectTypeTransferNotavailable string = "transfer.notavailable"

	// CallbackDisconnectTypeTransportFailure captures enum value "transport.failure"
	CallbackDisconnectTypeTransportFailure string = "transport.failure"

	// CallbackDisconnectTypeError captures enum value "error"
	CallbackDisconnectTypeError string = "error"

	// CallbackDisconnectTypePeer captures enum value "peer"
	CallbackDisconnectTypePeer string = "peer"

	// CallbackDisconnectTypeOther captures enum value "other"
	CallbackDisconnectTypeOther string = "other"

	// CallbackDisconnectTypeSpam captures enum value "spam"
	CallbackDisconnectTypeSpam string = "spam"

	// CallbackDisconnectTypeUncallable captures enum value "uncallable"
	CallbackDisconnectTypeUncallable string = "uncallable"
)

// prop value enum
func (m *Callback) validateDisconnectTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, callbackTypeDisconnectTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Callback) validateDisconnectType(formats strfmt.Registry) error {

	if swag.IsZero(m.DisconnectType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDisconnectTypeEnum("disconnectType", "body", m.DisconnectType); err != nil {
		return err
	}

	return nil
}

func (m *Callback) validateDisconnectedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.DisconnectedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("disconnectedTime", "body", "date-time", m.DisconnectedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Callback) validateSegments(formats strfmt.Registry) error {

	if swag.IsZero(m.Segments) { // not required
		return nil
	}

	for i := 0; i < len(m.Segments); i++ {
		if swag.IsZero(m.Segments[i]) { // not required
			continue
		}

		if m.Segments[i] != nil {
			if err := m.Segments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("segments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Callback) validateStartAlertingTime(formats strfmt.Registry) error {

	if swag.IsZero(m.StartAlertingTime) { // not required
		return nil
	}

	if err := validate.FormatOf("startAlertingTime", "body", "date-time", m.StartAlertingTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Callback) validateStartHoldTime(formats strfmt.Registry) error {

	if swag.IsZero(m.StartHoldTime) { // not required
		return nil
	}

	if err := validate.FormatOf("startHoldTime", "body", "date-time", m.StartHoldTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var callbackTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["alerting","dialing","contacting","offering","connected","disconnected","terminated","scheduled","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		callbackTypeStatePropEnum = append(callbackTypeStatePropEnum, v)
	}
}

const (

	// CallbackStateAlerting captures enum value "alerting"
	CallbackStateAlerting string = "alerting"

	// CallbackStateDialing captures enum value "dialing"
	CallbackStateDialing string = "dialing"

	// CallbackStateContacting captures enum value "contacting"
	CallbackStateContacting string = "contacting"

	// CallbackStateOffering captures enum value "offering"
	CallbackStateOffering string = "offering"

	// CallbackStateConnected captures enum value "connected"
	CallbackStateConnected string = "connected"

	// CallbackStateDisconnected captures enum value "disconnected"
	CallbackStateDisconnected string = "disconnected"

	// CallbackStateTerminated captures enum value "terminated"
	CallbackStateTerminated string = "terminated"

	// CallbackStateScheduled captures enum value "scheduled"
	CallbackStateScheduled string = "scheduled"

	// CallbackStateNone captures enum value "none"
	CallbackStateNone string = "none"
)

// prop value enum
func (m *Callback) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, callbackTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Callback) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *Callback) validateVoicemail(formats strfmt.Registry) error {

	if swag.IsZero(m.Voicemail) { // not required
		return nil
	}

	if m.Voicemail != nil {
		if err := m.Voicemail.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("voicemail")
			}
			return err
		}
	}

	return nil
}

func (m *Callback) validateWrapup(formats strfmt.Registry) error {

	if swag.IsZero(m.Wrapup) { // not required
		return nil
	}

	if m.Wrapup != nil {
		if err := m.Wrapup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("wrapup")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Callback) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Callback) UnmarshalBinary(b []byte) error {
	var res Callback
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
