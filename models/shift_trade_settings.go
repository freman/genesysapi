// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ShiftTradeSettings shift trade settings
//
// swagger:model ShiftTradeSettings
type ShiftTradeSettings struct {

	// Rules that specify what to do with activity categories that are part of a shift defined in a trade
	ActivityCategoryRules []*ShiftTradeActivityRule `json:"activityCategoryRules"`

	// Whether direct shift trades between agents are allowed
	AllowDirectTrades bool `json:"allowDirectTrades"`

	// Whether automatic shift trade review is enabled according to the rules defined in for this management unit
	AutoReview bool `json:"autoReview"`

	// Whether shift trading is enabled for this management unit
	Enabled bool `json:"enabled"`

	// The minimum number of hours in the future shift trades are allowed
	MinHoursInFuture int32 `json:"minHoursInFuture,omitempty"`

	// How to handle one-sided shift trades
	// Enum: [Allow Disallow AdminReview]
	OneSided string `json:"oneSided,omitempty"`

	// Whether to constrain shift trades to agents with matching languages
	RequiresMatchingLanguages bool `json:"requiresMatchingLanguages"`

	// Whether to constrain shift trades to agents with matching planning groups
	RequiresMatchingPlanningGroups bool `json:"requiresMatchingPlanningGroups"`

	// Whether to constrain shift trades to agents with matching queues
	RequiresMatchingQueues bool `json:"requiresMatchingQueues"`

	// Whether to constrain shift trades to agents with matching skills
	RequiresMatchingSkills bool `json:"requiresMatchingSkills"`

	// How to handle shift trades which involve unequal paid times
	// Enum: [Allow Disallow AdminReview]
	UnequalPaid string `json:"unequalPaid,omitempty"`

	// How to handle shift trades which result in violations of weekly maximum paid time constraint
	// Enum: [Allow Disallow AdminReview]
	WeeklyMaxPaidViolations string `json:"weeklyMaxPaidViolations,omitempty"`

	// How to handle shift trades which result in violations of weekly minimum paid time constraint
	// Enum: [Allow Disallow AdminReview]
	WeeklyMinPaidViolations string `json:"weeklyMinPaidViolations,omitempty"`
}

// Validate validates this shift trade settings
func (m *ShiftTradeSettings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActivityCategoryRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOneSided(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnequalPaid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeeklyMaxPaidViolations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeeklyMinPaidViolations(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShiftTradeSettings) validateActivityCategoryRules(formats strfmt.Registry) error {
	if swag.IsZero(m.ActivityCategoryRules) { // not required
		return nil
	}

	for i := 0; i < len(m.ActivityCategoryRules); i++ {
		if swag.IsZero(m.ActivityCategoryRules[i]) { // not required
			continue
		}

		if m.ActivityCategoryRules[i] != nil {
			if err := m.ActivityCategoryRules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activityCategoryRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activityCategoryRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var shiftTradeSettingsTypeOneSidedPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Allow","Disallow","AdminReview"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shiftTradeSettingsTypeOneSidedPropEnum = append(shiftTradeSettingsTypeOneSidedPropEnum, v)
	}
}

const (

	// ShiftTradeSettingsOneSidedAllow captures enum value "Allow"
	ShiftTradeSettingsOneSidedAllow string = "Allow"

	// ShiftTradeSettingsOneSidedDisallow captures enum value "Disallow"
	ShiftTradeSettingsOneSidedDisallow string = "Disallow"

	// ShiftTradeSettingsOneSidedAdminReview captures enum value "AdminReview"
	ShiftTradeSettingsOneSidedAdminReview string = "AdminReview"
)

// prop value enum
func (m *ShiftTradeSettings) validateOneSidedEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shiftTradeSettingsTypeOneSidedPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShiftTradeSettings) validateOneSided(formats strfmt.Registry) error {
	if swag.IsZero(m.OneSided) { // not required
		return nil
	}

	// value enum
	if err := m.validateOneSidedEnum("oneSided", "body", m.OneSided); err != nil {
		return err
	}

	return nil
}

var shiftTradeSettingsTypeUnequalPaidPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Allow","Disallow","AdminReview"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shiftTradeSettingsTypeUnequalPaidPropEnum = append(shiftTradeSettingsTypeUnequalPaidPropEnum, v)
	}
}

const (

	// ShiftTradeSettingsUnequalPaidAllow captures enum value "Allow"
	ShiftTradeSettingsUnequalPaidAllow string = "Allow"

	// ShiftTradeSettingsUnequalPaidDisallow captures enum value "Disallow"
	ShiftTradeSettingsUnequalPaidDisallow string = "Disallow"

	// ShiftTradeSettingsUnequalPaidAdminReview captures enum value "AdminReview"
	ShiftTradeSettingsUnequalPaidAdminReview string = "AdminReview"
)

// prop value enum
func (m *ShiftTradeSettings) validateUnequalPaidEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shiftTradeSettingsTypeUnequalPaidPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShiftTradeSettings) validateUnequalPaid(formats strfmt.Registry) error {
	if swag.IsZero(m.UnequalPaid) { // not required
		return nil
	}

	// value enum
	if err := m.validateUnequalPaidEnum("unequalPaid", "body", m.UnequalPaid); err != nil {
		return err
	}

	return nil
}

var shiftTradeSettingsTypeWeeklyMaxPaidViolationsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Allow","Disallow","AdminReview"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shiftTradeSettingsTypeWeeklyMaxPaidViolationsPropEnum = append(shiftTradeSettingsTypeWeeklyMaxPaidViolationsPropEnum, v)
	}
}

const (

	// ShiftTradeSettingsWeeklyMaxPaidViolationsAllow captures enum value "Allow"
	ShiftTradeSettingsWeeklyMaxPaidViolationsAllow string = "Allow"

	// ShiftTradeSettingsWeeklyMaxPaidViolationsDisallow captures enum value "Disallow"
	ShiftTradeSettingsWeeklyMaxPaidViolationsDisallow string = "Disallow"

	// ShiftTradeSettingsWeeklyMaxPaidViolationsAdminReview captures enum value "AdminReview"
	ShiftTradeSettingsWeeklyMaxPaidViolationsAdminReview string = "AdminReview"
)

// prop value enum
func (m *ShiftTradeSettings) validateWeeklyMaxPaidViolationsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shiftTradeSettingsTypeWeeklyMaxPaidViolationsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShiftTradeSettings) validateWeeklyMaxPaidViolations(formats strfmt.Registry) error {
	if swag.IsZero(m.WeeklyMaxPaidViolations) { // not required
		return nil
	}

	// value enum
	if err := m.validateWeeklyMaxPaidViolationsEnum("weeklyMaxPaidViolations", "body", m.WeeklyMaxPaidViolations); err != nil {
		return err
	}

	return nil
}

var shiftTradeSettingsTypeWeeklyMinPaidViolationsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Allow","Disallow","AdminReview"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		shiftTradeSettingsTypeWeeklyMinPaidViolationsPropEnum = append(shiftTradeSettingsTypeWeeklyMinPaidViolationsPropEnum, v)
	}
}

const (

	// ShiftTradeSettingsWeeklyMinPaidViolationsAllow captures enum value "Allow"
	ShiftTradeSettingsWeeklyMinPaidViolationsAllow string = "Allow"

	// ShiftTradeSettingsWeeklyMinPaidViolationsDisallow captures enum value "Disallow"
	ShiftTradeSettingsWeeklyMinPaidViolationsDisallow string = "Disallow"

	// ShiftTradeSettingsWeeklyMinPaidViolationsAdminReview captures enum value "AdminReview"
	ShiftTradeSettingsWeeklyMinPaidViolationsAdminReview string = "AdminReview"
)

// prop value enum
func (m *ShiftTradeSettings) validateWeeklyMinPaidViolationsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, shiftTradeSettingsTypeWeeklyMinPaidViolationsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ShiftTradeSettings) validateWeeklyMinPaidViolations(formats strfmt.Registry) error {
	if swag.IsZero(m.WeeklyMinPaidViolations) { // not required
		return nil
	}

	// value enum
	if err := m.validateWeeklyMinPaidViolationsEnum("weeklyMinPaidViolations", "body", m.WeeklyMinPaidViolations); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this shift trade settings based on the context it is used
func (m *ShiftTradeSettings) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateActivityCategoryRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ShiftTradeSettings) contextValidateActivityCategoryRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ActivityCategoryRules); i++ {

		if m.ActivityCategoryRules[i] != nil {
			if err := m.ActivityCategoryRules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activityCategoryRules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("activityCategoryRules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ShiftTradeSettings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ShiftTradeSettings) UnmarshalBinary(b []byte) error {
	var res ShiftTradeSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
