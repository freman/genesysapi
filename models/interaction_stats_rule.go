// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// InteractionStatsRule interaction stats rule
//
// swagger:model InteractionStatsRule
type InteractionStatsRule struct {

	// A collection of notification methods.
	// Required: true
	// Unique: true
	AlertTypes []string `json:"alertTypes"`

	// The dimension of concern.
	// Required: true
	// Enum: [queueId userId]
	Dimension *string `json:"dimension"`

	// The value of the dimension.
	// Required: true
	DimensionValue *string `json:"dimensionValue"`

	// Indicates if the rule is enabled.
	// Required: true
	Enabled *bool `json:"enabled"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// Indicates if the rule is in alarm state.
	// Read Only: true
	InAlarm *bool `json:"inAlarm,omitempty"`

	// The media type.
	// Required: true
	// Enum: [voice chat email callback message]
	MediaType *string `json:"mediaType"`

	// The metric to be assessed.
	// Required: true
	// Enum: [tAbandon tAnswered tTalk nOffered tHandle nTransferred oServiceLevel tWait tHeld tAcw]
	Metric *string `json:"metric"`

	// Name of the rule
	// Required: true
	Name *string `json:"name"`

	// The ids of users who will be notified of alarm state change.
	// Required: true
	// Unique: true
	NotificationUsers []*User `json:"notificationUsers"`

	// The comparison descriptor used against the metric's value.
	// Required: true
	// Enum: [gt gte lt lte eq ne]
	NumericRange *string `json:"numericRange"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// The statistic of concern for the metric.
	// Required: true
	// Enum: [count min ratio max]
	Statistic *string `json:"statistic"`

	// The threshold value.
	// Required: true
	Value *float64 `json:"value"`
}

// Validate validates this interaction stats rule
func (m *InteractionStatsRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDimension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDimensionValue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMediaType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotificationUsers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumericRange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatistic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var interactionStatsRuleAlertTypesItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SMS","DEVICE","EMAIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		interactionStatsRuleAlertTypesItemsEnum = append(interactionStatsRuleAlertTypesItemsEnum, v)
	}
}

func (m *InteractionStatsRule) validateAlertTypesItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, interactionStatsRuleAlertTypesItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InteractionStatsRule) validateAlertTypes(formats strfmt.Registry) error {

	if err := validate.Required("alertTypes", "body", m.AlertTypes); err != nil {
		return err
	}

	if err := validate.UniqueItems("alertTypes", "body", m.AlertTypes); err != nil {
		return err
	}

	for i := 0; i < len(m.AlertTypes); i++ {

		// value enum
		if err := m.validateAlertTypesItemsEnum("alertTypes"+"."+strconv.Itoa(i), "body", m.AlertTypes[i]); err != nil {
			return err
		}

	}

	return nil
}

var interactionStatsRuleTypeDimensionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["queueId","userId"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		interactionStatsRuleTypeDimensionPropEnum = append(interactionStatsRuleTypeDimensionPropEnum, v)
	}
}

const (

	// InteractionStatsRuleDimensionQueueID captures enum value "queueId"
	InteractionStatsRuleDimensionQueueID string = "queueId"

	// InteractionStatsRuleDimensionUserID captures enum value "userId"
	InteractionStatsRuleDimensionUserID string = "userId"
)

// prop value enum
func (m *InteractionStatsRule) validateDimensionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, interactionStatsRuleTypeDimensionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InteractionStatsRule) validateDimension(formats strfmt.Registry) error {

	if err := validate.Required("dimension", "body", m.Dimension); err != nil {
		return err
	}

	// value enum
	if err := m.validateDimensionEnum("dimension", "body", *m.Dimension); err != nil {
		return err
	}

	return nil
}

func (m *InteractionStatsRule) validateDimensionValue(formats strfmt.Registry) error {

	if err := validate.Required("dimensionValue", "body", m.DimensionValue); err != nil {
		return err
	}

	return nil
}

func (m *InteractionStatsRule) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

var interactionStatsRuleTypeMediaTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["voice","chat","email","callback","message"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		interactionStatsRuleTypeMediaTypePropEnum = append(interactionStatsRuleTypeMediaTypePropEnum, v)
	}
}

const (

	// InteractionStatsRuleMediaTypeVoice captures enum value "voice"
	InteractionStatsRuleMediaTypeVoice string = "voice"

	// InteractionStatsRuleMediaTypeChat captures enum value "chat"
	InteractionStatsRuleMediaTypeChat string = "chat"

	// InteractionStatsRuleMediaTypeEmail captures enum value "email"
	InteractionStatsRuleMediaTypeEmail string = "email"

	// InteractionStatsRuleMediaTypeCallback captures enum value "callback"
	InteractionStatsRuleMediaTypeCallback string = "callback"

	// InteractionStatsRuleMediaTypeMessage captures enum value "message"
	InteractionStatsRuleMediaTypeMessage string = "message"
)

// prop value enum
func (m *InteractionStatsRule) validateMediaTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, interactionStatsRuleTypeMediaTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InteractionStatsRule) validateMediaType(formats strfmt.Registry) error {

	if err := validate.Required("mediaType", "body", m.MediaType); err != nil {
		return err
	}

	// value enum
	if err := m.validateMediaTypeEnum("mediaType", "body", *m.MediaType); err != nil {
		return err
	}

	return nil
}

var interactionStatsRuleTypeMetricPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["tAbandon","tAnswered","tTalk","nOffered","tHandle","nTransferred","oServiceLevel","tWait","tHeld","tAcw"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		interactionStatsRuleTypeMetricPropEnum = append(interactionStatsRuleTypeMetricPropEnum, v)
	}
}

const (

	// InteractionStatsRuleMetricTAbandon captures enum value "tAbandon"
	InteractionStatsRuleMetricTAbandon string = "tAbandon"

	// InteractionStatsRuleMetricTAnswered captures enum value "tAnswered"
	InteractionStatsRuleMetricTAnswered string = "tAnswered"

	// InteractionStatsRuleMetricTTalk captures enum value "tTalk"
	InteractionStatsRuleMetricTTalk string = "tTalk"

	// InteractionStatsRuleMetricNOffered captures enum value "nOffered"
	InteractionStatsRuleMetricNOffered string = "nOffered"

	// InteractionStatsRuleMetricTHandle captures enum value "tHandle"
	InteractionStatsRuleMetricTHandle string = "tHandle"

	// InteractionStatsRuleMetricNTransferred captures enum value "nTransferred"
	InteractionStatsRuleMetricNTransferred string = "nTransferred"

	// InteractionStatsRuleMetricOServiceLevel captures enum value "oServiceLevel"
	InteractionStatsRuleMetricOServiceLevel string = "oServiceLevel"

	// InteractionStatsRuleMetricTWait captures enum value "tWait"
	InteractionStatsRuleMetricTWait string = "tWait"

	// InteractionStatsRuleMetricTHeld captures enum value "tHeld"
	InteractionStatsRuleMetricTHeld string = "tHeld"

	// InteractionStatsRuleMetricTAcw captures enum value "tAcw"
	InteractionStatsRuleMetricTAcw string = "tAcw"
)

// prop value enum
func (m *InteractionStatsRule) validateMetricEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, interactionStatsRuleTypeMetricPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InteractionStatsRule) validateMetric(formats strfmt.Registry) error {

	if err := validate.Required("metric", "body", m.Metric); err != nil {
		return err
	}

	// value enum
	if err := m.validateMetricEnum("metric", "body", *m.Metric); err != nil {
		return err
	}

	return nil
}

func (m *InteractionStatsRule) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *InteractionStatsRule) validateNotificationUsers(formats strfmt.Registry) error {

	if err := validate.Required("notificationUsers", "body", m.NotificationUsers); err != nil {
		return err
	}

	if err := validate.UniqueItems("notificationUsers", "body", m.NotificationUsers); err != nil {
		return err
	}

	for i := 0; i < len(m.NotificationUsers); i++ {
		if swag.IsZero(m.NotificationUsers[i]) { // not required
			continue
		}

		if m.NotificationUsers[i] != nil {
			if err := m.NotificationUsers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("notificationUsers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var interactionStatsRuleTypeNumericRangePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["gt","gte","lt","lte","eq","ne"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		interactionStatsRuleTypeNumericRangePropEnum = append(interactionStatsRuleTypeNumericRangePropEnum, v)
	}
}

const (

	// InteractionStatsRuleNumericRangeGt captures enum value "gt"
	InteractionStatsRuleNumericRangeGt string = "gt"

	// InteractionStatsRuleNumericRangeGte captures enum value "gte"
	InteractionStatsRuleNumericRangeGte string = "gte"

	// InteractionStatsRuleNumericRangeLt captures enum value "lt"
	InteractionStatsRuleNumericRangeLt string = "lt"

	// InteractionStatsRuleNumericRangeLte captures enum value "lte"
	InteractionStatsRuleNumericRangeLte string = "lte"

	// InteractionStatsRuleNumericRangeEq captures enum value "eq"
	InteractionStatsRuleNumericRangeEq string = "eq"

	// InteractionStatsRuleNumericRangeNe captures enum value "ne"
	InteractionStatsRuleNumericRangeNe string = "ne"
)

// prop value enum
func (m *InteractionStatsRule) validateNumericRangeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, interactionStatsRuleTypeNumericRangePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InteractionStatsRule) validateNumericRange(formats strfmt.Registry) error {

	if err := validate.Required("numericRange", "body", m.NumericRange); err != nil {
		return err
	}

	// value enum
	if err := m.validateNumericRangeEnum("numericRange", "body", *m.NumericRange); err != nil {
		return err
	}

	return nil
}

func (m *InteractionStatsRule) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

var interactionStatsRuleTypeStatisticPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["count","min","ratio","max"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		interactionStatsRuleTypeStatisticPropEnum = append(interactionStatsRuleTypeStatisticPropEnum, v)
	}
}

const (

	// InteractionStatsRuleStatisticCount captures enum value "count"
	InteractionStatsRuleStatisticCount string = "count"

	// InteractionStatsRuleStatisticMin captures enum value "min"
	InteractionStatsRuleStatisticMin string = "min"

	// InteractionStatsRuleStatisticRatio captures enum value "ratio"
	InteractionStatsRuleStatisticRatio string = "ratio"

	// InteractionStatsRuleStatisticMax captures enum value "max"
	InteractionStatsRuleStatisticMax string = "max"
)

// prop value enum
func (m *InteractionStatsRule) validateStatisticEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, interactionStatsRuleTypeStatisticPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *InteractionStatsRule) validateStatistic(formats strfmt.Registry) error {

	if err := validate.Required("statistic", "body", m.Statistic); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatisticEnum("statistic", "body", *m.Statistic); err != nil {
		return err
	}

	return nil
}

func (m *InteractionStatsRule) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *InteractionStatsRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *InteractionStatsRule) UnmarshalBinary(b []byte) error {
	var res InteractionStatsRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
