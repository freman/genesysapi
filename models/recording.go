// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Recording recording
//
// swagger:model Recording
type Recording struct {

	// actual transcode time ms
	ActualTranscodeTimeMs int64 `json:"actualTranscodeTimeMs,omitempty"`

	// Annotations that belong to the recording.
	Annotations []*Annotation `json:"annotations"`

	// The date the recording will be archived. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ArchiveDate strfmt.DateTime `json:"archiveDate,omitempty"`

	// The type of archive medium used. Example: CloudArchive
	// Enum: [CLOUDARCHIVE]
	ArchiveMedium string `json:"archiveMedium,omitempty"`

	// conversation Id
	ConversationID string `json:"conversationId,omitempty"`

	// The creation time of the recording. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	CreationTime strfmt.DateTime `json:"creationTime,omitempty"`

	// The date the recording will be deleted. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	DeleteDate strfmt.DateTime `json:"deleteDate,omitempty"`

	// Represents an email transcript
	EmailTranscript []*RecordingEmailMessage `json:"emailTranscript"`

	// The end time of the recording. Null when there is no playable media.
	EndTime string `json:"endTime,omitempty"`

	// estimated transcode time ms
	EstimatedTranscodeTimeMs int64 `json:"estimatedTranscodeTimeMs,omitempty"`

	// The date the recording will be exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ExportDate strfmt.DateTime `json:"exportDate,omitempty"`

	// The date the recording was exported. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ExportedDate strfmt.DateTime `json:"exportedDate,omitempty"`

	// Represents the current file state for a recording. Examples: Uploading, Archived, etc
	// Enum: [ARCHIVED AVAILABLE DELETED RESTORED RESTORING UPLOADING ERROR]
	FileState string `json:"fileState,omitempty"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// How many archive restorations the organization is allowed to have.
	MaxAllowedRestorationsForOrg int32 `json:"maxAllowedRestorationsForOrg,omitempty"`

	// The type of media that the recording is. At the moment that could be audio, chat, or email.
	Media string `json:"media,omitempty"`

	// The different mediaUris for the recording. Null when there is no playable media.
	MediaUris map[string]MediaResult `json:"mediaUris,omitempty"`

	// Represents a messaging transcript
	MessagingTranscript []*RecordingMessagingMessage `json:"messagingTranscript"`

	// name
	Name string `json:"name,omitempty"`

	// The start time of the full recording, before any segment access restrictions are applied. Null when there is no playable media. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	OriginalRecordingStartTime strfmt.DateTime `json:"originalRecordingStartTime,omitempty"`

	// Duration of transcoded media in milliseconds
	OutputDurationMs int32 `json:"outputDurationMs,omitempty"`

	// Size of transcoded media in bytes. 0 if there is no transcoded media.
	OutputSizeInBytes int32 `json:"outputSizeInBytes,omitempty"`

	// path
	Path string `json:"path,omitempty"`

	// Status of a recording that cannot be returned because of an error
	// Enum: [EMAIL_TRANSCRIPT_TOO_LARGE]
	RecordingErrorStatus string `json:"recordingErrorStatus,omitempty"`

	// Role of the file recording. It can be either customer_experience or adhoc.
	// Enum: [CUSTOMER_EXPERIENCE ADHOC]
	RecordingFileRole string `json:"recordingFileRole,omitempty"`

	// The remaining archive restorations the organization has.
	RemainingRestorationsAllowedForOrg int32 `json:"remainingRestorationsAllowedForOrg,omitempty"`

	// The amount of time a restored recording will remain restored before being archived again. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	RestoreExpirationTime strfmt.DateTime `json:"restoreExpirationTime,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// The session id represents an external resource id, such as email, call, chat, etc
	SessionID string `json:"sessionId,omitempty"`

	// The start time of the recording. Null when there is no playable media.
	StartTime string `json:"startTime,omitempty"`

	// Represents a chat transcript
	Transcript []*ChatMessage `json:"transcript"`

	// The users participating in the conversation
	Users []*User `json:"users"`
}

// Validate validates this recording
func (m *Recording) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAnnotations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArchiveMedium(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeleteDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailTranscript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExportDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExportedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMediaUris(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMessagingTranscript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginalRecordingStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecordingErrorStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRecordingFileRole(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestoreExpirationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTranscript(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Recording) validateAnnotations(formats strfmt.Registry) error {

	if swag.IsZero(m.Annotations) { // not required
		return nil
	}

	for i := 0; i < len(m.Annotations); i++ {
		if swag.IsZero(m.Annotations[i]) { // not required
			continue
		}

		if m.Annotations[i] != nil {
			if err := m.Annotations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("annotations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Recording) validateArchiveDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ArchiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("archiveDate", "body", "date-time", m.ArchiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var recordingTypeArchiveMediumPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CLOUDARCHIVE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordingTypeArchiveMediumPropEnum = append(recordingTypeArchiveMediumPropEnum, v)
	}
}

const (

	// RecordingArchiveMediumCLOUDARCHIVE captures enum value "CLOUDARCHIVE"
	RecordingArchiveMediumCLOUDARCHIVE string = "CLOUDARCHIVE"
)

// prop value enum
func (m *Recording) validateArchiveMediumEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordingTypeArchiveMediumPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Recording) validateArchiveMedium(formats strfmt.Registry) error {

	if swag.IsZero(m.ArchiveMedium) { // not required
		return nil
	}

	// value enum
	if err := m.validateArchiveMediumEnum("archiveMedium", "body", m.ArchiveMedium); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateCreationTime(formats strfmt.Registry) error {

	if swag.IsZero(m.CreationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("creationTime", "body", "date-time", m.CreationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateDeleteDate(formats strfmt.Registry) error {

	if swag.IsZero(m.DeleteDate) { // not required
		return nil
	}

	if err := validate.FormatOf("deleteDate", "body", "date-time", m.DeleteDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateEmailTranscript(formats strfmt.Registry) error {

	if swag.IsZero(m.EmailTranscript) { // not required
		return nil
	}

	for i := 0; i < len(m.EmailTranscript); i++ {
		if swag.IsZero(m.EmailTranscript[i]) { // not required
			continue
		}

		if m.EmailTranscript[i] != nil {
			if err := m.EmailTranscript[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("emailTranscript" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Recording) validateExportDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ExportDate) { // not required
		return nil
	}

	if err := validate.FormatOf("exportDate", "body", "date-time", m.ExportDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateExportedDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ExportedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("exportedDate", "body", "date-time", m.ExportedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var recordingTypeFileStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ARCHIVED","AVAILABLE","DELETED","RESTORED","RESTORING","UPLOADING","ERROR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordingTypeFileStatePropEnum = append(recordingTypeFileStatePropEnum, v)
	}
}

const (

	// RecordingFileStateARCHIVED captures enum value "ARCHIVED"
	RecordingFileStateARCHIVED string = "ARCHIVED"

	// RecordingFileStateAVAILABLE captures enum value "AVAILABLE"
	RecordingFileStateAVAILABLE string = "AVAILABLE"

	// RecordingFileStateDELETED captures enum value "DELETED"
	RecordingFileStateDELETED string = "DELETED"

	// RecordingFileStateRESTORED captures enum value "RESTORED"
	RecordingFileStateRESTORED string = "RESTORED"

	// RecordingFileStateRESTORING captures enum value "RESTORING"
	RecordingFileStateRESTORING string = "RESTORING"

	// RecordingFileStateUPLOADING captures enum value "UPLOADING"
	RecordingFileStateUPLOADING string = "UPLOADING"

	// RecordingFileStateERROR captures enum value "ERROR"
	RecordingFileStateERROR string = "ERROR"
)

// prop value enum
func (m *Recording) validateFileStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordingTypeFileStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Recording) validateFileState(formats strfmt.Registry) error {

	if swag.IsZero(m.FileState) { // not required
		return nil
	}

	// value enum
	if err := m.validateFileStateEnum("fileState", "body", m.FileState); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateMediaUris(formats strfmt.Registry) error {

	if swag.IsZero(m.MediaUris) { // not required
		return nil
	}

	for k := range m.MediaUris {

		if err := validate.Required("mediaUris"+"."+k, "body", m.MediaUris[k]); err != nil {
			return err
		}
		if val, ok := m.MediaUris[k]; ok {
			if err := val.Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *Recording) validateMessagingTranscript(formats strfmt.Registry) error {

	if swag.IsZero(m.MessagingTranscript) { // not required
		return nil
	}

	for i := 0; i < len(m.MessagingTranscript); i++ {
		if swag.IsZero(m.MessagingTranscript[i]) { // not required
			continue
		}

		if m.MessagingTranscript[i] != nil {
			if err := m.MessagingTranscript[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("messagingTranscript" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Recording) validateOriginalRecordingStartTime(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginalRecordingStartTime) { // not required
		return nil
	}

	if err := validate.FormatOf("originalRecordingStartTime", "body", "date-time", m.OriginalRecordingStartTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var recordingTypeRecordingErrorStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EMAIL_TRANSCRIPT_TOO_LARGE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordingTypeRecordingErrorStatusPropEnum = append(recordingTypeRecordingErrorStatusPropEnum, v)
	}
}

const (

	// RecordingRecordingErrorStatusEMAILTRANSCRIPTTOOLARGE captures enum value "EMAIL_TRANSCRIPT_TOO_LARGE"
	RecordingRecordingErrorStatusEMAILTRANSCRIPTTOOLARGE string = "EMAIL_TRANSCRIPT_TOO_LARGE"
)

// prop value enum
func (m *Recording) validateRecordingErrorStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordingTypeRecordingErrorStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Recording) validateRecordingErrorStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.RecordingErrorStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecordingErrorStatusEnum("recordingErrorStatus", "body", m.RecordingErrorStatus); err != nil {
		return err
	}

	return nil
}

var recordingTypeRecordingFileRolePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CUSTOMER_EXPERIENCE","ADHOC"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordingTypeRecordingFileRolePropEnum = append(recordingTypeRecordingFileRolePropEnum, v)
	}
}

const (

	// RecordingRecordingFileRoleCUSTOMEREXPERIENCE captures enum value "CUSTOMER_EXPERIENCE"
	RecordingRecordingFileRoleCUSTOMEREXPERIENCE string = "CUSTOMER_EXPERIENCE"

	// RecordingRecordingFileRoleADHOC captures enum value "ADHOC"
	RecordingRecordingFileRoleADHOC string = "ADHOC"
)

// prop value enum
func (m *Recording) validateRecordingFileRoleEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordingTypeRecordingFileRolePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Recording) validateRecordingFileRole(formats strfmt.Registry) error {

	if swag.IsZero(m.RecordingFileRole) { // not required
		return nil
	}

	// value enum
	if err := m.validateRecordingFileRoleEnum("recordingFileRole", "body", m.RecordingFileRole); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateRestoreExpirationTime(formats strfmt.Registry) error {

	if swag.IsZero(m.RestoreExpirationTime) { // not required
		return nil
	}

	if err := validate.FormatOf("restoreExpirationTime", "body", "date-time", m.RestoreExpirationTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Recording) validateTranscript(formats strfmt.Registry) error {

	if swag.IsZero(m.Transcript) { // not required
		return nil
	}

	for i := 0; i < len(m.Transcript); i++ {
		if swag.IsZero(m.Transcript[i]) { // not required
			continue
		}

		if m.Transcript[i] != nil {
			if err := m.Transcript[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("transcript" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Recording) validateUsers(formats strfmt.Registry) error {

	if swag.IsZero(m.Users) { // not required
		return nil
	}

	for i := 0; i < len(m.Users); i++ {
		if swag.IsZero(m.Users[i]) { // not required
			continue
		}

		if m.Users[i] != nil {
			if err := m.Users[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("users" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Recording) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Recording) UnmarshalBinary(b []byte) error {
	var res Recording
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
