// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TrusteeBillingOverview trustee billing overview
//
// swagger:model TrusteeBillingOverview
type TrusteeBillingOverview struct {

	// Date-time the billing period ended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	BillingPeriodEndDate strfmt.DateTime `json:"billingPeriodEndDate,omitempty"`

	// Date-time the billing period started. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	BillingPeriodStartDate strfmt.DateTime `json:"billingPeriodStartDate,omitempty"`

	// Date-time the contract was last amended. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ContractAmendmentDate strfmt.DateTime `json:"contractAmendmentDate,omitempty"`

	// Date-time the contract became effective. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ContractEffectiveDate strfmt.DateTime `json:"contractEffectiveDate,omitempty"`

	// Date-time the contract ends. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ContractEndDate strfmt.DateTime `json:"contractEndDate,omitempty"`

	// The currency type.
	// Required: true
	Currency *string `json:"currency"`

	// The charge short names for products enabled during the specified period.
	// Required: true
	EnabledProducts []string `json:"enabledProducts"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// in ramp period
	InRampPeriod bool `json:"inRampPeriod"`

	// Minimum amount that will be charged for the month
	MinimumMonthlyAmount string `json:"minimumMonthlyAmount,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// Organization
	// Required: true
	Organization *NamedEntity `json:"organization"`

	// Date-time the ramp period ends. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	RampPeriodEndDate strfmt.DateTime `json:"rampPeriodEndDate,omitempty"`

	// Date-time the ramp period starts. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	RampPeriodStartDate strfmt.DateTime `json:"rampPeriodStartDate,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// The subscription type.
	// Required: true
	// Enum: [ININ MONTH_TO_MONTH FREE_TRIAL_MONTH_TO_MONTH PREPAY_MONTHLY_COMMITMENT PREPAY DEV_ORG_MONTH_TO_MONTH DEV_ORG_PREPAY_MONTHLY_COMMITMENT DEV_ORG_PREPAY]
	SubscriptionType *string `json:"subscriptionType"`

	// Usages for the specified period.
	// Required: true
	Usages []*SubscriptionOverviewUsage `json:"usages"`
}

// Validate validates this trustee billing overview
func (m *TrusteeBillingOverview) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBillingPeriodEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillingPeriodStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContractAmendmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContractEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContractEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabledProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRampPeriodEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRampPeriodStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubscriptionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsages(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TrusteeBillingOverview) validateBillingPeriodEndDate(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingPeriodEndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("billingPeriodEndDate", "body", "date-time", m.BillingPeriodEndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateBillingPeriodStartDate(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingPeriodStartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("billingPeriodStartDate", "body", "date-time", m.BillingPeriodStartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateContractAmendmentDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ContractAmendmentDate) { // not required
		return nil
	}

	if err := validate.FormatOf("contractAmendmentDate", "body", "date-time", m.ContractAmendmentDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateContractEffectiveDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ContractEffectiveDate) { // not required
		return nil
	}

	if err := validate.FormatOf("contractEffectiveDate", "body", "date-time", m.ContractEffectiveDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateContractEndDate(formats strfmt.Registry) error {

	if swag.IsZero(m.ContractEndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("contractEndDate", "body", "date-time", m.ContractEndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", m.Currency); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateEnabledProducts(formats strfmt.Registry) error {

	if err := validate.Required("enabledProducts", "body", m.EnabledProducts); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateOrganization(formats strfmt.Registry) error {

	if err := validate.Required("organization", "body", m.Organization); err != nil {
		return err
	}

	if m.Organization != nil {
		if err := m.Organization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("organization")
			}
			return err
		}
	}

	return nil
}

func (m *TrusteeBillingOverview) validateRampPeriodEndDate(formats strfmt.Registry) error {

	if swag.IsZero(m.RampPeriodEndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("rampPeriodEndDate", "body", "date-time", m.RampPeriodEndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateRampPeriodStartDate(formats strfmt.Registry) error {

	if swag.IsZero(m.RampPeriodStartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("rampPeriodStartDate", "body", "date-time", m.RampPeriodStartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

var trusteeBillingOverviewTypeSubscriptionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ININ","MONTH_TO_MONTH","FREE_TRIAL_MONTH_TO_MONTH","PREPAY_MONTHLY_COMMITMENT","PREPAY","DEV_ORG_MONTH_TO_MONTH","DEV_ORG_PREPAY_MONTHLY_COMMITMENT","DEV_ORG_PREPAY"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		trusteeBillingOverviewTypeSubscriptionTypePropEnum = append(trusteeBillingOverviewTypeSubscriptionTypePropEnum, v)
	}
}

const (

	// TrusteeBillingOverviewSubscriptionTypeININ captures enum value "ININ"
	TrusteeBillingOverviewSubscriptionTypeININ string = "ININ"

	// TrusteeBillingOverviewSubscriptionTypeMONTHTOMONTH captures enum value "MONTH_TO_MONTH"
	TrusteeBillingOverviewSubscriptionTypeMONTHTOMONTH string = "MONTH_TO_MONTH"

	// TrusteeBillingOverviewSubscriptionTypeFREETRIALMONTHTOMONTH captures enum value "FREE_TRIAL_MONTH_TO_MONTH"
	TrusteeBillingOverviewSubscriptionTypeFREETRIALMONTHTOMONTH string = "FREE_TRIAL_MONTH_TO_MONTH"

	// TrusteeBillingOverviewSubscriptionTypePREPAYMONTHLYCOMMITMENT captures enum value "PREPAY_MONTHLY_COMMITMENT"
	TrusteeBillingOverviewSubscriptionTypePREPAYMONTHLYCOMMITMENT string = "PREPAY_MONTHLY_COMMITMENT"

	// TrusteeBillingOverviewSubscriptionTypePREPAY captures enum value "PREPAY"
	TrusteeBillingOverviewSubscriptionTypePREPAY string = "PREPAY"

	// TrusteeBillingOverviewSubscriptionTypeDEVORGMONTHTOMONTH captures enum value "DEV_ORG_MONTH_TO_MONTH"
	TrusteeBillingOverviewSubscriptionTypeDEVORGMONTHTOMONTH string = "DEV_ORG_MONTH_TO_MONTH"

	// TrusteeBillingOverviewSubscriptionTypeDEVORGPREPAYMONTHLYCOMMITMENT captures enum value "DEV_ORG_PREPAY_MONTHLY_COMMITMENT"
	TrusteeBillingOverviewSubscriptionTypeDEVORGPREPAYMONTHLYCOMMITMENT string = "DEV_ORG_PREPAY_MONTHLY_COMMITMENT"

	// TrusteeBillingOverviewSubscriptionTypeDEVORGPREPAY captures enum value "DEV_ORG_PREPAY"
	TrusteeBillingOverviewSubscriptionTypeDEVORGPREPAY string = "DEV_ORG_PREPAY"
)

// prop value enum
func (m *TrusteeBillingOverview) validateSubscriptionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, trusteeBillingOverviewTypeSubscriptionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TrusteeBillingOverview) validateSubscriptionType(formats strfmt.Registry) error {

	if err := validate.Required("subscriptionType", "body", m.SubscriptionType); err != nil {
		return err
	}

	// value enum
	if err := m.validateSubscriptionTypeEnum("subscriptionType", "body", *m.SubscriptionType); err != nil {
		return err
	}

	return nil
}

func (m *TrusteeBillingOverview) validateUsages(formats strfmt.Registry) error {

	if err := validate.Required("usages", "body", m.Usages); err != nil {
		return err
	}

	for i := 0; i < len(m.Usages); i++ {
		if swag.IsZero(m.Usages[i]) { // not required
			continue
		}

		if m.Usages[i] != nil {
			if err := m.Usages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("usages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TrusteeBillingOverview) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TrusteeBillingOverview) UnmarshalBinary(b []byte) error {
	var res TrusteeBillingOverview
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
