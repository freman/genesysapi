// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserScheduleAdherence user schedule adherence
//
// swagger:model UserScheduleAdherence
type UserScheduleAdherence struct {

	// The list of queues to which this user is joined
	// Read Only: true
	ActiveQueues []*QueueReference `json:"activeQueues"`

	// Time when the list of active queues for this user was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Read Only: true
	// Format: date-time
	ActiveQueuesModifiedTime strfmt.DateTime `json:"activeQueuesModifiedTime,omitempty"`

	// Activity in which the user is actually engaged
	// Read Only: true
	// Enum: [OnQueueWork Break Meal Meeting OffQueueWork TimeOff Training Unavailable Unscheduled]
	ActualActivityCategory string `json:"actualActivityCategory,omitempty"`

	// The user's current adherence state
	// Read Only: true
	// Enum: [InAdherence OutOfAdherence Unscheduled Unknown Ignored]
	AdherenceState string `json:"adherenceState,omitempty"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The impact of the user's current adherenceState
	// Read Only: true
	// Enum: [Positive Negative Neutral Unknown]
	Impact string `json:"impact,omitempty"`

	// Whether the user is marked OutOfOffice
	// Read Only: true
	IsOutOfOffice *bool `json:"isOutOfOffice"`

	// The management unit to which this user belongs
	// Read Only: true
	ManagementUnit *ManagementUnit `json:"managementUnit,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// Organization Secondary Presence Id.
	// Read Only: true
	OrganizationSecondaryPresenceID string `json:"organizationSecondaryPresenceId,omitempty"`

	// Time when presence was last updated.  Used to calculate time in current status. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Read Only: true
	// Format: date-time
	PresenceUpdateTime strfmt.DateTime `json:"presenceUpdateTime,omitempty"`

	// For notification purposes. Used to indicate that a user was removed from the management unit
	// Read Only: true
	RemovedFromManagementUnit *bool `json:"removedFromManagementUnit"`

	// Actual underlying routing status, used to determine whether a user is actually in adherence when OnQueue
	// Read Only: true
	// Enum: [OFF_QUEUE IDLE INTERACTING NOT_RESPONDING COMMUNICATING]
	RoutingStatus string `json:"routingStatus,omitempty"`

	// Activity for which the user is scheduled
	// Read Only: true
	// Enum: [OnQueueWork Break Meal Meeting OffQueueWork TimeOff Training Unavailable Unscheduled]
	ScheduledActivityCategory string `json:"scheduledActivityCategory,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// Actual underlying system presence value
	// Read Only: true
	// Enum: [Available Away Busy Offline Idle OnQueue Meal Training Meeting Break]
	SystemPresence string `json:"systemPresence,omitempty"`

	// The team to which this user belongs
	// Read Only: true
	Team *Team `json:"team,omitempty"`

	// Time when the user entered the current adherenceState in ISO-8601 format
	// Read Only: true
	// Format: date-time
	TimeOfAdherenceChange strfmt.DateTime `json:"timeOfAdherenceChange,omitempty"`

	// The user for whom this status applies
	// Read Only: true
	User *UserReference `json:"user,omitempty"`
}

// Validate validates this user schedule adherence
func (m *UserScheduleAdherence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActiveQueues(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActiveQueuesModifiedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActualActivityCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdherenceState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImpact(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManagementUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePresenceUpdateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutingStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduledActivityCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSystemPresence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimeOfAdherenceChange(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUser(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserScheduleAdherence) validateActiveQueues(formats strfmt.Registry) error {

	if swag.IsZero(m.ActiveQueues) { // not required
		return nil
	}

	for i := 0; i < len(m.ActiveQueues); i++ {
		if swag.IsZero(m.ActiveQueues[i]) { // not required
			continue
		}

		if m.ActiveQueues[i] != nil {
			if err := m.ActiveQueues[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activeQueues" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserScheduleAdherence) validateActiveQueuesModifiedTime(formats strfmt.Registry) error {

	if swag.IsZero(m.ActiveQueuesModifiedTime) { // not required
		return nil
	}

	if err := validate.FormatOf("activeQueuesModifiedTime", "body", "date-time", m.ActiveQueuesModifiedTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var userScheduleAdherenceTypeActualActivityCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OnQueueWork","Break","Meal","Meeting","OffQueueWork","TimeOff","Training","Unavailable","Unscheduled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userScheduleAdherenceTypeActualActivityCategoryPropEnum = append(userScheduleAdherenceTypeActualActivityCategoryPropEnum, v)
	}
}

const (

	// UserScheduleAdherenceActualActivityCategoryOnQueueWork captures enum value "OnQueueWork"
	UserScheduleAdherenceActualActivityCategoryOnQueueWork string = "OnQueueWork"

	// UserScheduleAdherenceActualActivityCategoryBreak captures enum value "Break"
	UserScheduleAdherenceActualActivityCategoryBreak string = "Break"

	// UserScheduleAdherenceActualActivityCategoryMeal captures enum value "Meal"
	UserScheduleAdherenceActualActivityCategoryMeal string = "Meal"

	// UserScheduleAdherenceActualActivityCategoryMeeting captures enum value "Meeting"
	UserScheduleAdherenceActualActivityCategoryMeeting string = "Meeting"

	// UserScheduleAdherenceActualActivityCategoryOffQueueWork captures enum value "OffQueueWork"
	UserScheduleAdherenceActualActivityCategoryOffQueueWork string = "OffQueueWork"

	// UserScheduleAdherenceActualActivityCategoryTimeOff captures enum value "TimeOff"
	UserScheduleAdherenceActualActivityCategoryTimeOff string = "TimeOff"

	// UserScheduleAdherenceActualActivityCategoryTraining captures enum value "Training"
	UserScheduleAdherenceActualActivityCategoryTraining string = "Training"

	// UserScheduleAdherenceActualActivityCategoryUnavailable captures enum value "Unavailable"
	UserScheduleAdherenceActualActivityCategoryUnavailable string = "Unavailable"

	// UserScheduleAdherenceActualActivityCategoryUnscheduled captures enum value "Unscheduled"
	UserScheduleAdherenceActualActivityCategoryUnscheduled string = "Unscheduled"
)

// prop value enum
func (m *UserScheduleAdherence) validateActualActivityCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userScheduleAdherenceTypeActualActivityCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserScheduleAdherence) validateActualActivityCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ActualActivityCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateActualActivityCategoryEnum("actualActivityCategory", "body", m.ActualActivityCategory); err != nil {
		return err
	}

	return nil
}

var userScheduleAdherenceTypeAdherenceStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["InAdherence","OutOfAdherence","Unscheduled","Unknown","Ignored"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userScheduleAdherenceTypeAdherenceStatePropEnum = append(userScheduleAdherenceTypeAdherenceStatePropEnum, v)
	}
}

const (

	// UserScheduleAdherenceAdherenceStateInAdherence captures enum value "InAdherence"
	UserScheduleAdherenceAdherenceStateInAdherence string = "InAdherence"

	// UserScheduleAdherenceAdherenceStateOutOfAdherence captures enum value "OutOfAdherence"
	UserScheduleAdherenceAdherenceStateOutOfAdherence string = "OutOfAdherence"

	// UserScheduleAdherenceAdherenceStateUnscheduled captures enum value "Unscheduled"
	UserScheduleAdherenceAdherenceStateUnscheduled string = "Unscheduled"

	// UserScheduleAdherenceAdherenceStateUnknown captures enum value "Unknown"
	UserScheduleAdherenceAdherenceStateUnknown string = "Unknown"

	// UserScheduleAdherenceAdherenceStateIgnored captures enum value "Ignored"
	UserScheduleAdherenceAdherenceStateIgnored string = "Ignored"
)

// prop value enum
func (m *UserScheduleAdherence) validateAdherenceStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userScheduleAdherenceTypeAdherenceStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserScheduleAdherence) validateAdherenceState(formats strfmt.Registry) error {

	if swag.IsZero(m.AdherenceState) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdherenceStateEnum("adherenceState", "body", m.AdherenceState); err != nil {
		return err
	}

	return nil
}

var userScheduleAdherenceTypeImpactPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Positive","Negative","Neutral","Unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userScheduleAdherenceTypeImpactPropEnum = append(userScheduleAdherenceTypeImpactPropEnum, v)
	}
}

const (

	// UserScheduleAdherenceImpactPositive captures enum value "Positive"
	UserScheduleAdherenceImpactPositive string = "Positive"

	// UserScheduleAdherenceImpactNegative captures enum value "Negative"
	UserScheduleAdherenceImpactNegative string = "Negative"

	// UserScheduleAdherenceImpactNeutral captures enum value "Neutral"
	UserScheduleAdherenceImpactNeutral string = "Neutral"

	// UserScheduleAdherenceImpactUnknown captures enum value "Unknown"
	UserScheduleAdherenceImpactUnknown string = "Unknown"
)

// prop value enum
func (m *UserScheduleAdherence) validateImpactEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userScheduleAdherenceTypeImpactPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserScheduleAdherence) validateImpact(formats strfmt.Registry) error {

	if swag.IsZero(m.Impact) { // not required
		return nil
	}

	// value enum
	if err := m.validateImpactEnum("impact", "body", m.Impact); err != nil {
		return err
	}

	return nil
}

func (m *UserScheduleAdherence) validateManagementUnit(formats strfmt.Registry) error {

	if swag.IsZero(m.ManagementUnit) { // not required
		return nil
	}

	if m.ManagementUnit != nil {
		if err := m.ManagementUnit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("managementUnit")
			}
			return err
		}
	}

	return nil
}

func (m *UserScheduleAdherence) validatePresenceUpdateTime(formats strfmt.Registry) error {

	if swag.IsZero(m.PresenceUpdateTime) { // not required
		return nil
	}

	if err := validate.FormatOf("presenceUpdateTime", "body", "date-time", m.PresenceUpdateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

var userScheduleAdherenceTypeRoutingStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OFF_QUEUE","IDLE","INTERACTING","NOT_RESPONDING","COMMUNICATING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userScheduleAdherenceTypeRoutingStatusPropEnum = append(userScheduleAdherenceTypeRoutingStatusPropEnum, v)
	}
}

const (

	// UserScheduleAdherenceRoutingStatusOFFQUEUE captures enum value "OFF_QUEUE"
	UserScheduleAdherenceRoutingStatusOFFQUEUE string = "OFF_QUEUE"

	// UserScheduleAdherenceRoutingStatusIDLE captures enum value "IDLE"
	UserScheduleAdherenceRoutingStatusIDLE string = "IDLE"

	// UserScheduleAdherenceRoutingStatusINTERACTING captures enum value "INTERACTING"
	UserScheduleAdherenceRoutingStatusINTERACTING string = "INTERACTING"

	// UserScheduleAdherenceRoutingStatusNOTRESPONDING captures enum value "NOT_RESPONDING"
	UserScheduleAdherenceRoutingStatusNOTRESPONDING string = "NOT_RESPONDING"

	// UserScheduleAdherenceRoutingStatusCOMMUNICATING captures enum value "COMMUNICATING"
	UserScheduleAdherenceRoutingStatusCOMMUNICATING string = "COMMUNICATING"
)

// prop value enum
func (m *UserScheduleAdherence) validateRoutingStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userScheduleAdherenceTypeRoutingStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserScheduleAdherence) validateRoutingStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.RoutingStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateRoutingStatusEnum("routingStatus", "body", m.RoutingStatus); err != nil {
		return err
	}

	return nil
}

var userScheduleAdherenceTypeScheduledActivityCategoryPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["OnQueueWork","Break","Meal","Meeting","OffQueueWork","TimeOff","Training","Unavailable","Unscheduled"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userScheduleAdherenceTypeScheduledActivityCategoryPropEnum = append(userScheduleAdherenceTypeScheduledActivityCategoryPropEnum, v)
	}
}

const (

	// UserScheduleAdherenceScheduledActivityCategoryOnQueueWork captures enum value "OnQueueWork"
	UserScheduleAdherenceScheduledActivityCategoryOnQueueWork string = "OnQueueWork"

	// UserScheduleAdherenceScheduledActivityCategoryBreak captures enum value "Break"
	UserScheduleAdherenceScheduledActivityCategoryBreak string = "Break"

	// UserScheduleAdherenceScheduledActivityCategoryMeal captures enum value "Meal"
	UserScheduleAdherenceScheduledActivityCategoryMeal string = "Meal"

	// UserScheduleAdherenceScheduledActivityCategoryMeeting captures enum value "Meeting"
	UserScheduleAdherenceScheduledActivityCategoryMeeting string = "Meeting"

	// UserScheduleAdherenceScheduledActivityCategoryOffQueueWork captures enum value "OffQueueWork"
	UserScheduleAdherenceScheduledActivityCategoryOffQueueWork string = "OffQueueWork"

	// UserScheduleAdherenceScheduledActivityCategoryTimeOff captures enum value "TimeOff"
	UserScheduleAdherenceScheduledActivityCategoryTimeOff string = "TimeOff"

	// UserScheduleAdherenceScheduledActivityCategoryTraining captures enum value "Training"
	UserScheduleAdherenceScheduledActivityCategoryTraining string = "Training"

	// UserScheduleAdherenceScheduledActivityCategoryUnavailable captures enum value "Unavailable"
	UserScheduleAdherenceScheduledActivityCategoryUnavailable string = "Unavailable"

	// UserScheduleAdherenceScheduledActivityCategoryUnscheduled captures enum value "Unscheduled"
	UserScheduleAdherenceScheduledActivityCategoryUnscheduled string = "Unscheduled"
)

// prop value enum
func (m *UserScheduleAdherence) validateScheduledActivityCategoryEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userScheduleAdherenceTypeScheduledActivityCategoryPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserScheduleAdherence) validateScheduledActivityCategory(formats strfmt.Registry) error {

	if swag.IsZero(m.ScheduledActivityCategory) { // not required
		return nil
	}

	// value enum
	if err := m.validateScheduledActivityCategoryEnum("scheduledActivityCategory", "body", m.ScheduledActivityCategory); err != nil {
		return err
	}

	return nil
}

func (m *UserScheduleAdherence) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

var userScheduleAdherenceTypeSystemPresencePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Available","Away","Busy","Offline","Idle","OnQueue","Meal","Training","Meeting","Break"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userScheduleAdherenceTypeSystemPresencePropEnum = append(userScheduleAdherenceTypeSystemPresencePropEnum, v)
	}
}

const (

	// UserScheduleAdherenceSystemPresenceAvailable captures enum value "Available"
	UserScheduleAdherenceSystemPresenceAvailable string = "Available"

	// UserScheduleAdherenceSystemPresenceAway captures enum value "Away"
	UserScheduleAdherenceSystemPresenceAway string = "Away"

	// UserScheduleAdherenceSystemPresenceBusy captures enum value "Busy"
	UserScheduleAdherenceSystemPresenceBusy string = "Busy"

	// UserScheduleAdherenceSystemPresenceOffline captures enum value "Offline"
	UserScheduleAdherenceSystemPresenceOffline string = "Offline"

	// UserScheduleAdherenceSystemPresenceIdle captures enum value "Idle"
	UserScheduleAdherenceSystemPresenceIdle string = "Idle"

	// UserScheduleAdherenceSystemPresenceOnQueue captures enum value "OnQueue"
	UserScheduleAdherenceSystemPresenceOnQueue string = "OnQueue"

	// UserScheduleAdherenceSystemPresenceMeal captures enum value "Meal"
	UserScheduleAdherenceSystemPresenceMeal string = "Meal"

	// UserScheduleAdherenceSystemPresenceTraining captures enum value "Training"
	UserScheduleAdherenceSystemPresenceTraining string = "Training"

	// UserScheduleAdherenceSystemPresenceMeeting captures enum value "Meeting"
	UserScheduleAdherenceSystemPresenceMeeting string = "Meeting"

	// UserScheduleAdherenceSystemPresenceBreak captures enum value "Break"
	UserScheduleAdherenceSystemPresenceBreak string = "Break"
)

// prop value enum
func (m *UserScheduleAdherence) validateSystemPresenceEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userScheduleAdherenceTypeSystemPresencePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserScheduleAdherence) validateSystemPresence(formats strfmt.Registry) error {

	if swag.IsZero(m.SystemPresence) { // not required
		return nil
	}

	// value enum
	if err := m.validateSystemPresenceEnum("systemPresence", "body", m.SystemPresence); err != nil {
		return err
	}

	return nil
}

func (m *UserScheduleAdherence) validateTeam(formats strfmt.Registry) error {

	if swag.IsZero(m.Team) { // not required
		return nil
	}

	if m.Team != nil {
		if err := m.Team.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("team")
			}
			return err
		}
	}

	return nil
}

func (m *UserScheduleAdherence) validateTimeOfAdherenceChange(formats strfmt.Registry) error {

	if swag.IsZero(m.TimeOfAdherenceChange) { // not required
		return nil
	}

	if err := validate.FormatOf("timeOfAdherenceChange", "body", "date-time", m.TimeOfAdherenceChange.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserScheduleAdherence) validateUser(formats strfmt.Registry) error {

	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {
		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserScheduleAdherence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserScheduleAdherence) UnmarshalBinary(b []byte) error {
	var res UserScheduleAdherence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
