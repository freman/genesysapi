// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Edge edge
//
// swagger:model Edge
type Edge struct {

	// api version
	APIVersion string `json:"apiVersion,omitempty"`

	// call draining state
	// Enum: [NONE WAIT WAIT_TIMEOUT TERMINATE COMPLETE]
	CallDrainingState string `json:"callDrainingState,omitempty"`

	// conversation count
	ConversationCount int32 `json:"conversationCount,omitempty"`

	// The ID of the user that created the resource.
	CreatedBy string `json:"createdBy,omitempty"`

	// The application that created the resource.
	CreatedByApp string `json:"createdByApp,omitempty"`

	// current version
	CurrentVersion string `json:"currentVersion,omitempty"`

	// The date the resource was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	DateCreated strfmt.DateTime `json:"dateCreated,omitempty"`

	// The date of the last modification to the resource. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss.SSSZ
	// Format: date-time
	DateModified strfmt.DateTime `json:"dateModified,omitempty"`

	// The resource's description.
	Description string `json:"description,omitempty"`

	// edge deployment type
	// Enum: [HARDWARE LDM CDM INVALID]
	EdgeDeploymentType string `json:"edgeDeploymentType,omitempty"`

	// edge group
	EdgeGroup *EdgeGroup `json:"edgeGroup,omitempty"`

	// fingerprint
	Fingerprint string `json:"fingerprint,omitempty"`

	// fingerprint hint
	FingerprintHint string `json:"fingerprintHint,omitempty"`

	// full software version
	FullSoftwareVersion string `json:"fullSoftwareVersion,omitempty"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The list of interfaces for the edge. (Deprecated) Replaced by configuring trunks/ip info on the logical interface instead
	Interfaces []*EdgeInterface `json:"interfaces"`

	// make
	Make string `json:"make,omitempty"`

	// managed
	Managed bool `json:"managed,omitempty"`

	// model
	Model string `json:"model,omitempty"`

	// The ID of the user that last modified the resource.
	ModifiedBy string `json:"modifiedBy,omitempty"`

	// The application that last modified the resource.
	ModifiedByApp string `json:"modifiedByApp,omitempty"`

	// The name of the entity.
	// Required: true
	Name *string `json:"name"`

	// True if the offline edge configuration endpoint has been called for this edge.
	// Read Only: true
	OfflineConfigCalled *bool `json:"offlineConfigCalled,omitempty"`

	// online status
	// Enum: [ONLINE OFFLINE]
	OnlineStatus string `json:"onlineStatus,omitempty"`

	// The name provided by the operating system of the Edge.
	// Read Only: true
	OsName string `json:"osName,omitempty"`

	// The pairing Id for a hardware Edge in the format: 00000-00000-00000-00000-00000. This field is only required when creating an Edge with a deployment type of HARDWARE.
	PairingID string `json:"pairingId,omitempty"`

	// patch
	Patch string `json:"patch,omitempty"`

	// physical edge
	PhysicalEdge bool `json:"physicalEdge,omitempty"`

	// Edge HTTP proxy configuration for the WAN port. The field can be a hostname, FQDN, IPv4 or IPv6 address. If port is not included, port 80 is assumed.
	Proxy string `json:"proxy,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// serial number
	SerialNumber string `json:"serialNumber,omitempty"`

	// The Site to which the Edge is assigned.
	Site *Site `json:"site,omitempty"`

	// Details about an in-progress or recently in-progress Edge software upgrade. This node appears only if a software upgrade was recently initiated for this Edge.
	SoftwareStatus *DomainEdgeSoftwareUpdateDto `json:"softwareStatus,omitempty"`

	// software version
	SoftwareVersion string `json:"softwareVersion,omitempty"`

	// software version configuration
	SoftwareVersionConfiguration string `json:"softwareVersionConfiguration,omitempty"`

	// software version platform
	SoftwareVersionPlatform string `json:"softwareVersionPlatform,omitempty"`

	// software version timestamp
	SoftwareVersionTimestamp string `json:"softwareVersionTimestamp,omitempty"`

	// staged version
	StagedVersion string `json:"stagedVersion,omitempty"`

	// Indicates if the resource is active, inactive, or deleted.
	// Read Only: true
	// Enum: [active inactive deleted]
	State string `json:"state,omitempty"`

	// The current status of the Edge.
	// Enum: [NEW AWAITING_CONNECTION AWAITING_FINGERPRINT AWAITING_FINGERPRINT_VERIFICATION FINGERPRINT_VERIFIED AWAITING_BOOTSTRAP ACTIVE INACTIVE RMA UNPAIRING UNPAIRED INITIALIZING]
	StatusCode string `json:"statusCode,omitempty"`

	// The current version of the resource.
	Version int32 `json:"version,omitempty"`
}

// Validate validates this edge
func (m *Edge) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCallDrainingState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateModified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdgeDeploymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEdgeGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnlineStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSite(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSoftwareStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatusCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var edgeTypeCallDrainingStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NONE","WAIT","WAIT_TIMEOUT","TERMINATE","COMPLETE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		edgeTypeCallDrainingStatePropEnum = append(edgeTypeCallDrainingStatePropEnum, v)
	}
}

const (

	// EdgeCallDrainingStateNONE captures enum value "NONE"
	EdgeCallDrainingStateNONE string = "NONE"

	// EdgeCallDrainingStateWAIT captures enum value "WAIT"
	EdgeCallDrainingStateWAIT string = "WAIT"

	// EdgeCallDrainingStateWAITTIMEOUT captures enum value "WAIT_TIMEOUT"
	EdgeCallDrainingStateWAITTIMEOUT string = "WAIT_TIMEOUT"

	// EdgeCallDrainingStateTERMINATE captures enum value "TERMINATE"
	EdgeCallDrainingStateTERMINATE string = "TERMINATE"

	// EdgeCallDrainingStateCOMPLETE captures enum value "COMPLETE"
	EdgeCallDrainingStateCOMPLETE string = "COMPLETE"
)

// prop value enum
func (m *Edge) validateCallDrainingStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, edgeTypeCallDrainingStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Edge) validateCallDrainingState(formats strfmt.Registry) error {

	if swag.IsZero(m.CallDrainingState) { // not required
		return nil
	}

	// value enum
	if err := m.validateCallDrainingStateEnum("callDrainingState", "body", m.CallDrainingState); err != nil {
		return err
	}

	return nil
}

func (m *Edge) validateDateCreated(formats strfmt.Registry) error {

	if swag.IsZero(m.DateCreated) { // not required
		return nil
	}

	if err := validate.FormatOf("dateCreated", "body", "date-time", m.DateCreated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Edge) validateDateModified(formats strfmt.Registry) error {

	if swag.IsZero(m.DateModified) { // not required
		return nil
	}

	if err := validate.FormatOf("dateModified", "body", "date-time", m.DateModified.String(), formats); err != nil {
		return err
	}

	return nil
}

var edgeTypeEdgeDeploymentTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["HARDWARE","LDM","CDM","INVALID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		edgeTypeEdgeDeploymentTypePropEnum = append(edgeTypeEdgeDeploymentTypePropEnum, v)
	}
}

const (

	// EdgeEdgeDeploymentTypeHARDWARE captures enum value "HARDWARE"
	EdgeEdgeDeploymentTypeHARDWARE string = "HARDWARE"

	// EdgeEdgeDeploymentTypeLDM captures enum value "LDM"
	EdgeEdgeDeploymentTypeLDM string = "LDM"

	// EdgeEdgeDeploymentTypeCDM captures enum value "CDM"
	EdgeEdgeDeploymentTypeCDM string = "CDM"

	// EdgeEdgeDeploymentTypeINVALID captures enum value "INVALID"
	EdgeEdgeDeploymentTypeINVALID string = "INVALID"
)

// prop value enum
func (m *Edge) validateEdgeDeploymentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, edgeTypeEdgeDeploymentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Edge) validateEdgeDeploymentType(formats strfmt.Registry) error {

	if swag.IsZero(m.EdgeDeploymentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateEdgeDeploymentTypeEnum("edgeDeploymentType", "body", m.EdgeDeploymentType); err != nil {
		return err
	}

	return nil
}

func (m *Edge) validateEdgeGroup(formats strfmt.Registry) error {

	if swag.IsZero(m.EdgeGroup) { // not required
		return nil
	}

	if m.EdgeGroup != nil {
		if err := m.EdgeGroup.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("edgeGroup")
			}
			return err
		}
	}

	return nil
}

func (m *Edge) validateInterfaces(formats strfmt.Registry) error {

	if swag.IsZero(m.Interfaces) { // not required
		return nil
	}

	for i := 0; i < len(m.Interfaces); i++ {
		if swag.IsZero(m.Interfaces[i]) { // not required
			continue
		}

		if m.Interfaces[i] != nil {
			if err := m.Interfaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("interfaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Edge) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var edgeTypeOnlineStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ONLINE","OFFLINE"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		edgeTypeOnlineStatusPropEnum = append(edgeTypeOnlineStatusPropEnum, v)
	}
}

const (

	// EdgeOnlineStatusONLINE captures enum value "ONLINE"
	EdgeOnlineStatusONLINE string = "ONLINE"

	// EdgeOnlineStatusOFFLINE captures enum value "OFFLINE"
	EdgeOnlineStatusOFFLINE string = "OFFLINE"
)

// prop value enum
func (m *Edge) validateOnlineStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, edgeTypeOnlineStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Edge) validateOnlineStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.OnlineStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateOnlineStatusEnum("onlineStatus", "body", m.OnlineStatus); err != nil {
		return err
	}

	return nil
}

func (m *Edge) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Edge) validateSite(formats strfmt.Registry) error {

	if swag.IsZero(m.Site) { // not required
		return nil
	}

	if m.Site != nil {
		if err := m.Site.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("site")
			}
			return err
		}
	}

	return nil
}

func (m *Edge) validateSoftwareStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.SoftwareStatus) { // not required
		return nil
	}

	if m.SoftwareStatus != nil {
		if err := m.SoftwareStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("softwareStatus")
			}
			return err
		}
	}

	return nil
}

var edgeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive","deleted"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		edgeTypeStatePropEnum = append(edgeTypeStatePropEnum, v)
	}
}

const (

	// EdgeStateActive captures enum value "active"
	EdgeStateActive string = "active"

	// EdgeStateInactive captures enum value "inactive"
	EdgeStateInactive string = "inactive"

	// EdgeStateDeleted captures enum value "deleted"
	EdgeStateDeleted string = "deleted"
)

// prop value enum
func (m *Edge) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, edgeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Edge) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

var edgeTypeStatusCodePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NEW","AWAITING_CONNECTION","AWAITING_FINGERPRINT","AWAITING_FINGERPRINT_VERIFICATION","FINGERPRINT_VERIFIED","AWAITING_BOOTSTRAP","ACTIVE","INACTIVE","RMA","UNPAIRING","UNPAIRED","INITIALIZING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		edgeTypeStatusCodePropEnum = append(edgeTypeStatusCodePropEnum, v)
	}
}

const (

	// EdgeStatusCodeNEW captures enum value "NEW"
	EdgeStatusCodeNEW string = "NEW"

	// EdgeStatusCodeAWAITINGCONNECTION captures enum value "AWAITING_CONNECTION"
	EdgeStatusCodeAWAITINGCONNECTION string = "AWAITING_CONNECTION"

	// EdgeStatusCodeAWAITINGFINGERPRINT captures enum value "AWAITING_FINGERPRINT"
	EdgeStatusCodeAWAITINGFINGERPRINT string = "AWAITING_FINGERPRINT"

	// EdgeStatusCodeAWAITINGFINGERPRINTVERIFICATION captures enum value "AWAITING_FINGERPRINT_VERIFICATION"
	EdgeStatusCodeAWAITINGFINGERPRINTVERIFICATION string = "AWAITING_FINGERPRINT_VERIFICATION"

	// EdgeStatusCodeFINGERPRINTVERIFIED captures enum value "FINGERPRINT_VERIFIED"
	EdgeStatusCodeFINGERPRINTVERIFIED string = "FINGERPRINT_VERIFIED"

	// EdgeStatusCodeAWAITINGBOOTSTRAP captures enum value "AWAITING_BOOTSTRAP"
	EdgeStatusCodeAWAITINGBOOTSTRAP string = "AWAITING_BOOTSTRAP"

	// EdgeStatusCodeACTIVE captures enum value "ACTIVE"
	EdgeStatusCodeACTIVE string = "ACTIVE"

	// EdgeStatusCodeINACTIVE captures enum value "INACTIVE"
	EdgeStatusCodeINACTIVE string = "INACTIVE"

	// EdgeStatusCodeRMA captures enum value "RMA"
	EdgeStatusCodeRMA string = "RMA"

	// EdgeStatusCodeUNPAIRING captures enum value "UNPAIRING"
	EdgeStatusCodeUNPAIRING string = "UNPAIRING"

	// EdgeStatusCodeUNPAIRED captures enum value "UNPAIRED"
	EdgeStatusCodeUNPAIRED string = "UNPAIRED"

	// EdgeStatusCodeINITIALIZING captures enum value "INITIALIZING"
	EdgeStatusCodeINITIALIZING string = "INITIALIZING"
)

// prop value enum
func (m *Edge) validateStatusCodeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, edgeTypeStatusCodePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Edge) validateStatusCode(formats strfmt.Registry) error {

	if swag.IsZero(m.StatusCode) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusCodeEnum("statusCode", "body", m.StatusCode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Edge) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Edge) UnmarshalBinary(b []byte) error {
	var res Edge
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
