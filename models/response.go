// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Response Contains information about a response.
//
// swagger:model Response
type Response struct {

	// Assets used in the response
	Assets []*AddressableEntityRef `json:"assets"`

	// User that created the response
	// Read Only: true
	CreatedBy *User `json:"createdBy,omitempty"`

	// The date and time the response was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Read Only: true
	// Format: date-time
	DateCreated strfmt.DateTime `json:"dateCreated,omitempty"`

	// Footer template definition for responseType.Footer.
	Footer *FooterTemplate `json:"footer,omitempty"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The interaction type for this response.
	// Enum: [chat email twitter]
	InteractionType string `json:"interactionType,omitempty"`

	// One or more libraries response is associated with.
	// Required: true
	Libraries []*DomainEntityRef `json:"libraries"`

	// An optional messaging template definition for responseType.MessagingTemplate.
	MessagingTemplate *MessagingTemplate `json:"messagingTemplate,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// The response type represented by the response.
	// Enum: [MessagingTemplate CampaignSmsTemplate CampaignEmailTemplate Footer]
	ResponseType string `json:"responseType,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// Details about any text substitutions used in the texts for this response.
	Substitutions []*ResponseSubstitution `json:"substitutions"`

	// Metadata about the text substitutions in json schema format.
	SubstitutionsSchema *JSONSchemaDocument `json:"substitutionsSchema,omitempty"`

	// One or more texts associated with the response.
	// Required: true
	Texts []*ResponseText `json:"texts"`

	// Version number required for updates.
	Version int32 `json:"version,omitempty"`
}

// Validate validates this response
func (m *Response) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAssets(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFooter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInteractionType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLibraries(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMessagingTemplate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubstitutions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubstitutionsSchema(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTexts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Response) validateAssets(formats strfmt.Registry) error {
	if swag.IsZero(m.Assets) { // not required
		return nil
	}

	for i := 0; i < len(m.Assets); i++ {
		if swag.IsZero(m.Assets[i]) { // not required
			continue
		}

		if m.Assets[i] != nil {
			if err := m.Assets[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("assets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("assets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Response) validateCreatedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedBy) { // not required
		return nil
	}

	if m.CreatedBy != nil {
		if err := m.CreatedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createdBy")
			}
			return err
		}
	}

	return nil
}

func (m *Response) validateDateCreated(formats strfmt.Registry) error {
	if swag.IsZero(m.DateCreated) { // not required
		return nil
	}

	if err := validate.FormatOf("dateCreated", "body", "date-time", m.DateCreated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Response) validateFooter(formats strfmt.Registry) error {
	if swag.IsZero(m.Footer) { // not required
		return nil
	}

	if m.Footer != nil {
		if err := m.Footer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("footer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("footer")
			}
			return err
		}
	}

	return nil
}

var responseTypeInteractionTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["chat","email","twitter"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		responseTypeInteractionTypePropEnum = append(responseTypeInteractionTypePropEnum, v)
	}
}

const (

	// ResponseInteractionTypeChat captures enum value "chat"
	ResponseInteractionTypeChat string = "chat"

	// ResponseInteractionTypeEmail captures enum value "email"
	ResponseInteractionTypeEmail string = "email"

	// ResponseInteractionTypeTwitter captures enum value "twitter"
	ResponseInteractionTypeTwitter string = "twitter"
)

// prop value enum
func (m *Response) validateInteractionTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, responseTypeInteractionTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Response) validateInteractionType(formats strfmt.Registry) error {
	if swag.IsZero(m.InteractionType) { // not required
		return nil
	}

	// value enum
	if err := m.validateInteractionTypeEnum("interactionType", "body", m.InteractionType); err != nil {
		return err
	}

	return nil
}

func (m *Response) validateLibraries(formats strfmt.Registry) error {

	if err := validate.Required("libraries", "body", m.Libraries); err != nil {
		return err
	}

	for i := 0; i < len(m.Libraries); i++ {
		if swag.IsZero(m.Libraries[i]) { // not required
			continue
		}

		if m.Libraries[i] != nil {
			if err := m.Libraries[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libraries" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("libraries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Response) validateMessagingTemplate(formats strfmt.Registry) error {
	if swag.IsZero(m.MessagingTemplate) { // not required
		return nil
	}

	if m.MessagingTemplate != nil {
		if err := m.MessagingTemplate.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("messagingTemplate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("messagingTemplate")
			}
			return err
		}
	}

	return nil
}

var responseTypeResponseTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MessagingTemplate","CampaignSmsTemplate","CampaignEmailTemplate","Footer"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		responseTypeResponseTypePropEnum = append(responseTypeResponseTypePropEnum, v)
	}
}

const (

	// ResponseResponseTypeMessagingTemplate captures enum value "MessagingTemplate"
	ResponseResponseTypeMessagingTemplate string = "MessagingTemplate"

	// ResponseResponseTypeCampaignSmsTemplate captures enum value "CampaignSmsTemplate"
	ResponseResponseTypeCampaignSmsTemplate string = "CampaignSmsTemplate"

	// ResponseResponseTypeCampaignEmailTemplate captures enum value "CampaignEmailTemplate"
	ResponseResponseTypeCampaignEmailTemplate string = "CampaignEmailTemplate"

	// ResponseResponseTypeFooter captures enum value "Footer"
	ResponseResponseTypeFooter string = "Footer"
)

// prop value enum
func (m *Response) validateResponseTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, responseTypeResponseTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Response) validateResponseType(formats strfmt.Registry) error {
	if swag.IsZero(m.ResponseType) { // not required
		return nil
	}

	// value enum
	if err := m.validateResponseTypeEnum("responseType", "body", m.ResponseType); err != nil {
		return err
	}

	return nil
}

func (m *Response) validateSelfURI(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Response) validateSubstitutions(formats strfmt.Registry) error {
	if swag.IsZero(m.Substitutions) { // not required
		return nil
	}

	for i := 0; i < len(m.Substitutions); i++ {
		if swag.IsZero(m.Substitutions[i]) { // not required
			continue
		}

		if m.Substitutions[i] != nil {
			if err := m.Substitutions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("substitutions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("substitutions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Response) validateSubstitutionsSchema(formats strfmt.Registry) error {
	if swag.IsZero(m.SubstitutionsSchema) { // not required
		return nil
	}

	if m.SubstitutionsSchema != nil {
		if err := m.SubstitutionsSchema.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("substitutionsSchema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("substitutionsSchema")
			}
			return err
		}
	}

	return nil
}

func (m *Response) validateTexts(formats strfmt.Registry) error {

	if err := validate.Required("texts", "body", m.Texts); err != nil {
		return err
	}

	for i := 0; i < len(m.Texts); i++ {
		if swag.IsZero(m.Texts[i]) { // not required
			continue
		}

		if m.Texts[i] != nil {
			if err := m.Texts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("texts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("texts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this response based on the context it is used
func (m *Response) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAssets(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreatedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDateCreated(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFooter(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLibraries(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMessagingTemplate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfURI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubstitutions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSubstitutionsSchema(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTexts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Response) contextValidateAssets(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Assets); i++ {

		if m.Assets[i] != nil {
			if err := m.Assets[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("assets" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("assets" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Response) contextValidateCreatedBy(ctx context.Context, formats strfmt.Registry) error {

	if m.CreatedBy != nil {
		if err := m.CreatedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createdBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createdBy")
			}
			return err
		}
	}

	return nil
}

func (m *Response) contextValidateDateCreated(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "dateCreated", "body", strfmt.DateTime(m.DateCreated)); err != nil {
		return err
	}

	return nil
}

func (m *Response) contextValidateFooter(ctx context.Context, formats strfmt.Registry) error {

	if m.Footer != nil {
		if err := m.Footer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("footer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("footer")
			}
			return err
		}
	}

	return nil
}

func (m *Response) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *Response) contextValidateLibraries(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Libraries); i++ {

		if m.Libraries[i] != nil {
			if err := m.Libraries[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("libraries" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("libraries" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Response) contextValidateMessagingTemplate(ctx context.Context, formats strfmt.Registry) error {

	if m.MessagingTemplate != nil {
		if err := m.MessagingTemplate.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("messagingTemplate")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("messagingTemplate")
			}
			return err
		}
	}

	return nil
}

func (m *Response) contextValidateSelfURI(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "selfUri", "body", strfmt.URI(m.SelfURI)); err != nil {
		return err
	}

	return nil
}

func (m *Response) contextValidateSubstitutions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Substitutions); i++ {

		if m.Substitutions[i] != nil {
			if err := m.Substitutions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("substitutions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("substitutions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Response) contextValidateSubstitutionsSchema(ctx context.Context, formats strfmt.Registry) error {

	if m.SubstitutionsSchema != nil {
		if err := m.SubstitutionsSchema.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("substitutionsSchema")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("substitutionsSchema")
			}
			return err
		}
	}

	return nil
}

func (m *Response) contextValidateTexts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Texts); i++ {

		if m.Texts[i] != nil {
			if err := m.Texts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("texts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("texts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Response) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Response) UnmarshalBinary(b []byte) error {
	var res Response
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
