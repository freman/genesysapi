// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MessagingSticker messaging sticker
//
// swagger:model MessagingSticker
type MessagingSticker struct {

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// The type of the messenger provider.
	// Required: true
	// Enum: [sms facebook twitter line whatsapp webmessaging instagram open]
	MessengerType *string `json:"messengerType"`

	// name
	Name string `json:"name,omitempty"`

	// The package name of the sticker, assigned by the sticker provider.
	PackageName string `json:"packageName,omitempty"`

	// The package Id of the sticker, assigned by the sticker provider.
	ProviderPackageID int32 `json:"providerPackageId,omitempty"`

	// The sticker Id of the sticker, assigned by the sticker provider.
	// Required: true
	ProviderStickerID *int32 `json:"providerStickerId"`

	// The version of the sticker, assigned by the provider.
	ProviderVersion int64 `json:"providerVersion,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// The type of the sticker.
	// Required: true
	// Enum: [standard free paid]
	StickerType *string `json:"stickerType"`

	// uri location
	// Format: uri
	URILocation strfmt.URI `json:"uriLocation,omitempty"`
}

// Validate validates this messaging sticker
func (m *MessagingSticker) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateMessengerType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProviderStickerID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStickerType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURILocation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var messagingStickerTypeMessengerTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sms","facebook","twitter","line","whatsapp","webmessaging","instagram","open"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messagingStickerTypeMessengerTypePropEnum = append(messagingStickerTypeMessengerTypePropEnum, v)
	}
}

const (

	// MessagingStickerMessengerTypeSms captures enum value "sms"
	MessagingStickerMessengerTypeSms string = "sms"

	// MessagingStickerMessengerTypeFacebook captures enum value "facebook"
	MessagingStickerMessengerTypeFacebook string = "facebook"

	// MessagingStickerMessengerTypeTwitter captures enum value "twitter"
	MessagingStickerMessengerTypeTwitter string = "twitter"

	// MessagingStickerMessengerTypeLine captures enum value "line"
	MessagingStickerMessengerTypeLine string = "line"

	// MessagingStickerMessengerTypeWhatsapp captures enum value "whatsapp"
	MessagingStickerMessengerTypeWhatsapp string = "whatsapp"

	// MessagingStickerMessengerTypeWebmessaging captures enum value "webmessaging"
	MessagingStickerMessengerTypeWebmessaging string = "webmessaging"

	// MessagingStickerMessengerTypeInstagram captures enum value "instagram"
	MessagingStickerMessengerTypeInstagram string = "instagram"

	// MessagingStickerMessengerTypeOpen captures enum value "open"
	MessagingStickerMessengerTypeOpen string = "open"
)

// prop value enum
func (m *MessagingSticker) validateMessengerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, messagingStickerTypeMessengerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MessagingSticker) validateMessengerType(formats strfmt.Registry) error {

	if err := validate.Required("messengerType", "body", m.MessengerType); err != nil {
		return err
	}

	// value enum
	if err := m.validateMessengerTypeEnum("messengerType", "body", *m.MessengerType); err != nil {
		return err
	}

	return nil
}

func (m *MessagingSticker) validateProviderStickerID(formats strfmt.Registry) error {

	if err := validate.Required("providerStickerId", "body", m.ProviderStickerID); err != nil {
		return err
	}

	return nil
}

func (m *MessagingSticker) validateSelfURI(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

var messagingStickerTypeStickerTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["standard","free","paid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		messagingStickerTypeStickerTypePropEnum = append(messagingStickerTypeStickerTypePropEnum, v)
	}
}

const (

	// MessagingStickerStickerTypeStandard captures enum value "standard"
	MessagingStickerStickerTypeStandard string = "standard"

	// MessagingStickerStickerTypeFree captures enum value "free"
	MessagingStickerStickerTypeFree string = "free"

	// MessagingStickerStickerTypePaid captures enum value "paid"
	MessagingStickerStickerTypePaid string = "paid"
)

// prop value enum
func (m *MessagingSticker) validateStickerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, messagingStickerTypeStickerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MessagingSticker) validateStickerType(formats strfmt.Registry) error {

	if err := validate.Required("stickerType", "body", m.StickerType); err != nil {
		return err
	}

	// value enum
	if err := m.validateStickerTypeEnum("stickerType", "body", *m.StickerType); err != nil {
		return err
	}

	return nil
}

func (m *MessagingSticker) validateURILocation(formats strfmt.Registry) error {
	if swag.IsZero(m.URILocation) { // not required
		return nil
	}

	if err := validate.FormatOf("uriLocation", "body", "uri", m.URILocation.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this messaging sticker based on the context it is used
func (m *MessagingSticker) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfURI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MessagingSticker) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *MessagingSticker) contextValidateSelfURI(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "selfUri", "body", strfmt.URI(m.SelfURI)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MessagingSticker) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MessagingSticker) UnmarshalBinary(b []byte) error {
	var res MessagingSticker
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
