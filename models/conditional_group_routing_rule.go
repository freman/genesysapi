// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ConditionalGroupRoutingRule conditional group routing rule
//
// swagger:model ConditionalGroupRoutingRule
type ConditionalGroupRoutingRule struct {

	// The limit value, beyond which a rule evaluates as true
	ConditionValue float64 `json:"conditionValue,omitempty"`

	// The group(s) to activate if the rule evaluates as true
	// Unique: true
	Groups []*MemberGroup `json:"groups"`

	// The queue metric being evaluated
	// Enum: [EstimatedWaitTime]
	Metric string `json:"metric,omitempty"`

	// The operator that compares the actual value against the condition value
	// Enum: [GreaterThan GreaterThanOrEqualTo LessThan LessThanOrEqualTo]
	Operator string `json:"operator,omitempty"`

	// The queue being evaluated for this rule.  For rule 1, this is always the current queue, so should not be specified.
	Queue *DomainEntityRef `json:"queue,omitempty"`

	// The number of seconds to wait in this rule, if it evaluates as true, before evaluating the next rule.  For the final rule, this is ignored, so need not be specified.
	WaitSeconds int32 `json:"waitSeconds,omitempty"`
}

// Validate validates this conditional group routing rule
func (m *ConditionalGroupRoutingRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperator(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConditionalGroupRoutingRule) validateGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.Groups) { // not required
		return nil
	}

	if err := validate.UniqueItems("groups", "body", m.Groups); err != nil {
		return err
	}

	for i := 0; i < len(m.Groups); i++ {
		if swag.IsZero(m.Groups[i]) { // not required
			continue
		}

		if m.Groups[i] != nil {
			if err := m.Groups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var conditionalGroupRoutingRuleTypeMetricPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["EstimatedWaitTime"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		conditionalGroupRoutingRuleTypeMetricPropEnum = append(conditionalGroupRoutingRuleTypeMetricPropEnum, v)
	}
}

const (

	// ConditionalGroupRoutingRuleMetricEstimatedWaitTime captures enum value "EstimatedWaitTime"
	ConditionalGroupRoutingRuleMetricEstimatedWaitTime string = "EstimatedWaitTime"
)

// prop value enum
func (m *ConditionalGroupRoutingRule) validateMetricEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, conditionalGroupRoutingRuleTypeMetricPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConditionalGroupRoutingRule) validateMetric(formats strfmt.Registry) error {

	if swag.IsZero(m.Metric) { // not required
		return nil
	}

	// value enum
	if err := m.validateMetricEnum("metric", "body", m.Metric); err != nil {
		return err
	}

	return nil
}

var conditionalGroupRoutingRuleTypeOperatorPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		conditionalGroupRoutingRuleTypeOperatorPropEnum = append(conditionalGroupRoutingRuleTypeOperatorPropEnum, v)
	}
}

const (

	// ConditionalGroupRoutingRuleOperatorGreaterThan captures enum value "GreaterThan"
	ConditionalGroupRoutingRuleOperatorGreaterThan string = "GreaterThan"

	// ConditionalGroupRoutingRuleOperatorGreaterThanOrEqualTo captures enum value "GreaterThanOrEqualTo"
	ConditionalGroupRoutingRuleOperatorGreaterThanOrEqualTo string = "GreaterThanOrEqualTo"

	// ConditionalGroupRoutingRuleOperatorLessThan captures enum value "LessThan"
	ConditionalGroupRoutingRuleOperatorLessThan string = "LessThan"

	// ConditionalGroupRoutingRuleOperatorLessThanOrEqualTo captures enum value "LessThanOrEqualTo"
	ConditionalGroupRoutingRuleOperatorLessThanOrEqualTo string = "LessThanOrEqualTo"
)

// prop value enum
func (m *ConditionalGroupRoutingRule) validateOperatorEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, conditionalGroupRoutingRuleTypeOperatorPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ConditionalGroupRoutingRule) validateOperator(formats strfmt.Registry) error {

	if swag.IsZero(m.Operator) { // not required
		return nil
	}

	// value enum
	if err := m.validateOperatorEnum("operator", "body", m.Operator); err != nil {
		return err
	}

	return nil
}

func (m *ConditionalGroupRoutingRule) validateQueue(formats strfmt.Registry) error {

	if swag.IsZero(m.Queue) { // not required
		return nil
	}

	if m.Queue != nil {
		if err := m.Queue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queue")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConditionalGroupRoutingRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConditionalGroupRoutingRule) UnmarshalBinary(b []byte) error {
	var res ConditionalGroupRoutingRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
