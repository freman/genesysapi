// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// RecordingEncryptionConfiguration recording encryption configuration
//
// swagger:model RecordingEncryptionConfiguration
type RecordingEncryptionConfiguration struct {

	// The api id for Hawk Authentication. Null if keyConfigurationType is KmsSymmetric
	APIID string `json:"apiId,omitempty"`

	// The api shared symmetric key used for hawk authentication. Null if keyConfigurationType is KmsSymmetric
	APIKey string `json:"apiKey,omitempty"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// Type should be LocalKeyManager or KmsSymmetric when create or update Key configurations; 'Native' for disabling configuration.
	// Required: true
	// Enum: [KmsSymmetric LocalKeyManager Native None]
	KeyConfigurationType *string `json:"keyConfigurationType"`

	// The error message related to the configuration
	LastError *ErrorBody `json:"lastError,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// When keyConfigurationType is LocalKeyManager, this should be the url for decryption and must specify the path to where GenesysCloud can requests decryption. When keyConfigurationType is KmsSymmetric, this should be the arn to the key alias for the master key
	// Required: true
	URL *string `json:"url"`
}

// Validate validates this recording encryption configuration
func (m *RecordingEncryptionConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateKeyConfigurationType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var recordingEncryptionConfigurationTypeKeyConfigurationTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["KmsSymmetric","LocalKeyManager","Native","None"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		recordingEncryptionConfigurationTypeKeyConfigurationTypePropEnum = append(recordingEncryptionConfigurationTypeKeyConfigurationTypePropEnum, v)
	}
}

const (

	// RecordingEncryptionConfigurationKeyConfigurationTypeKmsSymmetric captures enum value "KmsSymmetric"
	RecordingEncryptionConfigurationKeyConfigurationTypeKmsSymmetric string = "KmsSymmetric"

	// RecordingEncryptionConfigurationKeyConfigurationTypeLocalKeyManager captures enum value "LocalKeyManager"
	RecordingEncryptionConfigurationKeyConfigurationTypeLocalKeyManager string = "LocalKeyManager"

	// RecordingEncryptionConfigurationKeyConfigurationTypeNative captures enum value "Native"
	RecordingEncryptionConfigurationKeyConfigurationTypeNative string = "Native"

	// RecordingEncryptionConfigurationKeyConfigurationTypeNone captures enum value "None"
	RecordingEncryptionConfigurationKeyConfigurationTypeNone string = "None"
)

// prop value enum
func (m *RecordingEncryptionConfiguration) validateKeyConfigurationTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, recordingEncryptionConfigurationTypeKeyConfigurationTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *RecordingEncryptionConfiguration) validateKeyConfigurationType(formats strfmt.Registry) error {

	if err := validate.Required("keyConfigurationType", "body", m.KeyConfigurationType); err != nil {
		return err
	}

	// value enum
	if err := m.validateKeyConfigurationTypeEnum("keyConfigurationType", "body", *m.KeyConfigurationType); err != nil {
		return err
	}

	return nil
}

func (m *RecordingEncryptionConfiguration) validateLastError(formats strfmt.Registry) error {

	if swag.IsZero(m.LastError) { // not required
		return nil
	}

	if m.LastError != nil {
		if err := m.LastError.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastError")
			}
			return err
		}
	}

	return nil
}

func (m *RecordingEncryptionConfiguration) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *RecordingEncryptionConfiguration) validateURL(formats strfmt.Registry) error {

	if err := validate.Required("url", "body", m.URL); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RecordingEncryptionConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RecordingEncryptionConfiguration) UnmarshalBinary(b []byte) error {
	var res RecordingEncryptionConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
