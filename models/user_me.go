// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// UserMe user me
//
// swagger:model UserMe
type UserMe struct {

	// acd auto answer
	AcdAutoAnswer bool `json:"acdAutoAnswer"`

	// Email addresses and phone numbers for this user
	Addresses []*Contact `json:"addresses"`

	// The first 50 superiors, direct reports, and siblings of this user. Mutually exclusive with superiors and direct reports expands.
	// Read Only: true
	Adjacents *Adjacents `json:"adjacents,omitempty"`

	// Roles and permissions assigned to the user
	// Read Only: true
	Authorization *UserAuthorization `json:"authorization,omitempty"`

	// biography
	Biography *Biography `json:"biography,omitempty"`

	// certifications
	Certifications []string `json:"certifications"`

	// chat
	Chat *Chat `json:"chat,omitempty"`

	// Summary of conversion statistics for conversation types.
	// Read Only: true
	ConversationSummary *UserConversationSummary `json:"conversationSummary,omitempty"`

	// The PureCloud system date time.
	// Read Only: true
	Date *ServerDate `json:"date,omitempty"`

	// The last time the user logged in using username and password. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Read Only: true
	// Format: date-time
	DateLastLogin strfmt.DateTime `json:"dateLastLogin,omitempty"`

	// department
	Department string `json:"department,omitempty"`

	// The first 50 direct reports to this user.
	// Read Only: true
	DirectReports []*User `json:"directReports"`

	// The division to which this entity belongs.
	Division *Division `json:"division,omitempty"`

	// email
	Email string `json:"email,omitempty"`

	// employer info
	EmployerInfo *EmployerInfo `json:"employerInfo,omitempty"`

	// The first 50 favorited users.
	// Read Only: true
	Favorites []*User `json:"favorites"`

	// The field config for all entities types of user's organization
	// Read Only: true
	FieldConfigs *FieldConfigs `json:"fieldConfigs,omitempty"`

	// Current geolocation position
	// Read Only: true
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Geolocation settings for user's organization.
	// Read Only: true
	GeolocationSettings *GeolocationSettings `json:"geolocationSettings,omitempty"`

	// The groups the user is a member of
	// Read Only: true
	Groups []*Group `json:"groups"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// images
	Images []*UserImage `json:"images"`

	// Integration presence
	// Read Only: true
	IntegrationPresence *UserPresence `json:"integrationPresence,omitempty"`

	// preferred language by the user
	// Read Only: true
	LanguagePreference string `json:"languagePreference,omitempty"`

	// Routing (ACD) languages possessed by the user
	// Read Only: true
	Languages []*UserRoutingLanguage `json:"languages"`

	// last token issued
	LastTokenIssued *OAuthLastTokenIssued `json:"lastTokenIssued,omitempty"`

	// The first 100 site locations for user's organization
	// Read Only: true
	LocationDefinitions []*LocationDefinition `json:"locationDefinitions"`

	// The user placement at each site location.
	// Read Only: true
	Locations []*Location `json:"locations"`

	// manager
	Manager *User `json:"manager,omitempty"`

	// name
	Name string `json:"name,omitempty"`

	// The first 100 organization roles, with applicable permission policies, for user's organization.
	// Read Only: true
	OrgAuthorization []*DomainOrganizationRole `json:"orgAuthorization"`

	// Products enabled in this organization
	// Read Only: true
	OrgProducts []*DomainOrganizationProduct `json:"orgProducts"`

	// Organization details for this user.
	// Read Only: true
	Organization *Organization `json:"organization,omitempty"`

	// Determine if out of office is enabled
	// Read Only: true
	OutOfOffice *OutOfOffice `json:"outOfOffice,omitempty"`

	// Active presence
	// Read Only: true
	Presence *UserPresence `json:"presence,omitempty"`

	// The first 100 presence definitions for user's organization.
	// Read Only: true
	PresenceDefinitions []*OrganizationPresence `json:"presenceDefinitions"`

	// Auto populated from addresses.
	// Read Only: true
	PrimaryContactInfo []*Contact `json:"primaryContactInfo"`

	// Profile skills possessed by the user
	// Read Only: true
	ProfileSkills []string `json:"profileSkills"`

	// The first 50 routing skills for user's organizations
	// Read Only: true
	RoutingSkills []*RoutingSkill `json:"routingSkills"`

	// ACD routing status
	// Read Only: true
	RoutingStatus *RoutingStatus `json:"routingStatus,omitempty"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// Routing (ACD) skills possessed by the user
	// Read Only: true
	Skills []*UserRoutingSkill `json:"skills"`

	// The current state for this user.
	// Read Only: true
	// Enum: [active inactive deleted]
	State string `json:"state,omitempty"`

	// Effective, default, and last station information
	// Read Only: true
	Station *UserStations `json:"station,omitempty"`

	// The first 50 superiors of this user.
	// Read Only: true
	Superiors []*User `json:"superiors"`

	// The team the user is a member of
	// Read Only: true
	Team *Team `json:"team,omitempty"`

	// title
	Title string `json:"title,omitempty"`

	// Information about the current token
	// Read Only: true
	Token *TokenInfo `json:"token,omitempty"`

	// Organizations having this user as a trustee
	// Read Only: true
	Trustors []*Trustor `json:"trustors"`

	// username
	Username string `json:"username,omitempty"`

	// Required when updating a user, this value should be the current version of the user.  The current version can be obtained with a GET on the user before doing a PATCH.
	// Required: true
	Version *int32 `json:"version"`
}

// Validate validates this user me
func (m *UserMe) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAddresses(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdjacents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthorization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBiography(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChat(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConversationSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDateLastLogin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectReports(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDivision(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployerInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFavorites(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFieldConfigs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeolocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeolocationSettings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIntegrationPresence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguages(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastTokenIssued(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocationDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateManager(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrgAuthorization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrgProducts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOutOfOffice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePresence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePresenceDefinitions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrimaryContactInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutingSkills(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRoutingStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSkills(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSuperiors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTeam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToken(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTrustors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UserMe) validateAddresses(formats strfmt.Registry) error {

	if swag.IsZero(m.Addresses) { // not required
		return nil
	}

	for i := 0; i < len(m.Addresses); i++ {
		if swag.IsZero(m.Addresses[i]) { // not required
			continue
		}

		if m.Addresses[i] != nil {
			if err := m.Addresses[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addresses" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateAdjacents(formats strfmt.Registry) error {

	if swag.IsZero(m.Adjacents) { // not required
		return nil
	}

	if m.Adjacents != nil {
		if err := m.Adjacents.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("adjacents")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateAuthorization(formats strfmt.Registry) error {

	if swag.IsZero(m.Authorization) { // not required
		return nil
	}

	if m.Authorization != nil {
		if err := m.Authorization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authorization")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateBiography(formats strfmt.Registry) error {

	if swag.IsZero(m.Biography) { // not required
		return nil
	}

	if m.Biography != nil {
		if err := m.Biography.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("biography")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateChat(formats strfmt.Registry) error {

	if swag.IsZero(m.Chat) { // not required
		return nil
	}

	if m.Chat != nil {
		if err := m.Chat.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("chat")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateConversationSummary(formats strfmt.Registry) error {

	if swag.IsZero(m.ConversationSummary) { // not required
		return nil
	}

	if m.ConversationSummary != nil {
		if err := m.ConversationSummary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("conversationSummary")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateDate(formats strfmt.Registry) error {

	if swag.IsZero(m.Date) { // not required
		return nil
	}

	if m.Date != nil {
		if err := m.Date.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("date")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateDateLastLogin(formats strfmt.Registry) error {

	if swag.IsZero(m.DateLastLogin) { // not required
		return nil
	}

	if err := validate.FormatOf("dateLastLogin", "body", "date-time", m.DateLastLogin.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserMe) validateDirectReports(formats strfmt.Registry) error {

	if swag.IsZero(m.DirectReports) { // not required
		return nil
	}

	for i := 0; i < len(m.DirectReports); i++ {
		if swag.IsZero(m.DirectReports[i]) { // not required
			continue
		}

		if m.DirectReports[i] != nil {
			if err := m.DirectReports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("directReports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateDivision(formats strfmt.Registry) error {

	if swag.IsZero(m.Division) { // not required
		return nil
	}

	if m.Division != nil {
		if err := m.Division.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("division")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateEmployerInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.EmployerInfo) { // not required
		return nil
	}

	if m.EmployerInfo != nil {
		if err := m.EmployerInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("employerInfo")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateFavorites(formats strfmt.Registry) error {

	if swag.IsZero(m.Favorites) { // not required
		return nil
	}

	for i := 0; i < len(m.Favorites); i++ {
		if swag.IsZero(m.Favorites[i]) { // not required
			continue
		}

		if m.Favorites[i] != nil {
			if err := m.Favorites[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("favorites" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateFieldConfigs(formats strfmt.Registry) error {

	if swag.IsZero(m.FieldConfigs) { // not required
		return nil
	}

	if m.FieldConfigs != nil {
		if err := m.FieldConfigs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fieldConfigs")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateGeolocation(formats strfmt.Registry) error {

	if swag.IsZero(m.Geolocation) { // not required
		return nil
	}

	if m.Geolocation != nil {
		if err := m.Geolocation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("geolocation")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateGeolocationSettings(formats strfmt.Registry) error {

	if swag.IsZero(m.GeolocationSettings) { // not required
		return nil
	}

	if m.GeolocationSettings != nil {
		if err := m.GeolocationSettings.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("geolocationSettings")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateGroups(formats strfmt.Registry) error {

	if swag.IsZero(m.Groups) { // not required
		return nil
	}

	for i := 0; i < len(m.Groups); i++ {
		if swag.IsZero(m.Groups[i]) { // not required
			continue
		}

		if m.Groups[i] != nil {
			if err := m.Groups[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("groups" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateImages(formats strfmt.Registry) error {

	if swag.IsZero(m.Images) { // not required
		return nil
	}

	for i := 0; i < len(m.Images); i++ {
		if swag.IsZero(m.Images[i]) { // not required
			continue
		}

		if m.Images[i] != nil {
			if err := m.Images[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("images" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateIntegrationPresence(formats strfmt.Registry) error {

	if swag.IsZero(m.IntegrationPresence) { // not required
		return nil
	}

	if m.IntegrationPresence != nil {
		if err := m.IntegrationPresence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("integrationPresence")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateLanguages(formats strfmt.Registry) error {

	if swag.IsZero(m.Languages) { // not required
		return nil
	}

	for i := 0; i < len(m.Languages); i++ {
		if swag.IsZero(m.Languages[i]) { // not required
			continue
		}

		if m.Languages[i] != nil {
			if err := m.Languages[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("languages" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateLastTokenIssued(formats strfmt.Registry) error {

	if swag.IsZero(m.LastTokenIssued) { // not required
		return nil
	}

	if m.LastTokenIssued != nil {
		if err := m.LastTokenIssued.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastTokenIssued")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateLocationDefinitions(formats strfmt.Registry) error {

	if swag.IsZero(m.LocationDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.LocationDefinitions); i++ {
		if swag.IsZero(m.LocationDefinitions[i]) { // not required
			continue
		}

		if m.LocationDefinitions[i] != nil {
			if err := m.LocationDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locationDefinitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateLocations(formats strfmt.Registry) error {

	if swag.IsZero(m.Locations) { // not required
		return nil
	}

	for i := 0; i < len(m.Locations); i++ {
		if swag.IsZero(m.Locations[i]) { // not required
			continue
		}

		if m.Locations[i] != nil {
			if err := m.Locations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateManager(formats strfmt.Registry) error {

	if swag.IsZero(m.Manager) { // not required
		return nil
	}

	if m.Manager != nil {
		if err := m.Manager.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("manager")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateOrgAuthorization(formats strfmt.Registry) error {

	if swag.IsZero(m.OrgAuthorization) { // not required
		return nil
	}

	for i := 0; i < len(m.OrgAuthorization); i++ {
		if swag.IsZero(m.OrgAuthorization[i]) { // not required
			continue
		}

		if m.OrgAuthorization[i] != nil {
			if err := m.OrgAuthorization[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orgAuthorization" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateOrgProducts(formats strfmt.Registry) error {

	if swag.IsZero(m.OrgProducts) { // not required
		return nil
	}

	for i := 0; i < len(m.OrgProducts); i++ {
		if swag.IsZero(m.OrgProducts[i]) { // not required
			continue
		}

		if m.OrgProducts[i] != nil {
			if err := m.OrgProducts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("orgProducts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateOrganization(formats strfmt.Registry) error {

	if swag.IsZero(m.Organization) { // not required
		return nil
	}

	if m.Organization != nil {
		if err := m.Organization.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("organization")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateOutOfOffice(formats strfmt.Registry) error {

	if swag.IsZero(m.OutOfOffice) { // not required
		return nil
	}

	if m.OutOfOffice != nil {
		if err := m.OutOfOffice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("outOfOffice")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validatePresence(formats strfmt.Registry) error {

	if swag.IsZero(m.Presence) { // not required
		return nil
	}

	if m.Presence != nil {
		if err := m.Presence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("presence")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validatePresenceDefinitions(formats strfmt.Registry) error {

	if swag.IsZero(m.PresenceDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.PresenceDefinitions); i++ {
		if swag.IsZero(m.PresenceDefinitions[i]) { // not required
			continue
		}

		if m.PresenceDefinitions[i] != nil {
			if err := m.PresenceDefinitions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("presenceDefinitions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validatePrimaryContactInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.PrimaryContactInfo) { // not required
		return nil
	}

	for i := 0; i < len(m.PrimaryContactInfo); i++ {
		if swag.IsZero(m.PrimaryContactInfo[i]) { // not required
			continue
		}

		if m.PrimaryContactInfo[i] != nil {
			if err := m.PrimaryContactInfo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("primaryContactInfo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateRoutingSkills(formats strfmt.Registry) error {

	if swag.IsZero(m.RoutingSkills) { // not required
		return nil
	}

	for i := 0; i < len(m.RoutingSkills); i++ {
		if swag.IsZero(m.RoutingSkills[i]) { // not required
			continue
		}

		if m.RoutingSkills[i] != nil {
			if err := m.RoutingSkills[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("routingSkills" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateRoutingStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.RoutingStatus) { // not required
		return nil
	}

	if m.RoutingStatus != nil {
		if err := m.RoutingStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("routingStatus")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateSelfURI(formats strfmt.Registry) error {

	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *UserMe) validateSkills(formats strfmt.Registry) error {

	if swag.IsZero(m.Skills) { // not required
		return nil
	}

	for i := 0; i < len(m.Skills); i++ {
		if swag.IsZero(m.Skills[i]) { // not required
			continue
		}

		if m.Skills[i] != nil {
			if err := m.Skills[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("skills" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var userMeTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","inactive","deleted"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		userMeTypeStatePropEnum = append(userMeTypeStatePropEnum, v)
	}
}

const (

	// UserMeStateActive captures enum value "active"
	UserMeStateActive string = "active"

	// UserMeStateInactive captures enum value "inactive"
	UserMeStateInactive string = "inactive"

	// UserMeStateDeleted captures enum value "deleted"
	UserMeStateDeleted string = "deleted"
)

// prop value enum
func (m *UserMe) validateStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, userMeTypeStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *UserMe) validateState(formats strfmt.Registry) error {

	if swag.IsZero(m.State) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateEnum("state", "body", m.State); err != nil {
		return err
	}

	return nil
}

func (m *UserMe) validateStation(formats strfmt.Registry) error {

	if swag.IsZero(m.Station) { // not required
		return nil
	}

	if m.Station != nil {
		if err := m.Station.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("station")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateSuperiors(formats strfmt.Registry) error {

	if swag.IsZero(m.Superiors) { // not required
		return nil
	}

	for i := 0; i < len(m.Superiors); i++ {
		if swag.IsZero(m.Superiors[i]) { // not required
			continue
		}

		if m.Superiors[i] != nil {
			if err := m.Superiors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("superiors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateTeam(formats strfmt.Registry) error {

	if swag.IsZero(m.Team) { // not required
		return nil
	}

	if m.Team != nil {
		if err := m.Team.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("team")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateToken(formats strfmt.Registry) error {

	if swag.IsZero(m.Token) { // not required
		return nil
	}

	if m.Token != nil {
		if err := m.Token.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("token")
			}
			return err
		}
	}

	return nil
}

func (m *UserMe) validateTrustors(formats strfmt.Registry) error {

	if swag.IsZero(m.Trustors) { // not required
		return nil
	}

	for i := 0; i < len(m.Trustors); i++ {
		if swag.IsZero(m.Trustors[i]) { // not required
			continue
		}

		if m.Trustors[i] != nil {
			if err := m.Trustors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("trustors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *UserMe) validateVersion(formats strfmt.Registry) error {

	if err := validate.Required("version", "body", m.Version); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UserMe) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UserMe) UnmarshalBinary(b []byte) error {
	var res UserMe
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
