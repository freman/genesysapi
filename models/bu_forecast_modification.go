// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BuForecastModification bu forecast modification
//
// swagger:model BuForecastModification
type BuForecastModification struct {

	// The client side display granularity of the modification, expressed in the ISO-8601 duration format. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
	// Required: true
	DisplayGranularity *string `json:"displayGranularity"`

	// Whether the modification is enabled for the forecast
	// Required: true
	Enabled *bool `json:"enabled"`

	// The number of 15 minute intervals past referenceStartDate representing the last interval to which to apply this modification.  Must be null if values is populated
	EndIntervalIndex int32 `json:"endIntervalIndex,omitempty"`

	// The actual granularity of the modification as stored behind the scenes, expressed in the ISO-8601 duration format. Periods are represented as an ISO-8601 string. For example: P1D or P1DT12H
	Granularity string `json:"granularity,omitempty"`

	// The legacy metric to which this modification applies if applicable
	// Read Only: true
	// Enum: [AverageAfterCallWorkTimeSeconds AverageHandleTimeSeconds AverageTalkTimeSeconds Offered]
	LegacyMetric string `json:"legacyMetric,omitempty"`

	// The metric to which this modification applies
	// Required: true
	// Enum: [Offered AverageHandleTimeSeconds]
	Metric *string `json:"metric"`

	// The IDs of the planning groups to which this forecast modification applies.  Leave empty to apply to all
	// Unique: true
	PlanningGroupIds []string `json:"planningGroupIds"`

	// The number of 15 minute intervals past referenceStartDate representing the first interval to which to apply this modification. Must be null if values is populated
	StartIntervalIndex int32 `json:"startIntervalIndex,omitempty"`

	// The type of the modification
	// Required: true
	// Enum: [MinimumPerInterval MaximumPerInterval SetValuePerInterval ChangeValuePerInterval ChangePercentPerInterval SetValueOverRange ChangeValueOverRange SetValuesForIntervalSet]
	Type *string `json:"type"`

	// The value of the modification.  Must be null if "values" is populated
	Value float64 `json:"value,omitempty"`

	// The list of values to update.  Only applicable for grid-type modifications. Must be null if "value" is populated
	Values []*WfmForecastModificationIntervalOffsetValue `json:"values"`
}

// Validate validates this bu forecast modification
func (m *BuForecastModification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDisplayGranularity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLegacyMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetric(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlanningGroupIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValues(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuForecastModification) validateDisplayGranularity(formats strfmt.Registry) error {

	if err := validate.Required("displayGranularity", "body", m.DisplayGranularity); err != nil {
		return err
	}

	return nil
}

func (m *BuForecastModification) validateEnabled(formats strfmt.Registry) error {

	if err := validate.Required("enabled", "body", m.Enabled); err != nil {
		return err
	}

	return nil
}

var buForecastModificationTypeLegacyMetricPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["AverageAfterCallWorkTimeSeconds","AverageHandleTimeSeconds","AverageTalkTimeSeconds","Offered"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buForecastModificationTypeLegacyMetricPropEnum = append(buForecastModificationTypeLegacyMetricPropEnum, v)
	}
}

const (

	// BuForecastModificationLegacyMetricAverageAfterCallWorkTimeSeconds captures enum value "AverageAfterCallWorkTimeSeconds"
	BuForecastModificationLegacyMetricAverageAfterCallWorkTimeSeconds string = "AverageAfterCallWorkTimeSeconds"

	// BuForecastModificationLegacyMetricAverageHandleTimeSeconds captures enum value "AverageHandleTimeSeconds"
	BuForecastModificationLegacyMetricAverageHandleTimeSeconds string = "AverageHandleTimeSeconds"

	// BuForecastModificationLegacyMetricAverageTalkTimeSeconds captures enum value "AverageTalkTimeSeconds"
	BuForecastModificationLegacyMetricAverageTalkTimeSeconds string = "AverageTalkTimeSeconds"

	// BuForecastModificationLegacyMetricOffered captures enum value "Offered"
	BuForecastModificationLegacyMetricOffered string = "Offered"
)

// prop value enum
func (m *BuForecastModification) validateLegacyMetricEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, buForecastModificationTypeLegacyMetricPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BuForecastModification) validateLegacyMetric(formats strfmt.Registry) error {
	if swag.IsZero(m.LegacyMetric) { // not required
		return nil
	}

	// value enum
	if err := m.validateLegacyMetricEnum("legacyMetric", "body", m.LegacyMetric); err != nil {
		return err
	}

	return nil
}

var buForecastModificationTypeMetricPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Offered","AverageHandleTimeSeconds"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buForecastModificationTypeMetricPropEnum = append(buForecastModificationTypeMetricPropEnum, v)
	}
}

const (

	// BuForecastModificationMetricOffered captures enum value "Offered"
	BuForecastModificationMetricOffered string = "Offered"

	// BuForecastModificationMetricAverageHandleTimeSeconds captures enum value "AverageHandleTimeSeconds"
	BuForecastModificationMetricAverageHandleTimeSeconds string = "AverageHandleTimeSeconds"
)

// prop value enum
func (m *BuForecastModification) validateMetricEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, buForecastModificationTypeMetricPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BuForecastModification) validateMetric(formats strfmt.Registry) error {

	if err := validate.Required("metric", "body", m.Metric); err != nil {
		return err
	}

	// value enum
	if err := m.validateMetricEnum("metric", "body", *m.Metric); err != nil {
		return err
	}

	return nil
}

func (m *BuForecastModification) validatePlanningGroupIds(formats strfmt.Registry) error {
	if swag.IsZero(m.PlanningGroupIds) { // not required
		return nil
	}

	if err := validate.UniqueItems("planningGroupIds", "body", m.PlanningGroupIds); err != nil {
		return err
	}

	return nil
}

var buForecastModificationTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["MinimumPerInterval","MaximumPerInterval","SetValuePerInterval","ChangeValuePerInterval","ChangePercentPerInterval","SetValueOverRange","ChangeValueOverRange","SetValuesForIntervalSet"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		buForecastModificationTypeTypePropEnum = append(buForecastModificationTypeTypePropEnum, v)
	}
}

const (

	// BuForecastModificationTypeMinimumPerInterval captures enum value "MinimumPerInterval"
	BuForecastModificationTypeMinimumPerInterval string = "MinimumPerInterval"

	// BuForecastModificationTypeMaximumPerInterval captures enum value "MaximumPerInterval"
	BuForecastModificationTypeMaximumPerInterval string = "MaximumPerInterval"

	// BuForecastModificationTypeSetValuePerInterval captures enum value "SetValuePerInterval"
	BuForecastModificationTypeSetValuePerInterval string = "SetValuePerInterval"

	// BuForecastModificationTypeChangeValuePerInterval captures enum value "ChangeValuePerInterval"
	BuForecastModificationTypeChangeValuePerInterval string = "ChangeValuePerInterval"

	// BuForecastModificationTypeChangePercentPerInterval captures enum value "ChangePercentPerInterval"
	BuForecastModificationTypeChangePercentPerInterval string = "ChangePercentPerInterval"

	// BuForecastModificationTypeSetValueOverRange captures enum value "SetValueOverRange"
	BuForecastModificationTypeSetValueOverRange string = "SetValueOverRange"

	// BuForecastModificationTypeChangeValueOverRange captures enum value "ChangeValueOverRange"
	BuForecastModificationTypeChangeValueOverRange string = "ChangeValueOverRange"

	// BuForecastModificationTypeSetValuesForIntervalSet captures enum value "SetValuesForIntervalSet"
	BuForecastModificationTypeSetValuesForIntervalSet string = "SetValuesForIntervalSet"
)

// prop value enum
func (m *BuForecastModification) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, buForecastModificationTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *BuForecastModification) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *BuForecastModification) validateValues(formats strfmt.Registry) error {
	if swag.IsZero(m.Values) { // not required
		return nil
	}

	for i := 0; i < len(m.Values); i++ {
		if swag.IsZero(m.Values[i]) { // not required
			continue
		}

		if m.Values[i] != nil {
			if err := m.Values[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("values" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("values" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this bu forecast modification based on the context it is used
func (m *BuForecastModification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLegacyMetric(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValues(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BuForecastModification) contextValidateLegacyMetric(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "legacyMetric", "body", string(m.LegacyMetric)); err != nil {
		return err
	}

	return nil
}

func (m *BuForecastModification) contextValidateValues(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Values); i++ {

		if m.Values[i] != nil {
			if err := m.Values[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("values" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("values" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *BuForecastModification) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BuForecastModification) UnmarshalBinary(b []byte) error {
	var res BuForecastModification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
