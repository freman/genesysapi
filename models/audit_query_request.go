// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AuditQueryRequest audit query request
//
// swagger:model AuditQueryRequest
type AuditQueryRequest struct {

	// Additional filters for the query.
	Filters []*AuditQueryFilter `json:"filters"`

	// Date and time range of data to query. Intervals are represented as an ISO-8601 string. For example: YYYY-MM-DDThh:mm:ss/YYYY-MM-DDThh:mm:ss
	// Required: true
	Interval *string `json:"interval"`

	// Name of the service to query audits for.
	// Required: true
	// Enum: [Architect ContactCenter ContentManagement PeoplePermissions Presence Quality LanguageUnderstanding TopicsDefinitions PredictiveEngagement WorkforceManagement Triggers ResponseManagement Groups Telephony Outbound SpeechAndTextAnalytics Routing]
	ServiceName *string `json:"serviceName"`

	// Sort parameter for the query.
	Sort []*AuditQuerySort `json:"sort"`
}

// Validate validates this audit query request
func (m *AuditQueryRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFilters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInterval(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSort(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AuditQueryRequest) validateFilters(formats strfmt.Registry) error {

	if swag.IsZero(m.Filters) { // not required
		return nil
	}

	for i := 0; i < len(m.Filters); i++ {
		if swag.IsZero(m.Filters[i]) { // not required
			continue
		}

		if m.Filters[i] != nil {
			if err := m.Filters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("filters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AuditQueryRequest) validateInterval(formats strfmt.Registry) error {

	if err := validate.Required("interval", "body", m.Interval); err != nil {
		return err
	}

	return nil
}

var auditQueryRequestTypeServiceNamePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Architect","ContactCenter","ContentManagement","PeoplePermissions","Presence","Quality","LanguageUnderstanding","TopicsDefinitions","PredictiveEngagement","WorkforceManagement","Triggers","ResponseManagement","Groups","Telephony","Outbound","SpeechAndTextAnalytics","Routing"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		auditQueryRequestTypeServiceNamePropEnum = append(auditQueryRequestTypeServiceNamePropEnum, v)
	}
}

const (

	// AuditQueryRequestServiceNameArchitect captures enum value "Architect"
	AuditQueryRequestServiceNameArchitect string = "Architect"

	// AuditQueryRequestServiceNameContactCenter captures enum value "ContactCenter"
	AuditQueryRequestServiceNameContactCenter string = "ContactCenter"

	// AuditQueryRequestServiceNameContentManagement captures enum value "ContentManagement"
	AuditQueryRequestServiceNameContentManagement string = "ContentManagement"

	// AuditQueryRequestServiceNamePeoplePermissions captures enum value "PeoplePermissions"
	AuditQueryRequestServiceNamePeoplePermissions string = "PeoplePermissions"

	// AuditQueryRequestServiceNamePresence captures enum value "Presence"
	AuditQueryRequestServiceNamePresence string = "Presence"

	// AuditQueryRequestServiceNameQuality captures enum value "Quality"
	AuditQueryRequestServiceNameQuality string = "Quality"

	// AuditQueryRequestServiceNameLanguageUnderstanding captures enum value "LanguageUnderstanding"
	AuditQueryRequestServiceNameLanguageUnderstanding string = "LanguageUnderstanding"

	// AuditQueryRequestServiceNameTopicsDefinitions captures enum value "TopicsDefinitions"
	AuditQueryRequestServiceNameTopicsDefinitions string = "TopicsDefinitions"

	// AuditQueryRequestServiceNamePredictiveEngagement captures enum value "PredictiveEngagement"
	AuditQueryRequestServiceNamePredictiveEngagement string = "PredictiveEngagement"

	// AuditQueryRequestServiceNameWorkforceManagement captures enum value "WorkforceManagement"
	AuditQueryRequestServiceNameWorkforceManagement string = "WorkforceManagement"

	// AuditQueryRequestServiceNameTriggers captures enum value "Triggers"
	AuditQueryRequestServiceNameTriggers string = "Triggers"

	// AuditQueryRequestServiceNameResponseManagement captures enum value "ResponseManagement"
	AuditQueryRequestServiceNameResponseManagement string = "ResponseManagement"

	// AuditQueryRequestServiceNameGroups captures enum value "Groups"
	AuditQueryRequestServiceNameGroups string = "Groups"

	// AuditQueryRequestServiceNameTelephony captures enum value "Telephony"
	AuditQueryRequestServiceNameTelephony string = "Telephony"

	// AuditQueryRequestServiceNameOutbound captures enum value "Outbound"
	AuditQueryRequestServiceNameOutbound string = "Outbound"

	// AuditQueryRequestServiceNameSpeechAndTextAnalytics captures enum value "SpeechAndTextAnalytics"
	AuditQueryRequestServiceNameSpeechAndTextAnalytics string = "SpeechAndTextAnalytics"

	// AuditQueryRequestServiceNameRouting captures enum value "Routing"
	AuditQueryRequestServiceNameRouting string = "Routing"
)

// prop value enum
func (m *AuditQueryRequest) validateServiceNameEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, auditQueryRequestTypeServiceNamePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *AuditQueryRequest) validateServiceName(formats strfmt.Registry) error {

	if err := validate.Required("serviceName", "body", m.ServiceName); err != nil {
		return err
	}

	// value enum
	if err := m.validateServiceNameEnum("serviceName", "body", *m.ServiceName); err != nil {
		return err
	}

	return nil
}

func (m *AuditQueryRequest) validateSort(formats strfmt.Registry) error {

	if swag.IsZero(m.Sort) { // not required
		return nil
	}

	for i := 0; i < len(m.Sort); i++ {
		if swag.IsZero(m.Sort[i]) { // not required
			continue
		}

		if m.Sort[i] != nil {
			if err := m.Sort[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sort" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *AuditQueryRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AuditQueryRequest) UnmarshalBinary(b []byte) error {
	var res AuditQueryRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
