// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PatchActionMap patch action map
//
// swagger:model PatchActionMap
type PatchActionMap struct {

	// The action that will be executed if this action map is triggered.
	Action *PatchAction `json:"action,omitempty"`

	// The action map's associated schedule groups.
	ActionMapScheduleGroups *PatchActionMapScheduleGroups `json:"actionMapScheduleGroups,omitempty"`

	// Type of activation.
	Activation *Activation `json:"activation,omitempty"`

	// Timestamp indicating when the action map was created. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	CreatedDate strfmt.DateTime `json:"createdDate,omitempty"`

	// Display name of the action map.
	// Required: true
	DisplayName *string `json:"displayName"`

	// Timestamp at which the action map is scheduled to stop firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	EndDate strfmt.DateTime `json:"endDate,omitempty"`

	// The globally unique identifier for the object.
	// Read Only: true
	ID string `json:"id,omitempty"`

	// Override organization-level frequency cap and always offer web engagements from this action map.
	IgnoreFrequencyCap bool `json:"ignoreFrequencyCap"`

	// Whether the action map is active.
	IsActive bool `json:"isActive"`

	// Timestamp indicating when the action map was last updated. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	ModifiedDate strfmt.DateTime `json:"modifiedDate,omitempty"`

	// URL conditions that a page must match for web actions to be displayable.
	// Required: true
	PageURLConditions []*URLCondition `json:"pageUrlConditions"`

	// The URI for this object
	// Read Only: true
	// Format: uri
	SelfURI strfmt.URI `json:"selfUri,omitempty"`

	// Timestamp at which the action map is scheduled to start firing. Date time is represented as an ISO-8601 string. For example: yyyy-MM-ddTHH:mm:ss[.mmm]Z
	// Format: date-time
	StartDate strfmt.DateTime `json:"startDate,omitempty"`

	// List of event conditions that must be satisfied to trigger the action map.
	TriggerWithEventConditions []*EventCondition `json:"triggerWithEventConditions"`

	// Probability conditions for outcomes that must be satisfied to trigger the action map.
	TriggerWithOutcomeProbabilityConditions []*OutcomeProbabilityCondition `json:"triggerWithOutcomeProbabilityConditions"`

	// Trigger action map if any segment in the list is assigned to a given customer.
	// Required: true
	TriggerWithSegments []string `json:"triggerWithSegments"`

	// The version of the action map.
	Version int32 `json:"version,omitempty"`

	// Weight of the action map with higher number denoting higher weight.
	Weight int32 `json:"weight,omitempty"`
}

// Validate validates this patch action map
func (m *PatchActionMap) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActionMapScheduleGroups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActivation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisplayName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateModifiedDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePageURLConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSelfURI(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggerWithEventConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggerWithOutcomeProbabilityConditions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggerWithSegments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchActionMap) validateAction(formats strfmt.Registry) error {
	if swag.IsZero(m.Action) { // not required
		return nil
	}

	if m.Action != nil {
		if err := m.Action.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("action")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("action")
			}
			return err
		}
	}

	return nil
}

func (m *PatchActionMap) validateActionMapScheduleGroups(formats strfmt.Registry) error {
	if swag.IsZero(m.ActionMapScheduleGroups) { // not required
		return nil
	}

	if m.ActionMapScheduleGroups != nil {
		if err := m.ActionMapScheduleGroups.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("actionMapScheduleGroups")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("actionMapScheduleGroups")
			}
			return err
		}
	}

	return nil
}

func (m *PatchActionMap) validateActivation(formats strfmt.Registry) error {
	if swag.IsZero(m.Activation) { // not required
		return nil
	}

	if m.Activation != nil {
		if err := m.Activation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("activation")
			}
			return err
		}
	}

	return nil
}

func (m *PatchActionMap) validateCreatedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("createdDate", "body", "date-time", m.CreatedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) validateDisplayName(formats strfmt.Registry) error {

	if err := validate.Required("displayName", "body", m.DisplayName); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(m.EndDate) { // not required
		return nil
	}

	if err := validate.FormatOf("endDate", "body", "date-time", m.EndDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) validateModifiedDate(formats strfmt.Registry) error {
	if swag.IsZero(m.ModifiedDate) { // not required
		return nil
	}

	if err := validate.FormatOf("modifiedDate", "body", "date-time", m.ModifiedDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) validatePageURLConditions(formats strfmt.Registry) error {

	if err := validate.Required("pageUrlConditions", "body", m.PageURLConditions); err != nil {
		return err
	}

	for i := 0; i < len(m.PageURLConditions); i++ {
		if swag.IsZero(m.PageURLConditions[i]) { // not required
			continue
		}

		if m.PageURLConditions[i] != nil {
			if err := m.PageURLConditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pageUrlConditions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pageUrlConditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchActionMap) validateSelfURI(formats strfmt.Registry) error {
	if swag.IsZero(m.SelfURI) { // not required
		return nil
	}

	if err := validate.FormatOf("selfUri", "body", "uri", m.SelfURI.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) validateStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.StartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("startDate", "body", "date-time", m.StartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) validateTriggerWithEventConditions(formats strfmt.Registry) error {
	if swag.IsZero(m.TriggerWithEventConditions) { // not required
		return nil
	}

	for i := 0; i < len(m.TriggerWithEventConditions); i++ {
		if swag.IsZero(m.TriggerWithEventConditions[i]) { // not required
			continue
		}

		if m.TriggerWithEventConditions[i] != nil {
			if err := m.TriggerWithEventConditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("triggerWithEventConditions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("triggerWithEventConditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchActionMap) validateTriggerWithOutcomeProbabilityConditions(formats strfmt.Registry) error {
	if swag.IsZero(m.TriggerWithOutcomeProbabilityConditions) { // not required
		return nil
	}

	for i := 0; i < len(m.TriggerWithOutcomeProbabilityConditions); i++ {
		if swag.IsZero(m.TriggerWithOutcomeProbabilityConditions[i]) { // not required
			continue
		}

		if m.TriggerWithOutcomeProbabilityConditions[i] != nil {
			if err := m.TriggerWithOutcomeProbabilityConditions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("triggerWithOutcomeProbabilityConditions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("triggerWithOutcomeProbabilityConditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchActionMap) validateTriggerWithSegments(formats strfmt.Registry) error {

	if err := validate.Required("triggerWithSegments", "body", m.TriggerWithSegments); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch action map based on the context it is used
func (m *PatchActionMap) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateActionMapScheduleGroups(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateActivation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePageURLConditions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSelfURI(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTriggerWithEventConditions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTriggerWithOutcomeProbabilityConditions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PatchActionMap) contextValidateAction(ctx context.Context, formats strfmt.Registry) error {

	if m.Action != nil {
		if err := m.Action.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("action")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("action")
			}
			return err
		}
	}

	return nil
}

func (m *PatchActionMap) contextValidateActionMapScheduleGroups(ctx context.Context, formats strfmt.Registry) error {

	if m.ActionMapScheduleGroups != nil {
		if err := m.ActionMapScheduleGroups.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("actionMapScheduleGroups")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("actionMapScheduleGroups")
			}
			return err
		}
	}

	return nil
}

func (m *PatchActionMap) contextValidateActivation(ctx context.Context, formats strfmt.Registry) error {

	if m.Activation != nil {
		if err := m.Activation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("activation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("activation")
			}
			return err
		}
	}

	return nil
}

func (m *PatchActionMap) contextValidateID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "id", "body", string(m.ID)); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) contextValidatePageURLConditions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PageURLConditions); i++ {

		if m.PageURLConditions[i] != nil {
			if err := m.PageURLConditions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pageUrlConditions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("pageUrlConditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchActionMap) contextValidateSelfURI(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "selfUri", "body", strfmt.URI(m.SelfURI)); err != nil {
		return err
	}

	return nil
}

func (m *PatchActionMap) contextValidateTriggerWithEventConditions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TriggerWithEventConditions); i++ {

		if m.TriggerWithEventConditions[i] != nil {
			if err := m.TriggerWithEventConditions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("triggerWithEventConditions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("triggerWithEventConditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *PatchActionMap) contextValidateTriggerWithOutcomeProbabilityConditions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TriggerWithOutcomeProbabilityConditions); i++ {

		if m.TriggerWithOutcomeProbabilityConditions[i] != nil {
			if err := m.TriggerWithOutcomeProbabilityConditions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("triggerWithOutcomeProbabilityConditions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("triggerWithOutcomeProbabilityConditions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *PatchActionMap) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PatchActionMap) UnmarshalBinary(b []byte) error {
	var res PatchActionMap
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
