// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{ .Package }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command


import (
	"context"
	goerrors "errors"
	"net/url"
	"net/http"
	"path"
	"strings"

	rtclient "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/spec"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"

	"golang.org/x/oauth2/clientcredentials"
	"golang.org/x/oauth2"

	{{ range .DefaultImports -}}
	{{ printf "%q" .}}
	{{ end -}}
	{{ range $key, $value := .Imports -}}
	{{ $key }} {{ printf "%q" $value }}
	{{ end -}}
)

const (
	// DefaultHost is the default Host
	// found in Meta (info) section of spec file
	DefaultHost string = {{ printf "%#v" .Host }}
	// DefaultBasePath is the default BasePath
	// found in Meta (info) section of spec file
	DefaultBasePath string = {{ printf "%#v" .BasePath }}
)

// DefaultSchemes are the default schemes found in Meta (info) section of spec file
var DefaultSchemes = {{ printf "%#v" .Schemes }}

type Config struct {
	// URL is the base URL of the upstream server
	URL *url.URL
	// Transport is an inner transport for the client
	Transport http.RoundTripper
}

func (c *Config) AuthorizeClientCredentials(clientID, clientSecret string) error {
	var (
		host = DefaultHost
	)

	if c.URL != nil {
		host = c.URL.Host
	}

	ctx := context.Background()

	if c.Transport != nil {
		if _, isa := c.Transport.(*oauth2.Transport); isa {
			return goerrors.New("transport already configured")
		}
		ctx = context.WithValue(ctx, oauth2.HTTPClient, &http.Client{Transport: c.Transport})
	}

	authHost := strings.Replace(host, "api.", "login.", 1)
	oauth2Config := &clientcredentials.Config{
		ClientID: clientID,
		ClientSecret: clientSecret,
		TokenURL: "https://" + path.Join(authHost, "oauth/token"),
		AuthStyle: oauth2.AuthStyleInHeader,
	}

	client := oauth2Config.Client(ctx)
	if _, err := client.Transport.(*oauth2.Transport).Source.Token(); err != nil {
		return err
	}
	c.Transport = client.Transport

	return nil
}

// New creates a new {{ humanize .Name }} HTTP client.
func New(c Config) *{{ pascalize .Name }} {
	var (
		host = DefaultHost
		basePath = DefaultBasePath
		schemes = DefaultSchemes
	)

	if c.URL != nil {
		host = c.URL.Host
		basePath = c.URL.Path
		schemes = []string{c.URL.Scheme}
	}

	transport := rtclient.New(host, basePath, schemes)
	if c.Transport != nil {
		transport.Transport = c.Transport
	}

	cli := new({{ pascalize .Name }})
	cli.Transport = transport
	{{ range .OperationGroups -}}
	cli.{{ pascalize .Name }} = {{ .Name }}.New(transport, strfmt.Default, nil)
	{{ end -}}

	return cli
}

func (cli *{{ pascalize .Name }}) SetDebug(debug bool) {
	cli.Transport.(*rtclient.Runtime).SetDebug(debug)
}

// {{ pascalize .Name }} is a client for {{ humanize .Name }}
type {{ pascalize .Name }} struct {
	{{ range .OperationGroups -}}
	{{ pascalize .Name }} *{{ snakize .Name }}.Client
	{{ end -}}
	Transport runtime.ClientTransport
}